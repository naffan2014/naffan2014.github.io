<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-05-14T00:32:03+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">池化技术</title><link href="http://localhost:4000/tech/2021/05/12/01.html" rel="alternate" type="text/html" title="池化技术" /><published>2021-05-12T00:00:00+08:00</published><updated>2021-05-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/12/01.html">&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3a3f5840610fee80b18b90e20b8082801300138d074.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　池化技术就是把一些能复用的实例放在一起，一般指的是内存里，而池这个概念也是一个虚拟的概念。这样做的好处是省去了每次消耗在新建、销毁这些实例的时间，从而提高了整体服务性能。在开发中，我们经常遇到的就是数据库的连接池和多线程的线程池。连接池的管理是核心。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;数据库连接池&quot;&gt;数据库连接池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　数据库包括关系型数据库和非关系型数据库两种。关系型数据库指的是mysql，非关系型数据库指的是redis。&lt;/p&gt;

&lt;p&gt;　　mysql连接池有两个重要的配置：最小连接数和最大连接数。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前连接数小于最小连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;如果连接池中有空闲连接，则使用空闲连接。
3。 如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接。这等价于建立一个新的连接。这些连接使用完成不会立马清除，而是放在池中等待复用最终空闲超过一段时间后自动释放。&lt;/li&gt;
  &lt;li&gt;如果当前连接数大于等于最大连接数，并且没有空闲连接了，则进入等待队列，在超时时间内等待空闲连接。&lt;/li&gt;
  &lt;li&gt;超时之后，则提示超时失败。获取数据库连接失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　redis连接池有3个重要的配置：最大连接数，最小空闲数，最大空闲数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前连接小于最大连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;当前连接数大于等于最大连接数，超出的连接进入等待队列&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;，判断是否开启&lt;code&gt;blockWhenExhausted&lt;/code&gt;，是则等待获取连接，否则抛错连接池已耗尽。&lt;/li&gt;
  &lt;li&gt;当前连接数小于最小空闲数，则预热最小空闲数连接。&lt;/li&gt;
  &lt;li&gt;当前连接数大于最大空闲数，则强制销毁这些多出来的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;线程池&quot;&gt;线程池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　JDK1.5中引入的ThreadPoolExecutor就是一种线程池的实现，它有两个重要的参数：coreThreadCount和maxThreadCount。这两个参数控制着线程池的执行过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程数少于coreThreadCount时，则创建新的线程处理请求。&lt;/li&gt;
  &lt;li&gt;如果当前线程数大于coreThreadCount则将超出的任务进队列，由当前空闲的线程执行。&lt;/li&gt;
  &lt;li&gt;当队列中的任务对接满时，则继续创建线程，直到maxThreadCount。&lt;/li&gt;
  &lt;li&gt;当前线程数达到maxThreadCount时还有新的任务，就将其按照抛弃策略进行抛弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc7xbdxj67j30wk0ouqb3.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JDK线程池提交任务示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　连接池和线程池在开发过程中并不陌生，但是想真正弄懂他们还是需要借助阅读源码的帮助。在使用上如果遇到了一些困惑的话，可以查阅相关资料或者探索源码如何解决的。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">一种优化连接的方案，各种地方都有可能用到这种技术</summary></entry><entry><title type="html">我对JVM的解析和总结</title><link href="http://localhost:4000/tech/2021/05/11/01.html" rel="alternate" type="text/html" title="我对JVM的解析和总结" /><published>2021-05-11T00:00:00+08:00</published><updated>2021-05-11T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/11/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/11/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;java运行时数据区&quot;&gt;Java运行时数据区&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jvm会将内存划分为若干个不同的数据区域。如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://cdn.jikewenku.com/wp-content/uploads/2021/01/74e01322f26270ccfe235ead6215d271.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JVM运行时数据区域&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序计数器：线程私有，指向当前线程正在执行的字节码指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈：java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧压入栈，当方法&lt;code&gt;正常返回&lt;/code&gt;或者&lt;code&gt;抛出未捕获的异常&lt;/code&gt;时，栈帧就会出栈。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jmm-java内存模型&quot;&gt;JMM Java内存模型&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;堆的内存划分&quot;&gt;堆的内存划分&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;gc垃圾回收&quot;&gt;GC垃圾回收&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;hotspot-虚拟机详解&quot;&gt;HotSpot 虚拟机详解&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot,jvm" /><summary type="html">Java运行时数据区</summary></entry><entry><title type="html">spring-data-redis中的Jackson2JsonRedisSerializer研读</title><link href="http://localhost:4000/tech/2021/05/07/01.html" rel="alternate" type="text/html" title="spring-data-redis中的Jackson2JsonRedisSerializer研读" /><published>2021-05-07T00:00:00+08:00</published><updated>2021-05-07T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/07/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/07/01.html">&lt;p&gt;spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。&lt;/p&gt;

&lt;p&gt;首先，Jackson2JsonRedisSerializer一共有6个方法。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(JavaType javaType)&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;deserialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;serialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;setObjectMapper&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getJavaType&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Creates a new {@link Jackson2JsonRedisSerializer} for the given target {@link Class}.
	 *
	 * @param type
	 */
	public Jackson2JsonRedisSerializer(Class&amp;lt;T&amp;gt; type) {
		this.javaType = getJavaType(type);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据传入的参数类型，通过getJavaType方法指定为databind的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Returns the Jackson {@link JavaType} for the specific class.
	 * &amp;lt;p&amp;gt;
	 * Default implementation returns {@link TypeFactory#constructType(java.lang.reflect.Type)}, but this can be
	 * overridden in subclasses, to allow for custom generic collection handling. For instance:
	 *
	 * &amp;lt;pre class=&quot;code&quot;&amp;gt;
	 * protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
	 * 	if (List.class.isAssignableFrom(clazz)) {
	 * 		return TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, MyBean.class);
	 * 	} else {
	 * 		return super.getJavaType(clazz);
	 * 	}
	 * }
	 * &amp;lt;/pre&amp;gt;
	 *
	 * @param clazz the class to return the java type for
	 * @return the java type
	 */
	protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
		return TypeFactory.defaultInstance().constructType(clazz);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaType类属于com.fasterxml.jackson.databind包。它是一种令牌类的基类，用于保存信息和反序列化器的key。通过getJavaType方法经过反射来构造出指定的class。我们看到其中应用到了TypeFactory,用TypeFactory的作用就是快速的获取到clazz相对应的具体类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class TypeFactory implements java.io.Serializable
{
    //将clazz传入，通过_formAny方法构造。Class&amp;lt;?&amp;gt; 是实现了Type接口
    public JavaType constructType(Type type) {
        return _fromAny(null, type, EMPTY_BINDINGS);
    }
    
    ....
    
     /**
     * Factory method that can be used if type information is passed
     * as Java typing returned from &amp;lt;code&amp;gt;getGenericXxx&amp;lt;/code&amp;gt; methods
     * (usually for a return or argument type).
     */
    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class&amp;lt;?&amp;gt;) {
            // Important: remove possible bindings since this is type-erased thingy
            //判断type是一个简单class。然后调用_formClass
            //ClassStack是一个工具类，用来记录调用栈信息的上下文。
            //EMPTY_BINDINGS是TypeBindings中的常量。TypeBindings是用于解析给定类的类型参数的助手类。也就是说这个常量为空绑定关系。
            resultType = _fromClass(context, (Class&amp;lt;?&amp;gt;) type, EMPTY_BINDINGS);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {...}
    ...
    }
    
    /**
     * @param bindings Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(ClassStack context, Class&amp;lt;?&amp;gt; rawType, TypeBindings bindings)
    {
        // Very first thing: small set of core types we know well:
        //第一件事就是通过rawType来判断是哪种众所周知的简单类型。首先判断是否是原始类型，并且是否是BOOL，INT，LONG。如果不是就是String，Object。否则返回null
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance
        final Object key;
        if ((bindings == null) || bindings.isEmpty()) {
        //key是这种Bool Int Long String object中的一种
            key = rawType;
        } else {
            key = bindings.asKey(rawType);
        }
        //_typeCache是一个LRUMap。LRUMap其实底层是个ConcurrentHashMap。它用来帮助我们避免核心类型的重复解析。尤其为了泛型的解析。
        result = _typeCache.get(key); // ok, cache object is synced
        if (result != null) {
            return result;
        }
        //一般到这里就结束了。但是，如果通过我们传入的rawType没有找到绑定的关系，那就有可能是个复杂结构的结构体（递归引用）。接下来就需要通过调用栈来追踪整个结构了。
        // 15-Oct-2015, tatu: recursive reference?
        if (context == null) {
            context = new ClassStack(rawType);
        } else {
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                //可以看到，resolvedRecursiveType这个方法是用来自我引用的一个内部类型。他继承自TypeBase，TypeBase继承自javaType。
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
            }
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
        }
        //到这里，可以将递归引用的结构解析到context变量里了。
        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
         //首先解析父类型层次结构   
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                //返回的是一个JavaType的数组。
                //如果是个超接口（superInterface），通过反射返回的必须是实际用过的类型（interface or class）。
                //如果是个class，返回的是个数组，数组中包含着所有实现过的接口。
                //如果是个interface，返回的是个数组，数组中包含所有直接继承过的接口。
                //如果是个class或者interface，就返回个一个长度为0的数组。
                //如果是基础类型或者void，就返回一个长度为0的数组。
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so cannot drop those
                //返回class表示的实体(类、接口、基本类型型或void)的直接超类
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, &quot;simple&quot; class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
            }
        }
        context.resolveSelfReferences(result);
        // 16-Jul-2016, tatu: [databind#1302] is solved different way, but ideally we shouldn't
        //     cache anything with partially resolved `ResolvedRecursiveType`... so maybe improve
        if (!result.hasHandlers()) {
            _typeCache.putIfAbsent(key, result); // cache object syncs
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonReisSerializer(JavaType javaType)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个构造方法，参数是JavaType类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;deserialize(@Nullable byte[] bytes)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;反序列化方法，可为null的byte数组为参数。如果是空或者null的话，返回null。否则，通过ObjectMapper将byte数组进行反序列化。&lt;/p&gt;

&lt;p&gt;ObjectMapper提供读和写JSON的能力。不论是转成POJO还是从POJO转出，或者是转成JSON还是从JSON转出，还是一些相关的转化功能。ObjectMapper都可以高定制化的兼容不同种的JSON格式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;serialize(@Nullable Object t)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;序列化方法，同上。t如果为null，则返回空byte数组。否则，将t序列化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setObjectMapper(ObjectMapper objectMapper)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法比较有用，它可以用来自定义JSON序列化进程的。相关设置可以参见ObjectMapper.java中的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ObjectMapper mapper = new ObjectMapper();
		mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		serializer.setObjectMapper(mapper);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getJavaType(Class&amp;lt;?&amp;gt; clazz)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法是被Jackson2JsonRedisSerializer方法调用的，用途就是返回指定class的jackson格式。&lt;/p&gt;

&lt;p&gt;通过简单阅读了这个类的源码，我对这个类也有了大致的了解。作为spring-data-redis对redis的封装中的一个策略，这个策略满足了要保存的数据有比较复杂的层级结构，而且效率还是非常高的。建议用这个策略进行保存，只是可读性差了一些。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。</summary></entry><entry><title type="html">springboot的策略模式</title><link href="http://localhost:4000/tech/2021/05/02/01.html" rel="alternate" type="text/html" title="springboot的策略模式" /><published>2021-05-02T00:00:00+08:00</published><updated>2021-05-02T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/02/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/02/01.html">&lt;p&gt;策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。&lt;/p&gt;

&lt;p&gt;当你用springboot的时候，会牵扯到如何将类委托给spring容器，如果你按照策略模式的传统写法，就会遇到类似问题。所以，我们应该将不同的策略实现公用的接口，也就是面向接口编程。&lt;/p&gt;

&lt;p&gt;首先，我们定义一个接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ICreateOrderAndMissionStrategy {

	/**
	 * 创建订单和任务。不同的策略应该对这个方法进行重写
	 */
	void doCreateOrderAndMission(KCameraOrderAbstractCreateDTO oscVo);

	/**
	 * 获取类型，每个策略都需要你定义一个类型，比如业务1就定义为1，比如业务2就定义为2。当然，你也可以定义成不同类型。按照你的习惯即可
	 * @return Integer
	 */
	Integer getType();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，构造一个类，这个类的目的就是驱动你的策略。同时，也是这个类将你的策略装配到spring中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class CreateOrderMissionStrategyService {

	/**
	 * 策略类中的成员map变量，保存各种策略类.可以看到我将ICreateOrderAndMissionStrategy接口构造成一个map。通过我之前定义的数字来获取value。也就是能够拿到相应的策略。
	 */
	Map&amp;lt;Integer, ICreateOrderAndMissionStrategy&amp;gt; strategyMap = new HashMap&amp;lt;&amp;gt;(8);

	/**
	 * 构造函数，通过将spring管理的所有策略类注册进成员map变量中。
	 * 这个方法很重要，因为它驱动了策略类的装配。
	 * @param strategies List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt;
	 */
	public CreateOrderMissionStrategyService(List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt; strategies) {
		for (ICreateOrderAndMissionStrategy strategy : strategies) {
			strategyMap.put(strategy.getType(), strategy);
		}
	}

	/**
	 * 处理策略程序。通过strategyType得到我想要的策略类，然后进行调用
	 * @param strategyType 策略类型
	 * @param oscVo 业务变量
	 * @throws BizException 业务异常
	 */
	public void executeStrategy(Integer strategyType, KCameraOrderAbstractCreateDTO oscVo) throws BizException{
		ICreateOrderAndMissionStrategy strategy = strategyMap.get(strategyType);
		if(strategy == null){
			throw new BizException(&quot;未找到事件处理实现类，strategyType:&quot; + strategyType);
		}
		strategy.doCreateOrderAndMission(oscVo);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我可以开始根据不同的业务进行不同的策略了。我举两个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略A
public class AStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.A.getCode();  // 这个是我定义的策略类型的枚举类。我A为1，B为2
	}
	
	/**
	 * A策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略B
public class BStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.B.getCode();  	}
	
	/**
	 * B策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在真正的逻辑中，我们就可以直接使用这个模式了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Demo{

    public void Business(){
        String[] taskTypeList = oscVo.getTaskTypes().split(&quot;,&quot;);
			for (String i : taskTypeList) {
    createHouseSourceOrderAndMission.executeStrategy(Integer.valueOf(i),oscVo);
            			}
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。</summary></entry><entry><title type="html">2021年的五一劳动节</title><link href="http://localhost:4000/life/2021/05/01/01.html" rel="alternate" type="text/html" title="2021年的五一劳动节" /><published>2021-05-01T00:00:00+08:00</published><updated>2021-05-01T00:00:00+08:00</updated><id>http://localhost:4000/life/2021/05/01/01</id><content type="html" xml:base="http://localhost:4000/life/2021/05/01/01.html">&lt;blockquote&gt;
  &lt;p&gt;我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2021年的劳动节是自疫情之后中国的第一个能够群体聚集的首个节日。为了这个节日中国政府将五一前后的周末各调休了一天，用来凑出这次有五天假期的劳动节。就是因为这五天的假期，全国人名举国出游。很庆幸，我们没有参与其中，我们只是全程在抖音上参观景点的盛景。看着视频里“我后悔了，不想出来玩了，我想回家”，心中虽有偷着乐的愉悦心情，但也还是计划着接下来的几天出去走走，只是仅在北京周边自驾玩一玩。&lt;/p&gt;

&lt;p&gt;五一前一周末我从网上订购了一款4人帐篷以及户外炊具，就想着用特斯拉载着家人去环郊，找一片草坪停下车来，打开帐篷，烧着咖啡，看着风景，带上一本好书，悠闲的享受整个下午。&lt;/p&gt;

&lt;p&gt;五一当天，雷打不动的还是固定节目-跟家人们吃饭。说心里话，这种正日子一起坐下来吃个饭，聊聊天，悠闲的慢生活是最佳选择。但是，妈妈偏偏把之前商量好的包饺子改成了做家常饭。妈妈跟我说回来吃一次不容易，还是想给我做一些我喜欢吃的菜。结果是，大家坐在一起吃饭，还不到10分钟就已经吃完了，加上收拾碗筷和擦桌子洗碗，总共加起来不超过20分钟。就这样，难得的中午时光被这么临时的改动浪费了。其实，在前几天我已经跟他们沟通叫上双方的服务一起在我家的小院烤肉，可是在做决定的那天下午，手机的头条发来五一会有8级大风，于是我才同意的改为在705吃饺子。这么说，其实这都是天意。我也没得办法。&lt;/p&gt;

&lt;p&gt;下午，父母是需要睡午觉的，但是我和媳妇不困，不想睡觉了。于是，我提议我们俩去新华百货转一转，让父母睡完觉再跟我联系，到时候一起赶赴大家庭的晚餐聚会。跟媳妇转商场没有什么说的，就是逛和买。但想喝一杯DQ的脏脏奶昔，结果发现到了新街口豁口，DQ却在装修，查了一下最近的DQ门店远在2.4km以外，于是作罢。媳妇提议去对面的咖啡店喝杯咖啡，因为之前媳妇和她闺蜜去喝过，感觉很好喝，所以她建议我跟她再去一次。首先我是拒绝的，但是我也没有什么好的建议，于是妥协了。不过，也是因为这次妥协，我也真正意义的喝上了一杯手磨的咖啡。也学会了一些品咖啡的方法。咖啡的苦要像巧克力的苦，酸要像果酸，咽下去的时候喉咙会感受到回甘。老婆给我点的咖啡应该还是不错的，只是自己没有经验，我也就学着尝试品尝了。回想之前在回龙观的酒吧，老板教我品威士忌，两者相比较来说方法有些相像。&lt;/p&gt;

&lt;p&gt;晚上，大家的聚会还是比较圆满的，只是餐馆包间的桌子比较小。很多人都是侧着身吃饭，这可把我的三姨尴尬坏了，看得出来三姨对这次选地的不满意，但是我也不想让三姨觉得难过，所以还是以很好吃夸赞了这次晚饭，只是我能感觉的出来三姨知道我是在宽慰她。&lt;/p&gt;

&lt;p&gt;回到705写下了这篇日记。晋升的失败没有跟妈妈说，我怕她为我担心，我的不干不应写在脸上。我需要时间再次审视自己的缺陷。在接下来的一年中补齐这块短板。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="劳动节" /><summary type="html">我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。</summary></entry><entry><title type="html">有关字符集知识的总结</title><link href="http://localhost:4000/tech/2019/09/24/01.html" rel="alternate" type="text/html" title="有关字符集知识的总结" /><published>2019-09-24T00:00:00+08:00</published><updated>2019-09-24T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/09/24/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/09/24/01.html">&lt;p&gt;　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。&lt;/p&gt;

&lt;p&gt;　　因为字符集类问题是很庞大的，所以让我们来规定几种字符集先。让我就unicode,gbk,ascii等字符集先做一定的温习。&lt;/p&gt;

&lt;p&gt;　　首先，我们来说说我们比较常用的编码之间的关系，好来展开这篇文章的复习。当计算机问世的时候因为是美国人造的，所以美国人就用了些英文字母和标点符号和辅助型符号，这些字符加起来也不过128位，所以就诞生了&lt;code&gt;ASCII&lt;/code&gt;码。后来发展到了欧洲，欧洲那么多国家，每个国家的字母都不太一样，所以人们就扩充了字符集，从而出了拉丁语系的&lt;code&gt;ISO8859-1&lt;/code&gt;字符集。再后来中国人参与进来了，我们中国字常用就7000多个。以现有的字符集根本承载不下来那么多字体，那人们就创造出来了&lt;code&gt;GBK&lt;/code&gt;字符集，这种字符集和之前两种的区别就是GBK使用两个字节来存储的，其中收录了21003个字符。再后来又出了&lt;code&gt;GB18030&lt;/code&gt;，可以收录数量达到了70244个。这个编码采用了1，2，4字节的存储方式，具体存储方式先不说。这个时候人们发现随着用来存储的字节的增多，存储量也变的巨大了。所以，传输的过程中效率问题捉襟见肘。于是，人们就开始考虑更好的存储方法，既能够囊括更多的字符同时存储的容量又不会急剧的膨胀。那么就需要一种智慧的存储方案来解决，于是&lt;code&gt;unicode&lt;/code&gt;编码营运而生。unicode编码采用变长的存储结构，通过高位的特殊位数来规定采用的字节数，从而达到了目的。unicode中分为三类:&lt;code&gt;utf8&lt;/code&gt;,&lt;code&gt;utf16&lt;/code&gt;和&lt;code&gt;utf32&lt;/code&gt;。主要用的还是utf8，而且utf8已然成为现如今世界上最为普遍的编码。&lt;/p&gt;

&lt;h1 id=&quot;一ascii码&quot;&gt;一、ASCII码&lt;/h1&gt;

&lt;p&gt;　　我们知道，计算机内部存储的数据都是二进制值。每一个二进制位（bit）有&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;两种状态。因此，八个二进制可以组合出256种状态，由八位组成一个字节，即从&lt;code&gt;00000000&lt;/code&gt;到&lt;code&gt;11111111&lt;/code&gt;。下表是128种ascii码表。当时规定最&lt;code&gt;高位为0&lt;/code&gt;，剩下的七位来分别表示这128个字符。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/asciifull.gif&quot; alt=&quot;ascii表格&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;二非ascii码&quot;&gt;二、非ASCII码&lt;/h1&gt;

&lt;p&gt;　　可是，当高1位为1的时候，还没有利用上。所以，有的国家就开辟了剩下的128个字符，但是随之而来的问题也接踵而来。问题是每个国家都可以扩充这后128位，最终导致前一128个都是相同的，但是后128个就不同国家都不一样了。如果再这么继续下去整个世界对于字符上就不再统一了，这简直就是个噩梦。于是，美国人开发出了unicode编码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/extend.gif&quot; alt=&quot;扩展的&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;三unicode码&quot;&gt;三、Unicode码&lt;/h1&gt;

&lt;p&gt;　　Unicode是一本很厚的字典，记录着世界上所有字符对应的一个数字。我们可以通过这两个网站查看到每个字符相对应的存储数值，&lt;a href=&quot;https://home.unicode.org/&quot;&gt;unicode.org&lt;/a&gt;和&lt;a href=&quot;http://www.chi2ko.com/tool/CJK.htm&quot;&gt;unicode对照表&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;四utf-8&quot;&gt;四、UTF-8&lt;/h1&gt;

&lt;p&gt;　　unicode主要遇到了两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何让计算机区分出来&lt;/li&gt;
  &lt;li&gt;如何使存储空间更小&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　UTF-8是目前互联网上使用最广泛的一种unicode编码方式了，它主要的特点就是变长。它可以使用1-4个字符表示一个字符（零几年还有6个字符表示的方法，但是后来取消掉了）。规则如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。&lt;/li&gt;
  &lt;li&gt;对于需要使用 N 个字节来表示的字符（N &amp;gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode 十六进制码点范围&lt;/th&gt;
      &lt;th&gt;UTF-8 二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0000 - 0000 007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0080 - 0000 07FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0800 - 0000 FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0001 0000 - 0010 FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　下面，我们用&lt;code&gt;帆&lt;/code&gt;字为例进行讲解&lt;/p&gt;

&lt;p&gt;　　帆的unicode十六进制是&lt;code&gt;5E06&lt;/code&gt;，补全后位&lt;code&gt;0000 5E06&lt;/code&gt;，二进制是&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;。跟具上表可以得知是在第三列范围内的。所以帆的utf8编码需要三个字节，即格式为&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;。从最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0，就得到了&lt;code&gt;11100101 10111000 10000110&lt;/code&gt;，转换成十六进制后得到utf8十六进制&lt;code&gt;E5 B8 86&lt;/code&gt;。我们可以通过&lt;a href=&quot;http://www.mytju.com/classcode/tools/encode_utf8.asp&quot;&gt;utf8和unicode转化工具&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;　　另外，说一下我们的通常表示法。utf8的16进制数表示开头加&lt;code&gt;0x&lt;/code&gt;，unicode开头加&lt;code&gt;U+&lt;/code&gt;。所以，帆字的utf8的16进制应该是&lt;code&gt;0xE5 0xB8 0x86&lt;/code&gt;，而unicode的16进制表示应该是&lt;code&gt;U+5E06&lt;/code&gt;。这个注意一下就好了，别人家写出来咱分辨不出来。&lt;/p&gt;

&lt;h1 id=&quot;五十六进制转换十进制方法&quot;&gt;五、十六进制转换十进制方法&lt;/h1&gt;

&lt;p&gt;　　这节其实是我在写这篇文章的时候遇到的问题。在这里我也就不单独拿出来写了，直接在这里温故而知新吧。我们在表示十六进制的时候，采用的表示法是&lt;code&gt;0x&lt;/code&gt;。比如我们表示&lt;code&gt;0xA4&lt;/code&gt;，其对应的十进制数怎么算呢？首先，我们要知道16进制的权为16，这个数转化为是十进制的方法和二进制转换成十进制一个道理。 是10(A) * 16的一次方+4 * 16的0次方，最终等于164.那我们算下&lt;code&gt;0xFF&lt;/code&gt;，是不是就等于255呢?答案是没错。&lt;/p&gt;

&lt;h1 id=&quot;六大端法和小端法&quot;&gt;六、大端法和小端法&lt;/h1&gt;

&lt;p&gt;　　计算机在存储器重排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34，它的存储方式为下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/09/26/ZxRMdziesI6Th9v.png&quot; alt=&quot;大端法和小端法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　TF-32用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理），如果不分大小端的话，那么就会出现解读错误，比如我们一次要处理四个字节 12 34 56 78，这四个字节是表示0x12 34 56 78还是表示0x78 56 34 12 ，不同的解释最终表示的值不一样。&lt;/p&gt;

&lt;h1 id=&quot;七utf-16&quot;&gt;七、UTF-16&lt;/h1&gt;

&lt;p&gt;　　utf-16也是边长字节表示，我们可以简单看看其表示的方法，不用太细的去看，等到真碰上了再思考也不迟。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于编号在U+0000到U+FFFF的字符（常用字符集），直接用两个字节表示。&lt;/li&gt;
  &lt;li&gt;编号在 U+10000到U+10FFFF之间的字符，需要用四个字节表示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　同样，UTF-16 也有字节的顺序问题（大小端），所以就有UTF-16BE表示大端，UTF-16LE表示小端。&lt;/p&gt;

&lt;h1 id=&quot;八utf-32&quot;&gt;八、UTF-32&lt;/h1&gt;

&lt;p&gt;　　utf-32是字符对应标号的证书二进制形式，四个字节，直接转化就可以了。比如&lt;code&gt;帆&lt;/code&gt;的unicode为&lt;code&gt;U+5E06&lt;/code&gt;，直接转化成二进制后得到：&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以根据他们高低字节的存储位置来判断他们所代表的含义，所以在编码方式中有 UTF-32BE 和 UTF-32LE ，分别对应大端和小端，来正确地解释多个字节（这里是四个字节）的含义。&lt;/p&gt;

&lt;h1 id=&quot;九随便用go玩玩&quot;&gt;九、随便用GO玩玩&lt;/h1&gt;

&lt;p&gt;　　本来想用GO实现下编码互转的，但是后来发现GO原声只支持UTF-8编码，如果想用GB2312等编码还得去get包，我尝试了下但是timeout了。哎，临近国庆，很多东西都用不了啦。以后有需要再弄吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;unicode/utf8&quot;
)

func main(){
	b := []byte(&quot;Hello, 帆&quot;)
	for len(b) &amp;gt;0{
		r,size := utf8.DecodeLastRune(b)
		fmt.Printf(&quot;%c %v\n&quot;,r,size)
		b = b[:len(b)-size]
	}
	c := []byte(&quot;帆&quot;)
	fmt.Println(c)
}

打印结果：
帆 3
  1
, 1
o 1
l 1
l 1
e 1
H 1

[229 184 134]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以看到，utf8的中文在GO中是占3个字符的。而且帆的utf8的16进制数&lt;code&gt;E5 B8 86&lt;/code&gt;转换成十进制就是&lt;code&gt;[229 184 134]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6bdc0d52620a&quot;&gt;彻底弄懂 Unicode 编码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode 和 UTF-8&lt;/a&gt;&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="charset" /><summary type="html">　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。</summary></entry><entry><title type="html">Mysql中的too many connections问题背后</title><link href="http://localhost:4000/tech/2019/09/23/01.html" rel="alternate" type="text/html" title="Mysql中的too many connections问题背后" /><published>2019-09-23T00:00:00+08:00</published><updated>2019-09-23T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/09/23/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/09/23/01.html">&lt;p&gt;　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。&lt;/p&gt;

&lt;p&gt;　　在中秋节前的那个周二，是我们公司上线的窗口期。在晚上6点左右的时候，同事告诉我50那台机子挂了，测试数据库也在这台机子上，所以也挂掉了。我们上线前QA是需要在测试线回归一下问题后才能上线的，但是由于测试数据库挂了，导致QA的测试不能够进行，时间太短又来不及去迁移整个数据库，看来只能求助OP同学了。后来，OP同学告诉我们50这台服务器是我们的自运维机器，OP们也不知道如何操作（他们其实是不愿意管）。好说歹说OP才腾出功夫将服务器重启了（后来得知，其实并没有重启，而是50这台服务器是虚机，因为某些原道导致机器卡住了，于是虚机就被暂存起来了，然而OP做的就是吧暂存的虚机重新打开就行了），这样看似一切正常的操作，突然mysql就出现了too many connections的报错，这回我是根本连不上mysql了。经过询问DBA，这种情况是数据库太多的僵尸链接导致的，僵尸链接没有放开连接，导致后边的连接根本请求不到资源。这下问题就来了，我没有root权限（其实知道这台机子因为年代久远的原因没有人知道他的root权限了），那怎么办才能够清除这些僵尸链接呢？好了，前言已经铺垫的很多了，我也确实需要回忆一下我的解决方案和问题背后涉及的原理了。&lt;/p&gt;

&lt;h3 id=&quot;问题解释&quot;&gt;问题解释&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if you get a Too many connections error when you try to connect to the mysqld server, this means that all available connections are in use by other clients.

发生too many connections的错误是因为所有可用的连接都被其他客户端保持着呢。

The number of connections permitted is controlled by the max_connections system variable. The default value is 151 to improve performance when MySQL is used with the Apache Web server. (Previously, the default was 100.) If you need to support more connections, you should set a larger value for this variable.

max_connections定义了被允许连接的数量。默认值是151，151是一个性能较高的值，尤其在web服务上。如果你需要更多的连接数，需要设置更大的数字。

mysqld actually permits max_connections+1 clients to connect. The extra connection is reserved for use by accounts that have the CONNECTION_ADMIN or SUPER privilege. By granting the privilege to administrators and not to normal users (who should not need it), an administrator who also has the PROCESS privilege can connect to the server and use SHOW PROCESSLIST to diagnose problems even if the maximum number of unprivileged clients are connected. See Section 13.7.6.29, “SHOW PROCESSLIST Syntax”. 
 
 mysqld进程使max_connections+1为客户端最大数量，这1个特别的连接是提供给最高用户权限的人用的。最高权限的人可以单独拥有这个链接，以此在发生问题时可以登录到mysql中查看问题所在，通过show processlist命令可以分析问题。也就是说151个连接全部被打满时，仍然有个第152链接等待这个最高权限的人进入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面的引用出自mysql用户手册的原语。这只是告诉了我们在这种错误的情况下我们是可以做出调整的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like '%max_con%' \G;
*************************** 1. row ***************************
Variable_name: max_connect_errors
        Value: 100
*************************** 2. row ***************************
Variable_name: max_connections
        Value: 151
*************************** 3. row ***************************
Variable_name: mysqlx_max_connections
        Value: 100
*************************** 4. row ***************************
Variable_name: performance_schema_max_cond_classes
        Value: 100
*************************** 5. row ***************************
Variable_name: performance_schema_max_cond_instances
        Value: -1
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;　　当我们拥有mysql的root权限的时候我们可以直接运行命令&lt;code&gt;set global max_connections = xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;　　当我们没有mysql的root权限时我们可以通过重启数据库来解决。还有一种是直接在命令端更改（参见：&lt;a href=&quot;https://www.percona.com/blog/2010/03/23/too-many-connections-no-problem/&quot;&gt;外国连接&lt;/a&gt;），外国人给了一个语句&lt;code&gt;gdb -p  $(cat mysqld.pid) -ex &quot;set max_connections=xxx&quot; -batch&lt;/code&gt;来操作，这个骚气的操作我暂时没看太懂，gdb怎么就能够操作这个呢？&lt;/p&gt;

&lt;h3 id=&quot;自己测试&quot;&gt;自己测试&lt;/h3&gt;
&lt;p&gt;　　知道了问题产生的原理了，那么我就自己模拟了一下，看看我能不能复现出这类问题&lt;/p&gt;

&lt;p&gt;　　首先，就是需要创建出是2个账号，然后再把max_connections设置为1.这样，当A用户连接上后，B去连接就连接不上了，然而我的root却能够登录。如果能够达到这样的效果，就说明了我复现成功了。&lt;/p&gt;

&lt;p&gt;　　值得注意的是mysql自升到了8.0以后，创建用户后需要紧跟着为用户分配权限。如果不这么做，你是之后再分配权限的话，就会得到&lt;code&gt;You are not allowed to create a user with GRANT&lt;/code&gt;的错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create user `A`@localhost identified by 'testA';
mysql&amp;gt; grant select on laravel562.* to `test3`@`localhost`; //创建用户后直接分配读权限

Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我一共创建了两个用户分别是testA和testB。当我登录testA的时候，我通过root登录后运行```show processlist``后发现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*************************** 1. row ***************************
                 host: locahost
                 user: testA
authentication_string: *94BDCEBE19083CE2A1F959FD02F964C7AF4CFC29
               plugin: mysql_native_password
*************************** 2. row ***************************
                 host: localhost
                 user: mysql.infoschema
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 3. row ***************************
                 host: localhost
                 user: mysql.session
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 4. row ***************************
                 host: localhost
                 user: mysql.sys
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 5. row ***************************
                 host: localhost
                 user: root
authentication_string: *332A08EE56001FE5139E2FB111080AA441242991
               plugin: mysql_native_password

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以发现结果中可以看到testA和root两个用户的连接情况。当我这个时候让testB连接的话，testB就会报too many connections的错误了。 我再让testA关闭掉，再连testB就可以了。&lt;/p&gt;

&lt;p&gt;　　之后，我删除了testA和testB，应用&lt;code&gt;drop user `test`@`localhost`;&lt;/code&gt;。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html">　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。</summary></entry><entry><title type="html">《创造力-跳出盒子思考》</title><link href="http://localhost:4000/books/2019/05/24/01.html" rel="alternate" type="text/html" title="《创造力-跳出盒子思考》" /><published>2019-05-24T00:00:00+08:00</published><updated>2019-05-24T00:00:00+08:00</updated><id>http://localhost:4000/books/2019/05/24/01</id><content type="html" xml:base="http://localhost:4000/books/2019/05/24/01.html">&lt;p&gt;1.请跳出盒子思考&lt;/p&gt;

&lt;p&gt;　　答案很简单，是不是？解这道题的关键在于，在正方形范围以外画线。你解不出这道题的原因在于，被正方形框住了。哈哈！&lt;/p&gt;

&lt;p&gt;　　其实，在我们的脑子里，类似的框框很多。这些框框，有的来自于我们的思维定势，有的来自于认知偏差，有的是因为经历、见识、眼光等方面的局限。&lt;/p&gt;

&lt;p&gt;　　所以，我们一定要抱着开放的心态，去看待万事万物。对于你不习惯的新鲜事物，不要轻易地否定，可以抱着“一切有待验证”的态度，去了解它，探寻它；对于没有经历和没有见过的事情，不要忙着下结论，以防出现“黑天鹅事件”。&lt;/p&gt;

&lt;p&gt;2.运用发散性思维&lt;/p&gt;

&lt;p&gt;　　发散性思维，就是遇到问题的时候，能从多角度、多侧面、多层次、多结构去思考，去寻找答案。就像下图中所说的那样：想想左边，又想想右边，想想低处，再想想高处。只要你尝试，你就会有许多奇思妙想！&lt;/p&gt;

&lt;p&gt;　　有两种方法可以很好地锻炼你的发散性思维：&lt;/p&gt;

&lt;p&gt;　　一是利用思维导图。当你思考某一个问题的时候，就在纸的中心画个圆圈，写下你思考的问题，然后向外画开，把各种可能的点子和方案都写下来。&lt;/p&gt;

&lt;p&gt;　　二是运用联想。比如说看到一个圆，你能想到什么？是数字0，字母O，还是排球、网球、乒乓球，或者是地球、月亮、太阳……放开你的思维，像儿童一样，自由地想象吧。&lt;/p&gt;

&lt;p&gt;3.勇敢突破舒适区&lt;/p&gt;

&lt;p&gt;　　心理学表明，人们天生喜欢稳定，喜欢呆在舒适区，不愿意冒风险。&lt;/p&gt;

&lt;p&gt;　　而创新则意味着变化，意味着不确定性，意味着冒风险，这与人与生俱来的惰性相违背。&lt;/p&gt;

&lt;p&gt;　　所以，必要的时候，你需要自己推自己一把，勇敢跳出舒适区，接受新的环境和挑战。&lt;/p&gt;

&lt;p&gt;　　比如，尝试学习一项新的技能，研究一个完全陌生的领域，学会与背景、教育、观点各不相同的人相处，敢于接受别人的质疑和挑战，等等。&lt;/p&gt;

&lt;p&gt;　　当你经常接触新鲜事物，你的头脑会更加灵光，你的思维会更加活跃。&lt;/p&gt;

&lt;p&gt;4.保持专注&lt;/p&gt;

&lt;p&gt;　　注意力分散，是创造性思考的大敌。&lt;/p&gt;

&lt;p&gt;　　但如今我们生活在一个全天无休的互联网时代。&lt;/p&gt;

&lt;p&gt;　　每天，我们的注意力被各种新奇好玩的东西所吸引，我们的大脑被海量的信息所超载，这对发挥创造性思维很不利。&lt;/p&gt;

&lt;p&gt;　　所以，我们必须对海量的信息进行断舍离，只专注于所擅长和热爱的领域。冥想有助于提升专注力，你也可以尝试下。&lt;/p&gt;

&lt;p&gt;5.对旧元素进行重新组合&lt;/p&gt;

&lt;p&gt;　　大多数时候，创造力在于重新排列、延伸或者组合现有的事物，将其变为崭新的事物。&lt;/p&gt;

&lt;p&gt;　　当你创作一幅画时，你就是通过对现有的颜料、线条、材质进行重新组合，当你的组合与别人的组合方式不同时，你就是在创造新作品。&lt;/p&gt;

&lt;p&gt;　　写文章也一样，当你读了很多的书，把很多人的观点进行整合，然后加上自己的感悟，就形成了你自己独到的见解，你就创造了新作品。&lt;/p&gt;

&lt;p&gt;　　所谓大道至简，从哲学层面上，各个领域的东西都是相通的。&lt;/p&gt;

&lt;p&gt;　　你经历的事情越多，学到的知识越广，你的感悟就会越深，你就越容易做到跨界整合、融会贯通，这就是一种创造力。&lt;/p&gt;

&lt;p&gt;6.及时记录整理灵感、思考和发现&lt;/p&gt;

&lt;p&gt;　　灵感转瞬即逝，必须把它记录下来，因为“书面化的思考更便于利用”。而且，这种凭直觉而来的思想，比坐着主动推理得出的想法会更有创意。把思维活动的结果保存下来，是真正的智力节约。&lt;/p&gt;

&lt;p&gt;　　有时候，灵感只是一些思维的片断。但如果你能一点点积累，有一天，它就会成为一个绝妙的创意，或者一个独到的发现。&lt;/p&gt;

&lt;p&gt;　　许多时候，灵感是在你深入思考某一问题后的一种顿悟。&lt;/p&gt;

&lt;p&gt;　　比如，有些人说，写文章需要有灵感，灵感没有的时候，就不动笔。但很多时候，灵感是在你落笔的时候突然出现的。也就是说，灵感不是想出来的，而是写出来的。&lt;/p&gt;

&lt;p&gt;　　如果你想要开始写作，那就不要等待，赶快动手吧。如果你非要等待灵感出现才开始写，那可能你一个字都不会写。呵呵。&lt;/p&gt;

&lt;p&gt;7.管理好精力能量&lt;/p&gt;

&lt;p&gt;　　研究表明，创造力与能量水平直接相关。你的精力越充沛，创造力就越强，所以你要照顾好自己，注意饮食，睡眠充足，每天坚持锻炼。&lt;/p&gt;

&lt;p&gt;　　当你苦思冥想，都想不出新点子的时候，你应该好好地休息一下，让潜意识帮你工作。&lt;/p&gt;

&lt;p&gt;　　除了管理好体能精力，你还要管理好自己的情绪精力、意志精力，等等，下一篇将详细讲解这个问题。有兴趣的朋友，可持续关注。&lt;/p&gt;

&lt;p&gt;　　以上，是我读了吉姆·兰德尔所著的简单有趣的个人管理丛书之一《创造力——跳出盒子思考》以后的一些思考和总结，与您分享。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="books" /><category term="思维,书籍" /><summary type="html">吉姆·兰德尔(Jim Randel)，现年60岁，毕业于哥伦比亚大学法学院。他是一位企业家——购买和销售商业地产，同时拓展新业务。作为一名致力于投资和企业家精神领域的讲演者，兰德尔已经在全美许多场馆作过演讲.其中包括哈佛大学和纽约大学商学院。兰德尔学习和研究成功这一主题长达30年之久。除了阅读所有他能找到的有关这一主题的资料以外，他还不厌其烦地向成功人士请_教_.了解他们的成功之道(直到他们找理由回绝)。因此，这本书的结论是多年研究、个人试验和向他人学习的结果。兰德尔得出的结论是：成功的秘密就是欲望、努力、钻研、决心和坚持…而这些都需要毅力和自律能力。兰德尔相信，如果你愿意付出代价，一切都是可能的。</summary></entry><entry><title type="html">redis外网访问相关设置</title><link href="http://localhost:4000/tech/2019/03/12/01.html" rel="alternate" type="text/html" title="redis外网访问相关设置" /><published>2019-03-12T00:00:00+08:00</published><updated>2019-03-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/12/01.html">&lt;p&gt;1 . 我的redis服务用的redis配置文件在哪里？&lt;/p&gt;

&lt;p&gt;答：我用的是centos系统，我知道redis是通过yum安装的，那么我需要通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# rpm -qa | grep redis
redis-3.2.12-2.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这样，我就知道了我装的redis版本，进而我能够知道redis用的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# rpm -ql redis-3.2.12-2.el7.x86_64
/etc/logrotate.d/redis
/etc/redis-sentinel.conf
/etc/redis.conf     （*）
/etc/systemd/system/redis-sentinel.service.d
/etc/systemd/system/redis-sentinel.service.d/limit.conf
/etc/systemd/system/redis.service.d
/etc/systemd/system/redis.service.d/limit.conf
/usr/bin/redis-benchmark
/usr/bin/redis-check-aof
/usr/bin/redis-check-rdb
/usr/bin/redis-cli
/usr/bin/redis-sentinel
/usr/bin/redis-server
/usr/lib/systemd/system/redis-sentinel.service
/usr/lib/systemd/system/redis.service
/usr/libexec/redis-shutdown
/usr/share/doc/redis-3.2.12
/usr/share/doc/redis-3.2.12/00-RELEASENOTES
/usr/share/doc/redis-3.2.12/BUGS
/usr/share/doc/redis-3.2.12/CONTRIBUTING
/usr/share/doc/redis-3.2.12/MANIFESTO
/usr/share/doc/redis-3.2.12/README.md
/usr/share/licenses/redis-3.2.12
/usr/share/licenses/redis-3.2.12/COPYING
/usr/share/man/man1/redis-benchmark.1.gz
/usr/share/man/man1/redis-check-aof.1.gz
/usr/share/man/man1/redis-check-rdb.1.gz
/usr/share/man/man1/redis-cli.1.gz
/usr/share/man/man1/redis-sentinel.1.gz
/usr/share/man/man1/redis-server.1.gz
/usr/share/man/man5/redis-sentinel.conf.5.gz
/usr/share/man/man5/redis.conf.5.gz
/var/lib/redis
/var/log/redis
/var/run/redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2 . 如何更改该redis配置，可以打开外网访问？还要更改下密码以保证安全性。&lt;/p&gt;

&lt;p&gt;答：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;注释掉bind 127.0.0.1，从而让redis不光监听本机的请求。&lt;/li&gt;
  &lt;li&gt;protected-mode no，默认是打开的，想要从别的host连接古来，就需要关闭。&lt;/li&gt;
  &lt;li&gt;requirepass 密码，设置密码。&lt;/li&gt;
  &lt;li&gt;重启redis服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3 . 重启redis服务，我如何让redis以守护进程方式启动呢？&lt;/p&gt;

&lt;p&gt;答：centos 7开始，使用systemd代替daemon了，所以管理系统服务的命令全部由systemctl命令代替。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start redis //如果遇到问题就用systemctl status来查看问题原因
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4 . 防火墙还会挡住外网访问6379端口，怎么办？&lt;/p&gt;

&lt;p&gt;答：这个跟iptable的规则有关了，运维工程师们总是跟iptable打交道，我们只需要知道怎么用即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# iptables -nvL   //查看目前服务的端口
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
7704K 1142M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
12905  687K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           
12984  779K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           
   14   896 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:6379
 439K   25M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
5655K  271M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:80
54310 2782K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:8080
6545K  323M REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 764K  624M DOCKER-ISOLATION  all  --  *      *       0.0.0.0/0            0.0.0.0/0           
 400K  597M DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0           
 399K  597M ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
 364K   27M ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           
    0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0           
    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT 4127 packets, 1019K bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain DOCKER (1 references)
 pkts bytes target     prot opt in     out     source               destination         
   42  4713 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.18.0.2           tcp dpt:80
   16  2316 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.18.0.4           tcp dpt:8080

Chain DOCKER-ISOLATION (1 references)
 pkts bytes target     prot opt in     out     source               destination         
 764K  624M RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目前，我已经放开了服务器的6379端口外网访问，所以结果中会有6379条目。正常来说，新配环境的时候，6379是没有的，所以我们需要添加上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　之后，还需要保存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; service iptables save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后我们再通过查看语句就能看到6379了。至此我们配置完成了redis的外网访问及权限安全了。&lt;/p&gt;

&lt;p&gt;　　我准备再写一个实现主从redis配置的文章，改天研究研究。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,centos" /><summary type="html">1 . 我的redis服务用的redis配置文件在哪里？</summary></entry><entry><title type="html">git的rebase可以实现合并commit</title><link href="http://localhost:4000/tech/2019/03/08/01.html" rel="alternate" type="text/html" title="git的rebase可以实现合并commit" /><published>2019-03-08T00:00:00+08:00</published><updated>2019-03-08T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/08/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/08/01.html">&lt;p&gt;　　玩了那么多年的git了，现如今你只会add,commit,push,pull,merge，你都不好意思说你会git。chrrey-pick , filter branch, rebase等操作你还是需要盘一下的。&lt;/p&gt;

&lt;p&gt;　　git rebase是干什么的呢？学者们把他成为变基。说是把很多的commit合并到一个commit中。之前，我想不明白除了把commit合并为一个以外还有什么地方会用到。几天，我确实碰到了一个现实中的问题。这个问题是出自我的博客的，我的docs由于很多次提交了，每次要合到master上都得来一次filter branch。这个操作刚开始会很快，但是随着博客内容的增多，每次去合master的时候都得走一次从头到尾的遍历，实属受不了。（读者可能并不明白我再说什么，你们也不用想明白。）&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy&quot; data-original=&quot;https://s2.ax1x.com/2019/03/09/ASZxpD.gif&quot; src=&quot;/images/default.jpg&quot; alt=&quot;一顿操作&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以从图中看到，我首先创建了一个test文件。我们将第一行写入并置为第一次提交。之后再插入第二行作为第二行提交。现在，我想把第二次提交和第一次提交合并。这样，就不会有人再知道我曾经有过第二次提交了。这个操作就是rebase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们用上面的命令，就可以将最近的两次提交合并到最早的提交。之后会出现一个界面。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy&quot; data-original=&quot;https://s2.ax1x.com/2019/03/09/ASB856.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;rebase的todo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这个界面前两行列出了rebase所包含的commit。剩下的就是此操作的介绍。我们只需要关心pick和squash两个关键字。通过英文我们了解到，图中的意义是将第二次操作合并至第一次操作，这样在log里面只会显示一次log，然而确实是两次更改。退出即可。如果，rebase发现没有版本冲突就会直接完成rebase操作。如果有冲突，我们就像一般解决冲突一样去纠正就好，然后git add即可，不用commit，然后运行 git rebase –continue即可。 有的时候，你并不太操心rebase发生的冲突，我们可以运行git rebase –skip跳过冲突。&lt;/p&gt;

&lt;p&gt;　　最后，我们还要考虑push到远端的操作。因为当前本地的版本和远端的版本不一样且不是继承版本状态。所以，系统会提示你先git pull，然后再git push。 当心，系统是好心，但如果你真像系统要求你一样去做了，那么你rebase的这些操作都会随着git pull更改为远端的版本。所以，我们在这里需要git push -f，也就是强制推送到远端不进行版本的对比。这个操作其实在多人合作的时候会产生很多副作用，让你瞬间就扮演上了小队破坏者的身份。因此，很多开发者都不建议在多人项目中用rebase这个命令，除非你和你的小队已经充分沟通过此事，而且大家也互相明白做此事的重要性，而且大家还不是新兵蛋蛋。&lt;/p&gt;

&lt;p&gt;　　好了，我就记录到这里吧。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="git" /><summary type="html">　　玩了那么多年的git了，现如今你只会add,commit,push,pull,merge，你都不好意思说你会git。chrrey-pick , filter branch, rebase等操作你还是需要盘一下的。</summary></entry></feed>