<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://naffan.cn/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="http://naffan.cn/feed.xml" rel="self" type="application/atom+xml" /><link href="http://naffan.cn/" rel="alternate" type="text/html" /><updated>2017-06-09T18:57:58+08:00</updated><id>http://naffan.cn//</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">正确理解javascript中的Event loop机制</title><link href="http://naffan.cn/tech/2017/06/04/01.html" rel="alternate" type="text/html" title="正确理解javascript中的Event loop机制" /><published>2017-06-04T00:00:00+08:00</published><updated>2017-06-04T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/06/04/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/06/04/01.html">&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/c3041c9a-ee21-412a-83e3-a7d0d3c56214.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这两个星期一直在想着写一篇关于javascript中event Loop的文章。自从写完上一篇&lt;a href=&quot;http://naffan.cn/tech/2016/12/10/1.html&quot;&gt;《Javascript捕捉(capturing)与冒泡(bubbling)的区别》&lt;/a&gt;之后，我抛出了一个问题。当时的我对event loop的概念还很模糊，只是觉得这个问题隐隐约约跟它有关系。我当然不能放下这个问题太久，太久了就会忘记自己原先的初衷了。所以，在看了很多关于event loop的文章和视频以后我打算将这篇文章写出来。在文章的最后，我将列举出我所翻阅的所有资料，而且我很建议大家看一看。&lt;/p&gt;

&lt;p&gt;　　想要了解event loop的概念，首先就要知道几个有关的概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么叫做栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　栈（stack），是计算机内存存储的一种方式。数据进入栈叫做压栈，数据从栈中出来叫做出栈。栈的存储方式只支持先进后出，后进先出的原则。如果你熟悉C语言的话，你就会知道栈中的数据是静态数据，这些数据是由计算机分配的数据，不能被我们程序员进行更改。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么叫做堆&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　堆（heap），也是计算机内存存储的一种方式。数据根据所属的某种key分散存储在内存单元。同样你如果熟悉C语言的话，你就会知道堆中的数据是动态数据，是由操作者们单独创建出来的存储单元。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;什么叫做队列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　队列（queue），他是一种解决问题的方法。我们人为的规定队列中的数据具有先进先出，后进后出的规则。也就是说如果你想出队你就必须等你前面的所有数据全部出队以后你才可以出队。&lt;/p&gt;

&lt;p&gt;　　我相信有了以上的几种知识，你就能够明白我接下来要解释的长篇大论了。我们知道多个事情并发的时候就会出现你忙不过来的情况，如果你忙不过来那么就得让所有后面的事情等待你先解决手头的事情。这样就会出现后面的事务堆积得不到解决，那么我们怎么解决这个问题呢？javascript采用的并发模型是基于“事件循环”的。那什么叫做事件循环呢？下面我就一点一点展开。&lt;/p&gt;

&lt;p&gt;　　首先声明的是，javascript是单线程的。他不可能有多线程的性质，而只是在模仿多线程的样子让我们感觉像多线程一样。&lt;/p&gt;

&lt;script async=&quot;&quot; src=&quot;//jsfiddle.net/naffan/yas8jLho/embed/js,html,css,result/dark/&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/08/5938ee1832fb5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　从上图，我们可以看到这段代码展示的形式就是栈的表示方法。最先运行的代码最先压进栈，我们可以看到onload其实就是代码的main函数，然后依次压栈bazz,bar,foo，而在foo中抛出一个错误停止了程序的运行。&lt;/p&gt;

&lt;p&gt;　　在javascript中我们运行代码的时候，如果执行的时间很长，那么我们在这段时间内是做不了别的事情的。这就是单线程的弊端。我们可以运行个例子进行测试。&lt;/p&gt;

&lt;script async=&quot;&quot; src=&quot;//jsfiddle.net/naffan/qg247n3b/embed/js,html,css,result/dark/&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/06/08/5938ee1830a44.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面的程序，我们进行了递归调用，并且没有做异常处理。那么运行的时候会无限的调用foo函数直到碰触到内存中的栈最大值，这个时候js会抛出系统异常并终止程序。&lt;/p&gt;

&lt;p&gt;　　在这里我有个好奇点，栈到底有多大呢？当然，我不能具体量化到栈可以存储多少个字节，但是我可以通过循环的次数大体判断一下。&lt;/p&gt;

&lt;script async=&quot;&quot; src=&quot;//jsfiddle.net/naffan/m2aherx0/embed/js,html,css,result/dark/&quot;&gt;&lt;/script&gt;

&lt;p&gt;　　这段代码在不同的浏览器中会有不同的结果，大体结果如下：&lt;/p&gt;

&lt;h3 id=&quot;internet-explorer&quot;&gt;Internet Explorer&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IE6: 1130&lt;/li&gt;
  &lt;li&gt;IE7: 2553&lt;/li&gt;
  &lt;li&gt;IE8: 1475&lt;/li&gt;
  &lt;li&gt;IE9: 20678&lt;/li&gt;
  &lt;li&gt;IE10: 20677&lt;/li&gt;
  &lt;li&gt;IE11:54375&lt;/li&gt;
  &lt;li&gt;edge : 16615&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mozilla-firefox&quot;&gt;Mozilla Firefox&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;3.6: 3000&lt;/li&gt;
  &lt;li&gt;4.0: 9015&lt;/li&gt;
  &lt;li&gt;5.0: 9015&lt;/li&gt;
  &lt;li&gt;6.0: 9015&lt;/li&gt;
  &lt;li&gt;7.0: 65533&lt;/li&gt;
  &lt;li&gt;8b3: 63485&lt;/li&gt;
  &lt;li&gt;17: 50762&lt;/li&gt;
  &lt;li&gt;18: 52596&lt;/li&gt;
  &lt;li&gt;19: 52458&lt;/li&gt;
  &lt;li&gt;42: 281810&lt;/li&gt;
  &lt;li&gt;49: 8921&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;google-chrome&quot;&gt;Google Chrome&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;14: 26177&lt;/li&gt;
  &lt;li&gt;15: 26168&lt;/li&gt;
  &lt;li&gt;16: 26166&lt;/li&gt;
  &lt;li&gt;25: 25090&lt;/li&gt;
  &lt;li&gt;28: 26000&lt;/li&gt;
  &lt;li&gt;47: 20878&lt;/li&gt;
  &lt;li&gt;51: 41753&lt;/li&gt;
  &lt;li&gt;56: 20922&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;safari&quot;&gt;Safari&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;4: 52426&lt;/li&gt;
  &lt;li&gt;5: 65534&lt;/li&gt;
  &lt;li&gt;9: 63444&lt;/li&gt;
  &lt;li&gt;10: 73399&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;opera&quot;&gt;Opera&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;10.10: 9999&lt;/li&gt;
  &lt;li&gt;10.62: 32631&lt;/li&gt;
  &lt;li&gt;11: 32631&lt;/li&gt;
  &lt;li&gt;12: 35990&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　不过以上的数据并不能说明什么，因为当你再用同样的版本浏览器再次运行脚本的时候会发现得出的结果和上次并不太一样。何况这也取决你所处的软件环境和内存运行情况。所以说，这些结果也就是玩玩而已并没有什么实际意义。&lt;/p&gt;

&lt;p&gt;　　接下来，让我们看看js在运行程序的时候是如何在栈中存储的吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/6d3ad175-e285-458b-95eb-6a6769ecd635.gif&quot; alt=&quot;2017-06-08 22_47_11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们看到js在启动的时候先将main()函数压入栈底，然后运行到printSquare()时将其压入栈中，紧接着将square和multiply接连压栈。这样就构造出了完整的printSquare()函数运行栈，紧接着程序将按照出栈的顺序开始执行，直到栈空为止。下面让我们接着来看下远程调用数据时的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/5a6be3e5-cd1b-4f7a-b744-02ce0216981e.gif&quot; alt=&quot;2017-06-08 22_57_55&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这个效果和上一个例子的运行效果是一样的，但是我们注意到每个远程调用都是需要一段时间等待的，如果一个连接网络用时超长那么给我们的感觉就如同卡死一样，我们既不能操作别的动作，浏览器也不能处理诸如渲染页面之类的操作。这一问题是非常严重的，原因所在就是js是单线程的，浏览器只能完成一个任务之后再去执行下一个任务。&lt;/p&gt;

&lt;p&gt;　　那么我们需要一个解决办法，这个办法就是你常用的异步回调，更准确的说就是回调函数。我们运行的时候将其运行过程保存起来，在将来的&lt;strong&gt;某个时间点&lt;/strong&gt;再运行。请注意在这里所说的某个时间点的概念，请务必带着“哪个时间点？”的问题往下看。虽然我可以直接告诉你答案~&lt;/p&gt;

&lt;script async=&quot;&quot; src=&quot;//jsfiddle.net/naffan/t2a1gL67/2/embed/js,html,css,result/dark/&quot;&gt;&lt;/script&gt;

&lt;p&gt;　　我期望你能够运行一下并在浏览器中的控制台查看结果。&lt;/p&gt;

&lt;p&gt;　　setTimeout函数将方法体保存在了队列中以让他在将来的5秒后运行。这个时候队列的概念出来了。那么问题又来了，从代码直观上来看，这样的运行结果并不稀奇，因为我让方法体5秒后执行，可不就是先执行下面的代码了么？我们再来看个例子，请你对上面的代码修改5秒为0秒，试下看看结果变没有变。&lt;/p&gt;

&lt;p&gt;　　答案是没有变，虽然设置为了0秒。但他并不就等同于立即执行，而是&lt;strong&gt;某种东西&lt;/strong&gt;将其放到了队列中，当别的步骤都走完了才能开始运行队列中的代码。请注意这里所述的“某种东西”并不是javascript，而是浏览器，更准确的说是浏览器底层的C++。我们可以查看&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout&quot;&gt;window.setTimeout&lt;/a&gt;，setTimeout是底层WEB API提供的接口，他是我们在使用javascript编写web代码时由底层进行的。所以setTimeout并不是javascript的特性，而是浏览器。再进一步说，我们在做异步的时候是浏览器在帮助我们将方法体塞进队列，然后在未来的某个时间再从队列出来并执行的，从而给了我们一种异步的感觉。javascript是单线程的这句话，这里淋漓尽致的体现出来了吧。还有，网上各种文章标题什么的js的setTimeout其实都是bullshit。&lt;/p&gt;

&lt;p&gt;　　接下来，让我们真正带着event loop的概念看一看是如何进行的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/42b86a94-85af-4bf2-a69e-74e5f63ada33.gif&quot; alt=&quot;2017-06-08 23_54_45&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这个程序中直到webapis存储着timer之前的逻辑我不讲了（前面已经说的足够了），之后timer运行5秒以后将cb()函数塞进队列中，event loop会一直干两件事，一是检查栈中是否为空，二是检查队列是否为空。如果队列中不空就将最先执行的cb函数在栈为空的时候压栈并执行。最终得到的效果就如同异步一样，完美的完成了异步操作。&lt;/p&gt;

&lt;p&gt;　　接下来让我们看看Ajax的情况吧，其实和之前的例子没有什么两样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/f8d1801c-eba5-4aff-8d01-416b463fc704.gif&quot; alt=&quot;2017-06-09 00_07_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　如果很多的异步回调（几乎）同时触发，那么是什么情况呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/06146fe0-5b01-46d0-9f11-ee9eec70de96.gif&quot; alt=&quot;2017-06-09 00_11_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　就像刚才我所提到event loop所干的两件事，它一直在监察着栈和队列。当第一个timeout进入队列要出队列的时候，event loop发现栈中还在运行代码，所以就先不让其出队列而是等到栈中为空时才出队列，之后进来的timeout函数都要被event loop告知栈为空时才可以一个一个进行出队列并执行。&lt;/p&gt;

&lt;p&gt;　　如果你想了解更多的话，我强烈建议你点击下边第三个引用连接，这个连接里面的内容是一个js运行时的模拟器，你可以自己写程序，他可以直观的帮助你了解你写的程序在系统中是如何执行的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=8aGhZQkoFbQ&lt;/li&gt;
  &lt;li&gt;https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D&quot;&gt;相当推荐的工具，由于连接较长影响了美观，所以做成了超链接&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop&lt;/li&gt;
  &lt;li&gt;https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage&lt;/li&gt;
  &lt;li&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="javascript" /><summary type="html"></summary></entry><entry><title type="html">MYSQL中浮点类型的区别</title><link href="http://naffan.cn/tech/2017/05/23/01.html" rel="alternate" type="text/html" title="MYSQL中浮点类型的区别" /><published>2017-05-23T00:00:00+08:00</published><updated>2017-05-23T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/05/23/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/05/23/01.html">&lt;p&gt;&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;mysql&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　除了&lt;a href=&quot;http://naffan.cn/tech/2017/05/21/01.html&quot;&gt;《MYSQL中tinyint(1)的正确理解》&lt;/a&gt;所述的整形以外，mysql还有两种小数类型，一种是定点数类型（decimal,numeric），一种是浮点数类型(float,double)。&lt;/p&gt;

&lt;p&gt;　　我们先来说说定点数，他存的值一定是准确的。所以说这个类型通常是用来做需要保存准确度的数值类型的，比如金额类型的数据。numeric其实是被decimal实现的，所以说在意义上来将，numeric和decimal是同一个道理。&lt;/p&gt;

&lt;p&gt;　　decimal(M,N)，其中M代表位数的总和，N代表小数点的位数，不足则补零，超出的则用四舍五入的方式进位到小数点N位，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;decimal(5,3)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　该字段可以存储decimal类型的字段，字符总数为5位，小数点3位。也就是说这个字段可以存储任何5个数字以及3个小数，所以存储范围是-99.999~99.999。通过测试，我们可以总结一下几个规律：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;输入&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0.000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;111.111&lt;/td&gt;
      &lt;td&gt;out of range value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11111&lt;/td&gt;
      &lt;td&gt;out of range value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.1112&lt;/td&gt;
      &lt;td&gt;1.111&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1.1115&lt;/td&gt;
      &lt;td&gt;1.112&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9.9998&lt;/td&gt;
      &lt;td&gt;10.000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;99.9998&lt;/td&gt;
      &lt;td&gt;out of range value&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　让我们来关注下如果没有设置小数点位数的时候，decimal会是什么样子。比如，我设置decimal(5)，它其实就跟decimal(5,0)是等价的。也就是说这种情况下是没有小数的，如果你非要添加小数的话，他最终还是会按照四舍五入的方法进位至个位的最后存入数据库。&lt;/p&gt;

&lt;p&gt;　　如果你在设置decimal的时候不给他设置M值，那么mysql会默认给他赋成decimal(10)的。&lt;/p&gt;

&lt;p&gt;　　那么decimal最大的长度能够设置成多长呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The maximum number of digits for DECIMAL is 65, but the actual range for a given DECIMAL column can be constrained by the precision or scale for a given column. When such a column is assigned a value with more digits following the decimal point than are permitted by the specified scale, the value is converted to that scale. (The precise behavior is operating system-specific, but generally the effect is truncation to the permissible number of digits.)&lt;br /&gt;
　　DECIMAL 最大的数字长度是65位，但是实际的范围受制于给定的decimal列存储的precision(指M)和scale(指N)。当给此列被赋上一个由整数和不符合规范长度的小数组成的数时，这个值会被转化成符合规范的scale。(precise是操作系统指定的，但普遍来说效果是将截断至允许范围。)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　如果你设置decimal的长度大于65的时候，mysql会报“Too-big precision 66 specified for ‘f’ maximun is 65.”的错误。如果你去设置值时，跟上边举得例子是一摸一样的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;输入&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;11111111111111111111111111111111111111111111111111111111111111111（65个1）&lt;/td&gt;
      &lt;td&gt;out of range value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;111111111111111111111111111111111111111111111111111111111111.1111（64个1）&lt;/td&gt;
      &lt;td&gt;111111111111111111111111111111111111111111111111111111111111.11110&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11111111111111111111111111111111111111111111111111111111111111.1111（66个1）&lt;/td&gt;
      &lt;td&gt;out of range value&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　接下来让我们再看看浮点数类型，他们存储的都是一个近似值。mysql用4字节存储单精度值(float)，用8字节存储双精度值(double)。由于单精度和双精度牵涉的只是有些多，在这里我先埋个坑，等自己真正明白了再给补上吧。&lt;/p&gt;

&lt;p&gt;　　mysql允许一种非标准的语法来定义float(M,D) 或者 real(M,D)或者double precision(M,D)。在这里，M代表所存储的字符长度以及D位的小数部分。举个例子，一列定义成float(7,4)，那么可以存储形如-999.9999，mysql会在超出这个范围存储时对这个值进行四舍五入的操作，所以你在插入999.00009的时候，系统会给算个近似值等于999.0001。&lt;/p&gt;

&lt;p&gt;　　由于浮点数类型的值是近似数而不是一个确切的数值，所以想用他们来存储确切值时会出现意想不到的错误。所以，我们还是尽量避免使用这种类型的值吧。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html"></summary></entry><entry><title type="html">MYSQL中tinyint(1)的正确理解</title><link href="http://naffan.cn/tech/2017/05/21/01.html" rel="alternate" type="text/html" title="MYSQL中tinyint(1)的正确理解" /><published>2017-05-21T00:00:00+08:00</published><updated>2017-05-21T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/05/21/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/05/21/01.html">&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1495385716534&amp;amp;di=ed94757005ca2587cec41c926a1ee8eb&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fa1.jikexueyuan.com%2Fhome%2F201506%2F15%2F3604%2F557e2e270a34e.jpg&quot; alt=&quot;mysql头图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　今天，想起了一个关于mysql中类型长度的问题。一切的起源就是两年前和同事聊天时讨论状态位的字段用什么字段类型来存储，我还依稀记得刚进新浪工作的时候开发项目时总是将数字类型设置为int并且在长度栏填写10。程序在应用的时候没有任何问题而且也从没有关注过mysql存储类型相关细节。&lt;/p&gt;

&lt;p&gt;　　可是，有的时候在和同事聊天的过程中会突然谈论起mysql的存储类型相关问题，而我也没觉得有什么可以拿出来侃侃而谈的知识。后来，有一天新浪基础架构部门发了一封关于调整所有部门数据库用户id字段类型的邮件，邮件中要求所有用到uid的地方需要改成bigint类型。&lt;/p&gt;

&lt;p&gt;　　当时我正在负责新浪游戏的微坛项目，项目中的uid当然就是用int(10)来设定的。为了响应公司的要求，我就简简单单的将uid摄为了bigint(11)。在做出这一改变的过程中，我也询问了部门技术主管关于为什么要更改这个字段类型的原因，主管跟我们说因为起初新浪微博的用户id设置的就是int(10)，后来随着微博的业务发展壮大，用户量也急剧增长，原先10位的用户id已经不能够存储大于10位数了，所以让我们进行修改。比如以前用户id为10个9，后来有一个人注册了新浪微博账号，账号本应该加一位，可是因为只能够存十位所以数据库将这新进的人id覆盖了原先的id，这样就导致了问题的发生。&lt;/p&gt;

&lt;p&gt;　　当时的我一听觉得很有道理啊，10个9加1则进一位就成了1和10个0 。那么我改成bigint以后将长度写为11就能够满足正常的逻辑了，而且变成了11位，不论后面进再多少个人我也完全不怵啊。于是，这个问题就这样“完美”的解决了，而之后的运行也没有发生相关的问题。直到后来的某一天在翻看mysql数据类型所占字节长度的文章时，才发现当年的我真是兔羊兔森破。直到再后来又和同事聊状态位字段应该用什么字段类型及长度存储的时候，我说用tinyint(1)来存储，有符号tinyint可以存储数值最大是127，然而后边的长度1就是限定只能存储1位，也就是0-9 。而且，当年说这番话的时候我是很坚定的回答的。我都能想到当时我的样子是多么的胸有成竹啊，然而事实并不是这个样子的。。。我对问题的理解真是有够知其一不知其二的，如果那个同事能够反问我，如果1就只能存0-9，那么int(1)不和tinyint(1)一样了吗？我想我就不会认为自己很有道理了。&lt;/p&gt;

&lt;p&gt;　　好了，闲话就扯到这里。今天，我闲来有功夫就想将真正对的理解落于书面，这样的好处自然是如果接下来有理解错误的地方，我可以在未来的某个时间再接着此篇文章来进行知识的更新。那么，接下来我就以tinyint(1)这个概念进行阐述。&lt;/p&gt;

&lt;p&gt;　　在mysql中不同的字段类型有着不同的长度。tinyint就被设置为1字节。在计算机中规定8位为1字节。1字节为最小单位，字节的值就代表着高电平或者低电平，用数值来表示就是1和0 。那么，8位的话存储的大小就是00000000 - 11111111(无符号二进制)，转化为十进制的话就是0-255 。所以，1字节在没有符号的时候能够存储的值可以用十进制的0-255来表示。也就是说tinyint类型可以存储256个十进制的数字。而如果有符号的话8位存储的二进制值就是10000000-01111111(-128~127)，在计算机中涉及到负数的时候都是用补码的形式存储的，具体为什么可以参看&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/twos_complement.html&quot;&gt;《关于2的补码》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　话题扯远了，赶紧拽回来。。。&lt;/p&gt;

&lt;p&gt;　　我们知道了tinyint中在有无符号时分别可以存储什么范围的十进制数以后，那么后边的括号中的1又代表的是什么呢？其实我们可以理解为&lt;strong&gt;用多长的长度来读出这个数字&lt;/strong&gt;。通过字面的意思我们可以理解为tinyint(1)就是用1位字符的长度读出tinyint值。我觉得tinyint(1)并不是很好的列子，我打算先用tinyint(2)作为例子来进行演示，之后再回头来说1的情况。那我们有两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当我的值的长度超过2字符长度，结果会如何？&lt;/li&gt;
  &lt;li&gt;当我的值的长度不超过2字节的长度，结果会如何？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　首先，让我们先创建一张表出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `a` (
  `id` int(11) NOT NULL,
  `c` tinyint(2) DEFAULT NULL,
  PRIMARY KEY (`id`),
) ENGINE=MyISAM DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　我往表中插入几个数据，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO `a` VALUES ('1','3');
INSERT INTO `a` VALUES ('2,'33');
INSERT INTO `a` VALUES ('3','0');
INSERT INTO `a` VALUES ('4','111');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们分别执行select操作，看看会有什么结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; select c from a where id =1;
+------+
| c    |
+------+
|    3 |
+------+
1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =2;
+------+
| c    |
+------+
|   33 |
+------+
1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =3;
+------+
| c    |
+------+
|    0 |
+------+

1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =4;
+------+
| c    |
+------+
|  111 |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　结果显示即使我设置了tinyint(2)以后查询出来的结果还是可以显示出所有位数的数据，这个(2)根本没起任何作用啊。即使我的数据的长度超过了2或者没有超过2结果都是可以正常被显示出来的。&lt;/p&gt;

&lt;p&gt;　　那么，我再重新创建一次这张表，不同的是我给c增加了0填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `a` (
  `id` int(11) NOT NULL,
  `c` tinyint(2) unsigned zerofill DEFAULT NULL,
  PRIMARY KEY (`id`),
) ENGINE=MyISAM DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我同样插入一样的数据，然后再对他们执行查询操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; select c from a where id =1;
+------+
| c    |
+------+
|   03 |
+------+
1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =2;
+------+
| c    |
+------+
|   33 |
+------+
1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =3;
+------+
| c    |
+------+
|   00 |
+------+
1 row in set (0.00 sec)

mysql&amp;gt; select c from a where id =4;
+------+
| c    |
+------+
|  111 |
+------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以看到区别了吧，如果我设置了0填充的话。那么，数据会按照不足2位的前补0，多于2位的完全展示出来。这也就是我前面提到的“用多长的长度来读出这个数字”。&lt;/p&gt;

&lt;p&gt;　　好了，到这里我们发现，不论长度取什么值，光设置他是没有任何作用的，我们还需要指定当前数据长度小于这个值时用什么来填充它。于是，tinyint(4),tinyint(16)这样的设置我们就知道在读出的时候他们会长什么样子来了吧？&lt;/p&gt;

&lt;p&gt;　　这里有个mysql自己的设置细节，如果我要将c这个字段设置为0填充，那么也还需将此字段同时设置为unsigned。如果你没有作此操作，mysql会自动为你加上。mysql的官方文档&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/numeric-type-overview.html&quot;&gt;《Numeric Type Overview》&lt;/a&gt;有提到。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column.&lt;br /&gt;
如果你指定了ZEROFILL，MYSQL会自动的将UNSIGNED属性一并添加上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　我想这样设置有可能是跟补码有关的。我们知道正数存放的时候前面都是0，而负数的话高位那里必须是1，所以用零填充的话一定会出问题。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html"></summary></entry><entry><title type="html">MYSQL性能优化</title><link href="http://naffan.cn/tech/2017/05/10/01.html" rel="alternate" type="text/html" title="MYSQL性能优化" /><published>2017-05-10T00:00:00+08:00</published><updated>2017-05-10T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/05/10/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/05/10/01.html">&lt;h2 id=&quot;section&quot;&gt;优化简介&lt;/h2&gt;

&lt;p&gt;　　我们可以通过show status语句查询mysql数据库的性能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;show status like 'value';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　其中，value参数是常用的几个统计参数，这些参数介绍如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;connections:连接mysql服务器的次数；&lt;/li&gt;
  &lt;li&gt;uptime:mysql服务器的上线时间；&lt;/li&gt;
  &lt;li&gt;slow_queries:慢查询的次数；&lt;/li&gt;
  &lt;li&gt;Com_select:查询操作的次数；&lt;/li&gt;
  &lt;li&gt;Com_insert:插入操作的次数；&lt;/li&gt;
  &lt;li&gt;Com_update:更新操作的次数；&lt;/li&gt;
  &lt;li&gt;Com_delete:删除操作的次数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　mysql中存在查询InnoDB类型的表的一些参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Innodb_rows_read:select语句查询的记录数；&lt;/li&gt;
  &lt;li&gt;Innodb_rows_inserted:insert插入的记录数；&lt;/li&gt;
  &lt;li&gt;Innodb_rows_update:update更新的记录数；&lt;/li&gt;
  &lt;li&gt;Innodb_rows_deleted:delete删除的记录数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　通过这些参数可以分析mysql的性能，根据分析结果，进行相应的性能优化。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;优化查询&lt;/h2&gt;

&lt;p&gt;　　通过对查询语句的分析，可以了解查询语句的执行情况，我们可以通过EXPLAIN和DESCRIBE来分析查询语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;explain select 语句
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　结果中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;id:表示select语句的编号；&lt;/li&gt;
  &lt;li&gt;select_type:表示select语句的类型，这个参数有几个常用的取值，simple表示简单查询，其中不包括连接查询和子查询；primary表示主查询，或者是最外层的语句；union表示连接查询的第二个或后面的查询语句；&lt;/li&gt;
  &lt;li&gt;table:表示查询的表；&lt;/li&gt;
  &lt;li&gt;type:表示标的连接类型。这个参数有几个常用的取值，system表示表中只有一条记录；const表示表中有多条记录，但只从表中查询一条记录；all表示对表进行了完整的扫描；eq_ref表示多表连接时，后面的表使用了unique或者primary key；ref表示多表查询时，后面的表使用了普通索引；unique_subquery表示子查询中使用了unique或者primary key；index_subquery表示子查询中使用了普通索引；range表示查询语句中给出了查询范围；index表示对表中的索引进行了完整的扫描；&lt;/li&gt;
  &lt;li&gt;possible_keys:表示查询中可能使用的索引；&lt;/li&gt;
  &lt;li&gt;key:表示查询使用到的索引；&lt;/li&gt;
  &lt;li&gt;key_len:表示索引字段的长度；&lt;/li&gt;
  &lt;li&gt;ref:表示使用哪个列或常数于索引一起来查询记录；&lt;/li&gt;
  &lt;li&gt;rows:表示查询的元组个数；&lt;/li&gt;
  &lt;li&gt;filtered:表示按照条件过滤的元组个数	的百分比；&lt;/li&gt;
  &lt;li&gt;extra:表示查询过程的附件信息。这个参数有几个常用的取值，using where表示查询使用了where语句来处理的；using temporary表示使用了内部临时（基于内存）表；using filesort表示这是order by语句的结果；using index表示使用到了索引，没有直接访问整个表数据；using join buffer表示在连接查询时没有使用索引，并且需要连接缓冲区来存储中间的结果；impossible where表示where条件时没有找到符合的数据；select tables optimized away表示仅通过使用索引从聚合函数中返回一行数据；distinct表示找到一行数据后就停止了搜索；index merges表示使用了超过一个的索引时候，并以以下格式中的一个展现出来：
    &lt;ul&gt;
      &lt;li&gt;using sort_union(…)&lt;/li&gt;
      &lt;li&gt;using union(…)&lt;/li&gt;
      &lt;li&gt;using intersect(…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;以上三个的区别我会在以后的测试中展现出来。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　DESCRIBE语句（DESC）的使用方法与EXPLAIN语句是一样的。这两者的分析结果也是一样的。DESCRIBE语句的形式如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;describe select 语句；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在使用索引进行查询的过程中，有些时候即使查询时使用的是索引，但是索引并没有起作用。所以我们需要注意到几点情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用like的时候，如果匹配字符串的第一个字符为%,索引是不会被使用的，如果不在第一个位置，索引就会被使用&lt;/li&gt;
  &lt;li&gt;在使用多列索引时，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用&lt;/li&gt;
  &lt;li&gt;如果查询语句只有OR关键字时，如果OR前后的两个条件都是索引时，查询中将使用索引。如果前后有一个条件的列不是索引，那么查询中将不使用索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;优化插入记录的速度&lt;/h2&gt;

&lt;p&gt;1.禁用索引&lt;/p&gt;

&lt;p&gt;　　插入记录时，mysql会根据表的索引对插入的记录进行排序。如果插入大量数据时，这些排序会降低插入记录的速度。为了解决这个情况，再插入记录之前应该先禁用索引。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;alter table 表名 disable keys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　当数据都被插入以后，应该重新开启索引&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;alter table 表名 enbale keys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这块知识的应用，我已经在前边的文章有了对这块知识的应用：&lt;a href=&quot;http://naffan.cn/tech/2017/05/09/01.html&quot;&gt;《如何向MYSQL插入大量数据，千万级数据以及亿级数据的方法和性能》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.禁用唯一性检查&lt;/p&gt;

&lt;p&gt;　　插入数据时，mysql会对插入的记录进行唯一性校验。这种校验也会降低插入记录的速度。可以在插入记录之前禁用唯一性检验。等到记录插入完毕后再开启。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;set unique_checks=0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　重新开启唯一性检查&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;set unique_checks=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.优化insert语句&lt;/p&gt;

&lt;p&gt;　　一般在批量插入数据的时候，会优先想到用多个insert语句去插入数据。但是，其实如果将所有的数据汇聚成一条insert语句，将会减少与数据库的连接等操作。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;分析表、检查表和优化表&lt;/h2&gt;
&lt;p&gt;　　分析表主要作用是分析关键字的分布。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;analyze table 表名1[,表名2...];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　检查表主要作用是检查表是否存在错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;check table 表名1[,表名2...][option];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　option参数有5个参数：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;quick&lt;/li&gt;
  &lt;li&gt;fast&lt;/li&gt;
  &lt;li&gt;changed&lt;/li&gt;
  &lt;li&gt;medium&lt;/li&gt;
  &lt;li&gt;extended&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　这5个参数的执行效率依次降低。option选项只对MyISAM类型的表有效，对Innodb类型的表无效。同时还要注意这个执行过程会给表叫上只读锁。&lt;/p&gt;

&lt;p&gt;　　优化表主要作用是消除删除或更新造成的空间浪费。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;optimize table 表名1[,表名2...]；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　如果一个表使用了TEXT或者BLOB这样的数据类型，那么更新、删除等操作就会造成磁盘空间的浪费。&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;优化mysql的参数&lt;/h2&gt;

&lt;p&gt;　　mysql中比较重要的配置参数都在my.cnf或者my.ini文件的[mysqld]组中。下面对几个重要的参数进行详细介绍：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key_buffer_size:表示索引缓存的大小。这个值越大，使用索引进行查询的速度越快。&lt;/li&gt;
  &lt;li&gt;table_cache:表示同时打开的表的个数。这个值越大，能够同时同时打开的表的个数越多。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。&lt;/li&gt;
  &lt;li&gt;query_cache_size:表示查询缓存区的大小。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况；其默认值为0.当取值为2时，只有select语句中使用了sql_cache关键字，查询缓存区才会使用。例如，select sql_cache * from score&lt;/li&gt;
  &lt;li&gt;query_cache_type:表示查询缓存区的开启状态。其取值为0时表示关闭，取值为1时表示开器，取值为2时表示按要求使用查询缓存区。&lt;/li&gt;
  &lt;li&gt;max_connections:表示数据库的最大连接数。这个连接数不是越大越好，因为这些连接会浪费内存的资源。&lt;/li&gt;
  &lt;li&gt;sort_buffer_size:表示排序缓存区的大小。这个值越大，进行排序的速度越快。&lt;/li&gt;
  &lt;li&gt;read_buffer_size:表示为每个线程保留的缓冲区的大小。当线程需要从表中连续读取记录时需要用到这个缓冲区。set session read_buffer_size=n可以临时设置该参数的值。&lt;/li&gt;
  &lt;li&gt;read_rnd_buffer_size:表示为每个线程保留的缓冲区的大小，与read_buffer_size相似。但主要用于存储按特定顺序读取出来的记录。也可以用set session read_rnd_buffer_size=n来临时设置该参数的值。&lt;/li&gt;
  &lt;li&gt;innodb_buffer_pool_size:表示innodb类型的表和索引的最大缓存。这个值越大，查询的速度就会越快。但这个值太大了会影响操作系统的性能。&lt;/li&gt;
  &lt;li&gt;innodb_flush_log_at_trx_commit:表示何时缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数有3个值，分别是0、1和2.值为0时表示每隔1秒将数据写入日志文件并将日志文件写入磁盘；值为1时表示每次提交事务时将数据写入日志文件并将日志文件写入磁盘；值为2时表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。该参数的默认值为1.这个默认值是最全最合理的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　合理的配置这些参数可以提高mysql服务器的性能。除以上参数外，还有innodb_log_buffer_size、innodb_log_file_size等参数。如果想要了解更多的参数的话，应该去手册中进行查看。&lt;/p&gt;

&lt;p&gt;本文参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5450806/&quot;&gt;《mysql入门很简单》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html">优化简介</summary></entry><entry><title type="html">如何向MYSQL插入大量数据的方法和性能对比</title><link href="http://naffan.cn/tech/2017/05/09/01.html" rel="alternate" type="text/html" title="如何向MYSQL插入大量数据的方法和性能对比" /><published>2017-05-09T00:00:00+08:00</published><updated>2017-05-09T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/05/09/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/05/09/01.html">&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1494359970180&amp;amp;di=b0128a39c2341bf21bdb2a64ce7afe0b&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fa1.jikexueyuan.com%2Fhome%2F201506%2F26%2Fae91%2F558cca408efa6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在操作mysql的时候，为了理解mysql的特性我们往往需要构造出一张承载很大数据量的数据表。那么如何创建出大数据量的表呢？&lt;/p&gt;

&lt;p&gt;　　首先，我们要在自己的脑中先设想出能够满足这个需求的几个实现方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过你所掌握的语言编写脚本实现&lt;/li&gt;
  &lt;li&gt;在数据库中直接通过脚本实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　第一种方案实现起来比较简单，对我来说php是我的主语言，我用php去实现这个需求的业务逻辑很简单。但是，在实际的操作中就会发现光光写好一段能够满足此需求的逻辑还远远不够，我们还需要考虑运行程序机器的内存限制以及超时时间等。与直接通过数据库脚本实现来说，性能和时间都不是很有优势。&lt;/p&gt;

&lt;p&gt;　　第二种方案实现起来稍微复杂且需要一点点学习成本，首先是需要掌握最基本的数据库操作知识，其次还要通过编写mysql存储过程的标准格式。但是，运行起来的速度以及方便程度还有性能都远远比第一种方案来的效率。&lt;/p&gt;

&lt;p&gt;　　首先，我们需要将数据表结构建立起来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE millionData (
   id INT NOT NULL,
   email VARCHAR(64) NOT NULL,
   name VARCHAR(32) NOT NULL,
   password VARCHAR(32) NOT NULL,
   phone VARCHAR(13),
   birth DATE,
   sex INT(1),
   avatar BLOB,
   address VARCHAR(64),
   regtime DATETIME,
   lastip VARCHAR(15),
   modifytime TIMESTAMP NOT NULL,
  PRIMARY KEY (id)
)ENGINE = MyISAM ROW_FORMAT = DEFAULT
partition BY RANGE (id) (     
    partition p0 VALUES LESS THAN (100000),     
    partition p1 VALUES LESS THAN (500000),     
    partition p2 VALUES LESS THAN (1000000),     
    partition p3 VALUES LESS THAN (1500000),
    partition p4 VALUES LESS THAN (2000000),
    Partition p5 VALUES LESS THAN MAXVALUE     
); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们规定首先选择引擎为MyISAM，因为MyISAM的插入速度要比INNODB的插入速度快出10%。如果需要INNODB引擎的表，就在数据插入完成以后再对表进行此操作即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;alter table millionData engine=innodb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　虽说，这条语句在更改的时候也需要时间。但是，相对于直接用innodb引擎的表进行插入来说还是要快很多的。接下来，我们就要对此表进行数据的插入了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;CREATE DEFINER=`root`@`localhost` PROCEDURE `BatchInsertMillionData`(IN `start` int, IN loop_time int)
    DETERMINISTIC
BEGIN
 DECLARE Var INT;
 DECLARE ID INT;
 SET Var = 0;
 SET ID= start;
      WHILE Var &amp;lt; loop_time 
        DO
      insert into millionData(ID,email,name,password,phone,birth,sex,avatar,address,regtime,lastip,modifytime) 
  values(ID,CONCAT(ID,'@sina.com'),CONCAT('name_',rand(ID)*10000 mod 200),123456,13800000000,adddate('1995-01-01',(rand(ID)*36520) mod 3652),Var%2,'http:///it/u=2267714161,58787848&amp;amp;fm=52&amp;amp;gp=0.jpg','北京市海淀区',adddate('1995-01-01',(rand(ID)*36520) mod 3652),'8.8.8.8',adddate('1995-01-01',(rand(ID)*36520) mod 3652));
      SET Var = Var + 1;
      SET ID= ID + 1;
      END WHILE;
END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　通过阅读上面的代码，我们可以发现。BatchInsertMillionData有两个输入参数，一个是起始id，一个是要插入的数据量。代码是通过这两个输入的值做while循环，一条一条insert数据插入到数据库当中的。让我们来看看实际应用的耗时吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt;call BatchInsertMillionData(1,1000000);
Query OK, 1 row affected (1 min 21.30 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　让我们多做一步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; truncate table millionData;
Query OK, 0 rows affected (0.02 sec)

mysql&amp;gt; alter table millionData disable keys;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; call BatchInsertMillionData(1,1000000);
Query OK, 1 row affected (1 min 23.05 sec)

mysql&amp;gt; alter table millionData enable keys;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　从上面的两个运行方法来看，第二种在运行存储过程之前对myisam表进行了关闭索引的操作。然而完成的时间并没有提高反而慢了1秒多。为什么我会增加这个步骤呢？这是因为有人说这步骤可以实现打开/关闭myisam表非唯一索引的更新。然而，我并没有对此表任何字段添加任何索引。所以，以最后的完成时间来看。关闭key的操作并没有对我的插入起到什么效果。那好，我们就对这张表增加几个非唯一索引来试试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; truncate table millionData;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; alter table millionData add key name(name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; alter table millionData add key phone(phone);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; alter table millionData add key phoneAndName(phone,name);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; show create table millionData;
(中间的制表符省略)
| Table       | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
(中间的制表符省略)
| millionData | CREATE TABLE `millionData` (
  `id` int(11) NOT NULL,
  `email` varchar(64) COLLATE utf8_bin NOT NULL,
  `name` varchar(32) COLLATE utf8_bin NOT NULL,
  `password` varchar(32) COLLATE utf8_bin NOT NULL,
  `phone` varchar(13) COLLATE utf8_bin DEFAULT NULL,
  `birth` date DEFAULT NULL,
  `sex` int(1) DEFAULT NULL,
  `avatar` blob,
  `address` varchar(64) COLLATE utf8_bin DEFAULT NULL,
  `regtime` datetime DEFAULT NULL,
  `lastip` varchar(15) COLLATE utf8_bin DEFAULT NULL,
  `modifytime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `name` (`name`),
  KEY `phone` (`phone`),
  KEY `phoneAndName` (`phone`,`name`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin
/*!50100 PARTITION BY RANGE (id)
(PARTITION p0 VALUES LESS THAN (100000) ENGINE = MyISAM,
 PARTITION p1 VALUES LESS THAN (500000) ENGINE = MyISAM,
 PARTITION p2 VALUES LESS THAN (1000000) ENGINE = MyISAM,
 PARTITION p3 VALUES LESS THAN (1500000) ENGINE = MyISAM,
 PARTITION p4 VALUES LESS THAN (2000000) ENGINE = MyISAM,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = MyISAM) */ |
(中间的制表符省略)
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;　　接下来我们运行两种方法的插入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; call BatchInsertMillionData(1,1000000);
Query OK, 1 row affected (2 min 1.12 sec)

mysql&amp;gt; truncate table millionData;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; alter table millionData disable keys;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; call BatchInsertMillionData(1,1000000);
Query OK, 1 row affected (1 min 27.24 sec)

alter table millionData enable keys;
Query OK, 0 rows affected (7.87 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以看到，我们对此表增加了3个索引（一张表建议最好不要添加多于6个索引）。两个普通索引和一个关联索引。没有关闭非唯一索引的插入时间要比关闭非唯一索引的插入时间慢了半分钟，虽然最后开开了索引也只是在用时8秒。所以说，如果你的表建立的时候就建立了索引，在导入大批量数据之前，一定要先尝试着关闭这些索引，这一个步骤会让你省去很多的等待时间。&lt;/p&gt;

&lt;p&gt;　　上面我们插入的是一百万数据而已，那么接下来我们尝试插入一亿条数据试试。我们建立一张表，同样用的也是之前的建表语句，只是表的名称改成了billionData。讲个题外话，你是不是经常搞不清million和billion谁大以及各代表的数字呢？我告诉你们一个好方法，你只要记住b比m大，而b是3个3个0，m是2个3个0。因为，外国人记录数字都习惯用3个0位一个段。所以，million代表1，000，000，billion代表1，000，000，000。&lt;/p&gt;

&lt;p&gt;　　如果我们还是用上面的那个存储过程的话，很悲催，最后会出现query超时或者丢失的提示，而进程还没等数据插入完成就早早停止住了。这是因为mysql在做数据插入的时候是有一个循环体在不断的向mysql中注入信息的，如果要插入的数据时时刻刻都在往这个循环内插入数据，然而写入磁盘的数据量是有上限的，这样一来数据远远超过了消费数据的能力，mysql就会报出这样的错误来。那么问题来了，我们需要怎么修改存储过程才能满足这个需求呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;CREATE DEFINER=`root`@`localhost` PROCEDURE `BatchInsertBillionData2`(IN start int(11), IN loop_time int(11))
BEGIN
	DECLARE times INT;
	DECLARE ID INT;
	DECLARE j INT;
	DECLARE count INT;
	SET ID = start;
	SET times = loop_time/1000;
	SET count = 0;
	SET @exedata = &quot;&quot;;
	WHILE count &amp;lt; times DO
		SET j = 0;
		WHILE j &amp;lt; 1000 DO
			SET @exedata = concat(@exedata,&quot;,('&quot;,ID,&quot;','&quot;,CONCAT(ID,'@sina.com'),&quot;','&quot;,CONCAT('name_',rand(ID)*10000 mod 200),&quot;','123456','13800000000','&quot;,adddate('1995-01-01',(rand(ID)*36520) mod 3652),&quot;','&quot;,ID%2,&quot;','http://it/u=2267714161,58787848&amp;amp;fm=52&amp;amp;gp=0.jpg','北京市海淀区','&quot;,adddate('1995-01-01',(rand(ID)*36520) mod 3652),&quot;','8.8.8.8','&quot;,adddate('1995-01-01',(rand(ID)*36520) mod 3652),&quot;')&quot;);
			SET j = j+1;
			SET ID = ID + 1;
		end while;
		SET @exedata = SUBSTRING(@exedata,2);
		SET @exesql = concat(&quot;insert into billionData(ID,email,name,password,phone,birth,sex,avatar,address,regtime,lastip,modifytime) values &quot;,@exedata);	
		prepare stmt from @exesql;
		execute stmt;
		DEALLOCATE prepare stmt;
		SET @exedata = &quot;&quot;;
		SET count = count +1 ;
	end while;
END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　以上就是对存储过程的修改，大概意思就是判断要插入的数据量除以1000，所得到的数字就是最外层循环的循环次数，内层循环再做1000此循环，循环体就是在每次循环中将sql组成类似insert into billionData(…) values (…),…,(…)的形式然后再通过prepare和execute进行分批量的插入。这样一是将1000次的请求汇成一个请求然后异步的去插入数据库，然后马上再进行下一个1000次的组装和插入。这样就不会发生丢失query连接的报错了。&lt;/p&gt;

&lt;p&gt;　　想说一下用这个方法插入了一亿条数据的耗时吧。这段代码大约耗时2个多小时，总数据量在17G左右，每秒20000条插入到数据表中。在没有任何索引的情况下，将此表引擎改成innodb花了12分钟左右：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; alter table  billionData engine=innodb;
Query OK, 0 rows affected (11 min 51.20 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/05/10/5911f7eb697d8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;以下写于2017-05-10&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　首先，让我插个题外话。今天凌晨，2017年欧冠半决赛尤文图斯战胜了摩纳哥。时隔两年尤文图斯又站上了欧冠的巅峰，接下来就要看明日凌晨皇马和马竞谁能赢了，不过皇马已经在前半回合3比0领先马竞了，不出意外皇马不会被马竞翻盘的，毕竟现在C罗如日中天屌的一逼。回想2015年10月我也是曾经在卡尔德隆球场看过皇马对马竞比赛的男人。&lt;/p&gt;

&lt;p&gt;　　好了，扯回来吧。之前的方式还不是最高效的。后来，了解到还有一种大法就是Load data。这个方法简直高效的要命，时间占用比例是之前的约5%，提升了95%的速度呢。为了进行测试我将昨日插入的一百万数据导出成txt，让我们先看一下mysql导出这个文件花了多长时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/05/10/5912897f0c087.png&quot; alt=&quot;QQ20170510-105800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　接着，让我们来用load data的方法尝试插入数据库吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql&amp;gt; truncate table millionData;
Query OK, 0 rows affected (0.09 sec)

load data local infile '/Users/yifanzhang/Downloads/millionData.txt' into table millionData;
ERROR 1148 (42000): The used command is not allowed with this MySQL version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上来就遇到了error的报错。通过报错我们知道是因为这个方法是不被当前的数据库版本所支持的。经过查询手册得知：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;LOCAL works only if your server and your client both have been configured to permit it. For example, if mysqld was started with –local-infile=0, LOCAL does not work. See Section 6.1.6, “Security Issues with LOAD DATA LOCAL”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　local关键字只有服务器端和客户端都设置为允许的情况下才可以使用。默认情况下mysqld是以–local-infile=0开始启动的，所以local不能够工作。&lt;/p&gt;

&lt;p&gt;　　所以说有两种方式可以将local功能打开。一种是在启动mysql客户端时带上允许local的参数，一种是配置在my.cnf中的，允许mysql一直保持local的开启。显然，我是在做测试，毕竟这个功能不会一直用到，所以我采用的就是第一种方法。那么我们先退出mysql，然后重新启动mysql客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;mysql --local-infile -uroot test
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 35
Server version: 5.7.10 Homebrew

Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; load data local infile '/Users/yifanzhang/Downloads/millionData.txt' into table millionData;
Query OK, 1000000 rows affected, 65535 warnings (5.88 sec)
Records: 1000000  Deleted: 0  Skipped: 0  Warnings: 12000000

mysql&amp;gt; truncate table millionData;
Query OK, 0 rows affected (0.20 sec)

mysql&amp;gt; alter table millionData add index name(name);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; alter table millionData add index phone(phone);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; alter table millionData add index phoneAndName(phone,name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; load data local infile '/Users/yifanzhang/Downloads/millionData.txt' into table millionData;
Query OK, 1000000 rows affected, 65535 warnings (11.70 sec)
Records: 1000000  Deleted: 0  Skipped: 0  Warnings: 12000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　通过测试，我们可以看到用load data的方式插入数据，在数据表没有索引以及有索引的情况下，性能都要比之前的每一种方法快很多。只是，这种方法你需要导入的数据文本以及打开相关配置。在什么时候使用哪种情况，完全取决于你所处的环境之下。&lt;/p&gt;

&lt;p&gt;　　PS:拥有一千万数据量的millionData.txt总大小为146.2MB，在数据库中包括三个索引的容量为41MB。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html"></summary></entry><entry><title type="html">实现jekyll分类目录</title><link href="http://naffan.cn/tech/2017/04/15/01.html" rel="alternate" type="text/html" title="实现jekyll分类目录" /><published>2017-04-15T00:00:00+08:00</published><updated>2017-04-15T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/04/15/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/04/15/01.html">&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/15/58f1026a213b8.png&quot; alt=&quot;jekyllserve&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　首先，感谢作者sverrirs的开源项目&lt;a href=&quot;https://github.com/sverrirs/jekyll-paginate-v2&quot;&gt;jekyll-paginate-v2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　自打我这个博客建立到现在已经有半年的时光了，从简单的jekyll本机跑起来，到实现各种rb的插件，再到部署到github-pages服务器上，然后又研究了如何让page可以实现插件功能，之后又发现百度蜘蛛抓被github-pages禁止后转向了CDN服务，现如今又解决了jekyll的分类的分页。可以说，从现在开始我的博客终于实现了作为一个博客的最基础的功能。当刚才实现了分类的分页让我欣喜若狂，我终于不用担心着自己的文章多的只能在一个html中不够地方展现了。&lt;/p&gt;

&lt;p&gt;　　接下来介绍一下实现方法吧，现在都夜里1点了，今天（周六）早上还要上班呢，赶紧在睡觉之前把这篇文章写完吧。&lt;/p&gt;

&lt;p&gt;　　jekyll-paginate-v2是一个专给jekyll博客系统开发出的一个分页类，他继承了jekyll的原始paginator方法，并且将每个目录中的paginator.posts替换成YAML中所指定的聚合类（collectoion,category,tag），最终达到只要在YAML中规定好目录的所属分类即可实现分类中的分页效果。&lt;/p&gt;

&lt;p&gt;　　由于，jekyll的源代码中是不支持分类的分页的，可以从官方的&lt;a href=&quot;http://jekyll.com.cn/docs/pagination/#note&quot;&gt;说明文档&lt;/a&gt;中看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不支持对“标签”和“类别”分页
分页功能仅仅遍历文章列表并计算出结果，并无读取 YAML 头信息，现在不支持对“标签”和“类别”分页。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　就因为jekyll本身不支持这样的操作，所以引来了很多的开发者致力于实现这个功能，虽然很多开发者都在试图开发出这个功能，但是也许是因为jekyll过于小众，所以从进展上来说，没有一个可以兼容的实现此功能的。但是，16年12月sverrirs却开发出了jekyll-paginate-v2分页类，终于实现了这个功能。其实，我也是半年以后才发现他这个插件的。通过它的帮助文档，虽然有一些小小的问题，但是最终还是实现了我梦寐以求的功能。不得不说这个开发者为我们jekyll用户造福了。&lt;/p&gt;

&lt;p&gt;　　就像说明文档说的一样，我们只需要安装好了这个插件，然后在_config.yml以及Gemfile中配置完成即可以应用了。然后，你再在每个分类index.html页面中规定好YAML信息就可以最终实现了。&lt;/p&gt;

&lt;p&gt;　　比如，我的&lt;strong&gt;深思默想&lt;/strong&gt;分类，thinking是这个分类的文件夹，置于root下，然后在这个文件夹中建立index.html，index.html中配置即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: 拿饭-沈思默想
pagination: 
  enabled: true
  category: thinking
---
&lt;/code&gt;&lt;/pre&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="jekyll,jekyll-paginate-v2" /><summary type="html"></summary></entry><entry><title type="html">如何培养自己结构化思维的能力</title><link href="http://naffan.cn/thinking/2017/04/09/1.html" rel="alternate" type="text/html" title="如何培养自己结构化思维的能力" /><published>2017-04-09T00:00:00+08:00</published><updated>2017-04-09T00:00:00+08:00</updated><id>http://naffan.cn/thinking/2017/04/09/1</id><content type="html" xml:base="http://naffan.cn/thinking/2017/04/09/1.html">&lt;blockquote&gt;
  &lt;p&gt;谈话开始的最初30秒决定一切，所以你需要一下子就抓住对方的注意力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　最近在微信公众号上看到了一篇文章叫做&lt;a href=&quot;http://mt.sohu.com/20170321/n484031234.shtml&quot;&gt;《结构化思维-让项目经理受益三生三世》&lt;/a&gt;，看完以后让我受益匪浅。故想借着热劲儿赶紧写一篇我对结构化思维的理解出来，但是工作需要十十六又正处我转型的过程中，所以一拖再拖没有来得及静下心来思考关于如何让自己掌握结构化思维的问题，好在当时看完了这篇文章以后就顺手在我的代办事务上记下了这个事情，于是之后的每一天电脑都会提醒我这个待办事情，今天终于可以腾出时间好好研究了一下。&lt;/p&gt;

&lt;p&gt;　　周六加完班吃完饭到家都快10点了，所以就翻出了这篇文章重新温读了一番。但是，感觉这篇文章写的还不是那么透彻。于是，就到网络上搜了一下“结构化思维”这个关键词，不搜不知道，一搜还真是文章一大把呢。但是，在点进前几篇文章阅读以后发现其他的文章无非就是互相改一改案例之类的，雷同的还是挺多的。&lt;/p&gt;

&lt;p&gt;　　关于“结构化思维”的方法，很多文章都提到了&lt;a href=&quot;http://wiki.mbalib.com/wiki/MECE分析法&quot;&gt;MECE&lt;/a&gt;方法。这个方法我就不再多赘述了，反正只需要记住八个字“相互独立，完全穷尽”即可。具体如何理解，可以参考这篇文章&lt;a href=&quot;https://sanwen8.cn/p/14bZzFA.html&quot;&gt;结构化思维是最值得培养的思维方式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　下面我来说一下我理解的MECE吧。如果你看了上边我链接的文章或者你曾经看过类似的文章你应该MECE有两种主流结构吧。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自上而下结构法&lt;/li&gt;
  &lt;li&gt;自下而上结构法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　其实区分这两种方法是很简单的。首先自上而下的结构法是针对于最终结果是已知的，在知道结果的情况下，去找寻能够完成的方法。举个例子，就是做菜。比如你想要炒个鱼香肉丝。炒鱼香肉丝就是结果，而我们要用自上而下的结构法去分析如何才能完成这道菜。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/09/58ea28b7c12ee.png&quot; alt=&quot;炒鱼香肉丝分析&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　根据上面的结构图，我们就能够很快的了解如何去炒鱼香肉丝了。当然，上面这幅图里面炒菜模块下面的结构没有画完整，但是已经能够体现出我想表达的自上而下分析问题的方法了。&lt;/p&gt;

&lt;p&gt;　　不论生活中还是工作中，自上而下的结构法用处也很多，不过总感觉有点像统筹管理。而且此思维方法感觉更加适用于生活中的安排之类的事情，更深入的思考还是需要掌握自下而上的结构方法。所以，更加关键的还应该是说自下而上更加对自己有帮助一些。&lt;/p&gt;

&lt;p&gt;　　当我认真的研究自下而上结构法的时候，我在网上看到了这么一篇文章：&lt;a href=&quot;http://news.mbalib.com/story/230292&quot;&gt;如何养成高薪人士的逻辑思维力？&lt;/a&gt;。这个题目一下子吸引到了我的注意力，我觉得作者也挺会给文章起名字的。通读了整篇文章以后，确实发现作者对自下而上结构法有自己的认识并且已经基本上掌握了这种方法。作者在这篇文章中给出了很多的例子，能够帮助我们切身的体会出这里面的道理。&lt;/p&gt;

&lt;p&gt;　　所有文章看完以后，我准备动手尝试进行归纳总结了。但是，我首先需要找个能够让我进行思考的例子。其实，身边很多事情都能当例子，可是当我突然想去研究一下的时候却发现脑中一片空白。后来突然想到这周六上班在等红绿灯的时候，有很多发广告的农民从车窗中扔进来了很多房产广告。那我就拿这些房产广告作为例子，假设自己要在这些广告中挑选一套房子。&lt;/p&gt;

&lt;p&gt;　　首先，让我先列举一些自下而上结构法的几个关键步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;头脑风暴：把所有能够想到的想法碎片列举出来&lt;/li&gt;
  &lt;li&gt;连线分组：对这些碎片进行归纳并连线&lt;/li&gt;
  &lt;li&gt;结构提炼：对分组后的结果一一分组，这一步就要依照MECE方法的独立且穷尽来这里了&lt;/li&gt;
  &lt;li&gt;补充观点：因为有了分组了，所以就能够按照这个分组的意义去补充更多的细节了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　综上所述，当整幅图画出以后，就能够让你一目了然所有的细枝末节了。通过这幅图就能够帮助我们总结归纳然后做出明智的选择了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/09/58ea59cecd09a.png&quot; alt=&quot;房屋小广告&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　首先，我按照1中所说的，将我能够想到的关于我认为购置房产时购房者最关心的问题一一列举了出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/10/58ea633509f76.png&quot; alt=&quot;QQ20170410-000608@2x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　当然，仅仅这些思维碎片肯定是不够的。但是在刚开始的时候想出的多少并不是关键，我们可以多想想，即使漏掉了在以下的步骤中我们还会再重新审视一遍的，在那个时候因为有了组织结构了，所以更能够帮助自己选定了方向去思考。接下来我就应该将这些碎片进行连线划分了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/10/58ea63354947a.png&quot; alt=&quot;QQ20170410-001458@2x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　通过上图，我们可以看到这些碎片已经被我一一关联了起来。这些线就是我脑中认为的碎片之间的关系。比如单价和平米是一种类型，地理位置和用途是一个类型等等。现在我们可以对这些琐碎的思维碎片进行结构化了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/10/58ea63354c7b7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这样这里出来以后，我就可以很直观的看到，我现在这个阶段能够考虑到的就是这几个组织结构：价格，环境，用途，利益。&lt;/p&gt;

&lt;p&gt;　　在这幅图中，我有个思考过程。其中用途相关这里，为什么类型和政策会放在这里呢？没错，是MECE。我是这样想的，类型就是这个房子是商住两用的还是住宅的还是商驻的。政策就是国家规定这个房子是用来干什么的。其实考虑到如果把政策放到利益相关这个组织里面，那就代表我认为的政策是国家对买卖房屋出的限购之类的政策了。我本意并非如此，我想的是国家对这种房子的规划，也就是说这种房子将来政府会把他归属于那种类别怎么用。因为这样的考虑所以我把政策规划到用途相关里了。如果，把政策单拎出来放在一个叫做政策相关的结构里，也不是不行。但是，总感觉这个政策相关和我买房并没有太大关系。而且还会和利益产生交集。说了那么多其实我想说明的是，这些归纳总结是属于一个人自己的想法的，即使别人不这么认为，也没多大关系，因为是你自己在总结，你总结出来的东西收益的是自己，而非他人。&lt;/p&gt;

&lt;p&gt;　　这样，我们已经完成了前三部了。接下来，我们需要进入到第四部，也就是对这些结构补充细节了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/10/58ea64aaf3ced.png&quot; alt=&quot;QQ20170410-004305@2x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　经过，最后这一轮的思考。我将我能够想到的方方面面全部总结到了这张表中。虽说，我对买卖房屋没有太多的经验。但是，如果我按照这个我总结出的标准去看房子，一定不会走眼。在将来的生活中，如果发现了更多的想法我就可以在这张表中继续填加现在没能够想到的细节了。长此以往，买房子这种事情自己就会有主心骨了。也不用听人家说如何如何了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/04/10/58ea6c7e2817f.jpg&quot; alt=&quot;表格&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　通过对每一项细节一一的带入到表中，这样就汇总出来了一份可供我们理解的结构化思维的工具了。通过这幅图我们可以直观的看到很多很多细节，虽然这个例子是拿街边小广告做的，而我也没有买房的意愿，但是我仍然觉得通过这么一归纳，买还是不卖的结果已经了然于胸。&lt;/p&gt;

&lt;p&gt;　　从表中我们可以看到。相比之下投资性价比最高的还是别墅这一款。但是，由于宣传单上缺少了太多的必要信息了，所以只能实打实的去咨询为好。另外，香江公馆和酒店公寓就稍微差点了，首先房屋是商住两用的，那就意味着房子的质量以及物业费会比住宅不划算很多。但是，价格上确实有很大优势，而这些优势也大都是建立在离城区相对较远上。另外，香江公馆周围的配套设施要比其他的房型都要齐全一些。所以，如果是真正的选择居住的话肯定会选香江公馆。至于艺术农庄这个项目来说，由于农庄的产权是又村子划拨的，他并不受政府的重视，也就是说政府是任由村子自有处置土地的，同样我们可以看出来这个35年使用权有一些问题。我们知道普通住宅使用权是70年，商用是45年。然而这个却是35年。也就是说这种农家院都是由村子管理的，好坏那就要看这个村子的知名度如何了。如果村子还没有发展起来呢，那买这种农场的意义就不存在了。毕竟风险太大，政府说啥就是啥，如果有一天政府要收回征地了，那么房子具体是不是你的也会说不清的。&lt;/p&gt;

&lt;p&gt;　　好了，经过以上的分析都是出自本人思考以后得出的结论。通过这个方法起初肯定是比价生疏的，但只要勤加练习，就像别人文章中所提到的一样。刻意的这样联系，3个月后，你就刻意融会贯通了。以后再遇见类似的事情，你都可以用这种结构化的思维去解决了。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="思维,能力" /><summary type="html">谈话开始的最初30秒决定一切，所以你需要一下子就抓住对方的注意力。</summary></entry><entry><title type="html">《跟任何人都聊得来》</title><link href="http://naffan.cn/books/2017/04/04/2.html" rel="alternate" type="text/html" title="《跟任何人都聊得来》" /><published>2017-04-04T00:00:00+08:00</published><updated>2017-04-04T00:00:00+08:00</updated><id>http://naffan.cn/books/2017/04/04/2</id><content type="html" xml:base="http://naffan.cn/books/2017/04/04/2.html">&lt;p&gt;　　今天要分享一本书了，其实一直想做这个栏目。但是，很长时间都没有下定决心去开始做起。另外，这个页面其实已经挂在本博客上已经有半年的时间了，因为jekyll框架没有对分类的文档做分页功能，所以有可能这个分类里面的文章会慢慢的变多变长，在几年时间内这个list页不会太难以忍受，但是如果我写很多的读后感的话，想必加载起来就会费劲起来了。不过还好，现在是刚开始，这些问题不是很急，而且页面展现的样子还是不错的。所以，我打算先这么凑合用着XD&lt;/p&gt;

&lt;p&gt;　　其实这本书很早就读完了，大概是在2016年6月份吧。起因是部门刚刚组建，招了一批心人。你知道刚建立的部门都跟打鸡血一样，分享什么的不可能差的。所以，大家有分享工作经验的，有分享帮助工具的，居然后来还有人分享看过的电影的，而且别人还特么的听的挺带劲。由于，我是第一个做分享的人。所以，我自然有很大的主动权，就这样我选择了给大家分享一篇我的读后感，主要就是讲人与人之间的沟通的。&lt;/p&gt;

&lt;p&gt;　　你别小看人与人之间的沟通，你说一个人自从生下来就开始与别的人一起沟通，从小到大你想要什么想做什么都会与别人产生交集，那么小的时候还好，大家都能够让着你，让你产生了自我为中心的思想，所以自己任性一点也没太大的关系。但是，随着你的年龄越来越大。从升学到毕业再到踏入社会，你会慢慢滴发现你的周遭出现了很多都是跟你一样以自我为中心的人，这些人有些不会替别人照相，有些人跟别人经常产生瓜葛。作为主人公的你，肯定会想一想：你能不能以自我为中心改变其他所有人的意愿？如果不能的话，你应该如何去做呢？当然，很自然的就会想如何跟别人产生交流，从而改变彼此的关系。所以，我们可以说。人，立于社会必要沟通。有效（正向）沟通是需要有好的方法的。有了好的方法才能够让沟通的变得事半功倍。也就是因为这个原因，这本书的作者就对沟通展开了思考，从而写下了这本书，书的名字叫做《跟任何人都聊得来》。&lt;/p&gt;

&lt;p&gt;　　首先，让我们看看书中所说的作者概括的四个关键要素：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;坚持自己的个性，让自己的独特之处发挥作用。&lt;/li&gt;
  &lt;li&gt;准备越充分，你就越自信。&lt;/li&gt;
  &lt;li&gt;永远保持一颗好奇的心，千方百计让自己变得有趣。&lt;/li&gt;
  &lt;li&gt;学会从他人的思维角度出发，真正在意对方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　第一，人总是对自己的现状不满。如果是直发，就总想着烫成卷发，如果本身就是卷发，又总是羡慕那些直发的。我们总是在两个极端徘徊。&lt;/p&gt;

&lt;p&gt;　　性格方面也是如此，我们这些内向的人往往想要成为外向的人，因为后者似乎在应对生活及人际关系方面更为自如。观察外向的人如何交流很有益，因为我们可以采纳那些适合自己的技巧。&lt;/p&gt;

&lt;p&gt;　　其实，相对于交谈，倾听有时候显得更为重要，从倾听中我们也可以获得更多的信息，而在倾听方面，内向性格往往更具优势。&lt;/p&gt;

&lt;p&gt;　　作者说，他从事沟通力培训很多年。不管是何种身份、教育背景和收入情况，他们或多或少存在着两个方面的问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;交谈困难症&lt;/li&gt;
  &lt;li&gt;倾听困难症&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　不论上面的哪种，他们只要能够结合自身的长处和性格特点，沟通就可以顺利进行。不管我们是偏向于安静还是偏向于表达，这都不是错误。我们越是煞费苦心改变自己，越是努力让自己变得面目全非，就会越感到沮丧。&lt;/p&gt;

&lt;p&gt;　　第二，作者认为一定要自信，至少看上去要如此。不要不好意思，因为你并不孤单。作者拿自己在研讨会之前的一天对会场做了充分的熟悉，以至作者当在台上演讲的时候并不感到会场的压力。&lt;/p&gt;

&lt;p&gt;　　可以说，充分准备是让交谈更为顺利的简单方式，预先思考的越多，你就越自信。&lt;/p&gt;

&lt;p&gt;　　第三，卡耐基曾说过“与其花两年的时间让他人对你感兴趣，不如花两个月的时间真正对他人感兴趣，这样会给你带来更多的朋友。”所以说，改变只能由内而外产生，你只有真心对他人和世界充满好奇，才会真正达到预期的结果。&lt;/p&gt;

&lt;p&gt;　　第四，如果你能够帮助他人、满足他人所需，在这个过程中你的需要也会得到满足。当你在社交场合犹豫：自己要不要接近某人，开始交谈呢？淡定的主动做出尝试，通常结果会让你非常意外，非常惊喜。&lt;/p&gt;

&lt;p&gt;　　最后，作者给出了肯定的定理：&lt;strong&gt;没有人是天生的沟通达人&lt;/strong&gt;。只要遵循着作者提供的“工具”，就能够对下面这些问题得出结论：&lt;/p&gt;

&lt;p&gt;　　如何了解真实的自己，找到适合自己的沟通技巧。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如何深入倾听他人。&lt;/li&gt;
  &lt;li&gt;如何有效地提问。&lt;/li&gt;
  &lt;li&gt;如何将压力转化为创造性能量。&lt;/li&gt;
  &lt;li&gt;如何恰到好处地结束一次交谈。&lt;/li&gt;
  &lt;li&gt;如何应对比较棘手的局面。&lt;/li&gt;
  &lt;li&gt;如何应对移动互联时代的沟通问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　好了，有了这些基本的介绍，我想也让你明白了这本书要讲的那些道理了。其实，道理都很简单。但是，当你真正的要去做的时候，却发现如此之难。这并不怪你，因为大家都是这样的。任何事情都包括主动方和被动方。我们要做的就是让这两方融为一体，让这两方傻傻分不清楚XD。适用于每个人的方法是不同的，所以我们找不出标准答案。但是，有个原理可以帮助我们判断。那就是只要是你遵循着你的真性情，就一定不会错。&lt;/p&gt;

&lt;p&gt;　　人大体上可以分为两类，一个是内向型，一个是外向型。书中也对这两类做了明确的定义。&lt;/p&gt;

&lt;p&gt;　　“内向型”是指那些通过独处就可以获得能量的人。他们并不一定很害羞，但是，在和一群人相处之后，他们更需要个人的空间。他们倾向于在内心里自我反思，而不是和他人一起交流自己的想法。可能在集体讨论时他们不太容易参与其中，但是，之后他们会独自把问题思考一遍。通常情况下，他们的最终结论都是很可靠的，而且是经过深思熟虑的，当然，这样的结论有时需要更长的时间来酝酿和总结。他们并不是不善言谈，只是倾向于先思考再开口。&lt;/p&gt;

&lt;p&gt;　　“外向型”是指那些通过群体交流获得能量的人。他们倾向于通过交谈来思考。人越多，他们越是活跃。交谈中，他们通常都能够最好地表达自己的观点。他们反应敏捷，不会因为人多势众而恐慌。可能一开始的结论略显浅薄，不过，他们会意识到这不过是整个过程的一部分，最后会有更好的结论。&lt;/p&gt;

&lt;p&gt;　　那么如何分辨你是内向型还是外向型的呢？书中也给出了一套题，做完根据所得分数就能够算出你是属于哪一类的。其实我觉得这个题没太大必要，谁不了解自己的性格啊？我们关心的是不管我们是啥性格，在遇见事儿的时候，用哪种解决方法更为合适罢了。或者说，哪种性格可以在社会上混的更开而已。另外，我们需要的是沟通技巧，比如当一个人表达了他自己的意见以后，你应该如何回复才能够让事情向着你更愿意看到的结果为导向。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="books" /><category term="沟通,书籍" /><summary type="html">　　迈克·贝克特尔（Mike Bechtle），亚利桑那州立大学教育学博士，有多年的大学及政府部门的从业经验，现任富兰克林科威公司(Franklin Covey---由《高效能人士的七个习惯》作者Stephen R. Covey博士创建)高级培训顾问，先后为世界500强企业进行过2500多场研讨会形式的讲座，是名副其实的金牌培训师。　　著有《跟任何人都聊得来》《自信谈话第一书》《疯狂行为学》等畅销书，曾在《企业家》（Entrepreneur）杂志上发表多篇文章。</summary></entry><entry><title type="html">为什么倒热水的和倒冷水的声音不一样？</title><link href="http://naffan.cn/thinking/2017/04/04/1.html" rel="alternate" type="text/html" title="为什么倒热水的和倒冷水的声音不一样？" /><published>2017-04-04T00:00:00+08:00</published><updated>2017-04-04T00:00:00+08:00</updated><id>http://naffan.cn/thinking/2017/04/04/1</id><content type="html" xml:base="http://naffan.cn/thinking/2017/04/04/1.html">&lt;p&gt;　　前几天在公司接水的时候，接了一瓶热水。热水发出的声音突然抓住了我的注意力，倒热水的声音明显比倒凉水的声音高且闷，这让我感到了浓厚的兴趣，于是本文的题目这个问题就产生在了我的脑子里。我打算过几天研究一下看看这个是为什么，不过正好我的工作有了较大的变化，拖了我一个星期之久，现在就来看看是什么原因导致的倒热水合倒凉水的声音不相同呢？&lt;/p&gt;

&lt;p&gt;　　首先，从问题中就能想到，肯定是温度导致这个显现的。那么为什么热的水声音就高呢？带着这个问题首先查了下知乎的文章，从&lt;a href=&quot;https://www.zhihu.com/question/38401210&quot;&gt;《开水和冷水倒在地上的声音为什么不一样》&lt;/a&gt;看到很多的答案，还真有个相当专业的回答者从物理学的角度回答了此问题。通篇看下来，答者跳过的步骤还真是多，如何求证的推到也没有写具体，只是列举了他自己认为的关键公式而已。而最后的他给出答案是&lt;strong&gt;温度越高，声音的频率越低&lt;/strong&gt;。再让我查一下声音频率越低，声调会怎样后发现，是越低沉。好了，这样我们有了理论基础就可以打遍天下无敌手啦。其实这个是用科学公式的方法去证明这个问题现象的。那么我们要是在跟人家聊天的时候，也搬出这个公式来，那试想谁会有空跟你掰扯这个呢？&lt;/p&gt;

&lt;p&gt;　　那让我看看别的解释吧，有人说热水中的分子运行更快，导致热水的流动性更高，粘稠度更低。就像蜂蜜一样，凉蜂蜜流的会比热蜂蜜更难更慢。所以，在倒热水的时候，由于分子活动的更加频繁，所以声音也就发出的更大。&lt;/p&gt;

&lt;p&gt;　　还有一些人说这是因为水蒸气的原因，因为热水周围时刻被水蒸气包围，所以当你倒热水的时候，接触地面的首先不是水，而是水蒸气，也就相当于水蒸气包裹住了水先接触地面，所以水蒸气起到了缓冲的作用，也就造成了声音显得低沉了许多。&lt;/p&gt;

&lt;p&gt;　　最后，让我们看看&lt;a href=&quot;http://www.1010jiajiao.com/czwl/shiti_id_9a1fd2b0fe8237e085782c5d94051758&quot;&gt;初中物理&lt;/a&gt;中是怎么阐述这个问题的吧。当然，这道题是初中物理的习题，说明问题的深度不高，只是一个概念而已。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="自然" /><summary type="html">　　前几天在公司接水的时候，接了一瓶热水。热水发出的声音突然抓住了我的注意力，倒热水的声音明显比倒凉水的声音高且闷，这让我感到了浓厚的兴趣，于是本文的题目这个问题就产生在了我的脑子里。我打算过几天研究一下看看这个是为什么，不过正好我的工作有了较大的变化，拖了我一个星期之久，现在就来看看是什么原因导致的倒热水合倒凉水的声音不相同呢？</summary></entry><entry><title type="html">通过命令行获取NAS 320L权限</title><link href="http://naffan.cn/tech/2017/03/24/01.html" rel="alternate" type="text/html" title="通过命令行获取NAS 320L权限" /><published>2017-03-24T00:00:00+08:00</published><updated>2017-03-24T00:00:00+08:00</updated><id>http://naffan.cn/tech/2017/03/24/01</id><content type="html" xml:base="http://naffan.cn/tech/2017/03/24/01.html">&lt;p&gt;　　5年前买的DLINK的NAS一直在被我用来当做NFS用。当时买回来这货就是看中了可以和远程迅雷绑定，可以是实现在任何地只要知道下载链接就可以通过远程迅雷将下载任务直接拖拽到家中的NAS中，这样我在上班的同时，就可以利用家里的网络下载一些自己喜欢的电影，等到家了以后就可以直接用平板通过SMB协议访问到NAS上，这样就可以直接看电影了。其实这东西还挺好用，给我这几年的生活带来了很大的快乐，但是就是总会有意想不到的事情发生。这玩意在16年中旬的时候坏过一次，拿到DLINK客服那里想修一下，结果发现这货早就停产了，只能从总部发一个新的回来供我置换，并收我160元置换费。我只是怕麻烦，又因为自己已经熟悉了这个产品了所以就答应了他们的提议。可没成想换回来以后发生了一件让我到现在都很头疼的事情，那就是远程迅雷这套脚本增加了安全机制了。貌似是DLINK和迅雷在这款产品上有了分歧，迅雷不让用户在smb协议下直接删除所下载下来的文件了，如果想下载还必须登入他们的远程下载网站去删除。这样让我非常恼火，远程迅雷的用户体验本来就不好，却还逼着用户访问他们网站去删除已经存在自己NAS中的资料。&lt;/p&gt;

&lt;p&gt;　　就因为这个问题刚开始我还以为是人家客服给我换回来的是一个残次品而我又亲自找他们去了一趟，后来不成我还给他们总部的客服打电话，最后给我转到了他们的高级技术人员才真正证实了这件事不是DLINK的问题，而是迅雷在安装到NAS上的脚本做了些文章。&lt;/p&gt;

&lt;p&gt;　　接下来我就说说来龙去脉吧。当我想删除NAS上的文件时，总是有报错信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d4011869c21.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　就光凭这种报错信息我很难发现是哪里的权限出了问题，但是优先想到的就是NAS上有什么权限。于是我还特意登录了NAS的浏览器后台去设置了我的用户组。但是，通过很多次测试根本就没有用处。也就是说问题不出在应用层面上的权限问题。而后台中的用户组其实是针对访问内容时的用户设计的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d4011884114.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　接下来我就想看看，到底底层给我返回的是什么状态码，好让我能够有目的性的去排查。结果，我通过wireshark找到了真正原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d40118b9a96.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　看到SMB条目下边的 nas NT Status: STATUS_ACCESS_DENIED (0xc0000022)错误代码了吧。这就说明了一切的问题。是由于NAS中的权限配置的原因造成的，而罪魁祸首肯定是迅雷的脚本做的怪。&lt;/p&gt;

&lt;p&gt;　　好了，问题确定了，我们就要想方设法的去获取NAS的权限。NAS的系统是UNIX的，所以我们需要用ssh区连接。但是，我在连接的时候出现了问题。问题是这样的，在windows上用putty就可以ssh到NAS上，但是在mac上我用ssh就不能够连接上。后来，通过查询报错信息，在网上搜了一下发现了问题所在。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d40118580dd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　错误提示说不能与nas进行联通，原因是没有找到匹配的宿主key，而且服务器的宿主协议只接受ssh-dss(DSA)。将这段话作为关键词在搜索引擎上搜了一下，果然找到了这个错误提示的响应的解决办法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d4011876a07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这说的是openSSH 7.0或者更高版本的应用是默认关闭这个公钥算法的，因为这个算法太容易破解了。而后，这篇文章&lt;a href=&quot;http://cache.baiducontent.com/c?m=9d78d513d99f1cb8589ccb2d4b478d3d450197634d8d8d5439c39339ca3310564717a5f065750704a29121205df95e5d9ae73605200351f1c19fd30acabbe3757bdc7074671df65613a00eafba07649b37912afeaf6ff0bb8064d2efc6949f0a5c9015433897f1f8471d518f2ae71446bee4ce14541e4aaded4734a2066a77c87613e70ceee0453441dea8&amp;amp;p=ce71c64ad48911a05bed9122544191&amp;amp;newp=8033d315d9c041aa1bbe9b7c527a82231610db2151d6d501298ffe0cc4241a1a1a3aecbf26291b04d1ce786405a44257e9fa3274360234f1f689df08d2ecce7e6c&amp;amp;user=baidu&amp;amp;fm=sc&amp;amp;query=no+matching+host+key+type+found%2E+Their+offer%3A+ssh%2Ddss&amp;amp;qid=b4c9b66f00047dfc&amp;amp;p1=2&quot;&gt;《OpenSSH Legacy Options》&lt;/a&gt;也给出了响应的答案。按照帮助文档的提示下，我迅速的登录到了NAS的系统中，并且获取到了NAS的管理员权限。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/03/24/58d40118855b1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　之后，就是要找到迅雷的脚本了，我想这个脚本应该不难找也不难改，无非就是一个.sh的文件而已。等到下次我研究出来，再发一篇文章上来。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="nas" /><summary type="html">　　5年前买的DLINK的NAS一直在被我用来当做NFS用。当时买回来这货就是看中了可以和远程迅雷绑定，可以是实现在任何地只要知道下载链接就可以通过远程迅雷将下载任务直接拖拽到家中的NAS中，这样我在上班的同时，就可以利用家里的网络下载一些自己喜欢的电影，等到家了以后就可以直接用平板通过SMB协议访问到NAS上，这样就可以直接看电影了。其实这东西还挺好用，给我这几年的生活带来了很大的快乐，但是就是总会有意想不到的事情发生。这玩意在16年中旬的时候坏过一次，拿到DLINK客服那里想修一下，结果发现这货早就停产了，只能从总部发一个新的回来供我置换，并收我160元置换费。我只是怕麻烦，又因为自己已经熟悉了这个产品了所以就答应了他们的提议。可没成想换回来以后发生了一件让我到现在都很头疼的事情，那就是远程迅雷这套脚本增加了安全机制了。貌似是DLINK和迅雷在这款产品上有了分歧，迅雷不让用户在smb协议下直接删除所下载下来的文件了，如果想下载还必须登入他们的远程下载网站去删除。这样让我非常恼火，远程迅雷的用户体验本来就不好，却还逼着用户访问他们网站去删除已经存在自己NAS中的资料。</summary></entry></feed>
