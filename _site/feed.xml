<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-30T18:50:49+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">有关字符集知识的总结</title><link href="http://localhost:4000/tech/2019/09/24/01.html" rel="alternate" type="text/html" title="有关字符集知识的总结" /><published>2019-09-24T00:00:00+08:00</published><updated>2019-09-24T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/09/24/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/09/24/01.html">&lt;p&gt;　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。&lt;/p&gt;

&lt;p&gt;　　因为字符集类问题是很庞大的，所以让我们来规定几种字符集先。让我就unicode,gbk,ascii等字符集先做一定的温习。&lt;/p&gt;

&lt;p&gt;　　首先，我们来说说我们比较常用的编码之间的关系，好来展开这篇文章的复习。当计算机问世的时候因为是美国人造的，所以美国人就用了些英文字母和标点符号和辅助型符号，这些字符加起来也不过128位，所以就诞生了&lt;code&gt;ASCII&lt;/code&gt;码。后来发展到了欧洲，欧洲那么多国家，每个国家的字母都不太一样，所以人们就扩充了字符集，从而出了拉丁语系的&lt;code&gt;ISO8859-1&lt;/code&gt;字符集。再后来中国人参与进来了，我们中国字常用就7000多个。以现有的字符集根本承载不下来那么多字体，那人们就创造出来了&lt;code&gt;GBK&lt;/code&gt;字符集，这种字符集和之前两种的区别就是GBK使用两个字节来存储的，其中收录了21003个字符。再后来又出了&lt;code&gt;GB18030&lt;/code&gt;，可以收录数量达到了70244个。这个编码采用了1，2，4字节的存储方式，具体存储方式先不说。这个时候人们发现随着用来存储的字节的增多，存储量也变的巨大了。所以，传输的过程中效率问题捉襟见肘。于是，人们就开始考虑更好的存储方法，既能够囊括更多的字符同时存储的容量又不会急剧的膨胀。那么就需要一种智慧的存储方案来解决，于是&lt;code&gt;unicode&lt;/code&gt;编码营运而生。unicode编码采用变长的存储结构，通过高位的特殊位数来规定采用的字节数，从而达到了目的。unicode中分为三类:&lt;code&gt;utf8&lt;/code&gt;,&lt;code&gt;utf16&lt;/code&gt;和&lt;code&gt;utf32&lt;/code&gt;。主要用的还是utf8，而且utf8已然成为现如今世界上最为普遍的编码。&lt;/p&gt;

&lt;h1 id=&quot;一ascii码&quot;&gt;一、ASCII码&lt;/h1&gt;

&lt;p&gt;　　我们知道，计算机内部存储的数据都是二进制值。每一个二进制位（bit）有&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;两种状态。因此，八个二进制可以组合出256种状态，由八位组成一个字节，即从&lt;code&gt;00000000&lt;/code&gt;到&lt;code&gt;11111111&lt;/code&gt;。下表是128种ascii码表。当时规定最&lt;code&gt;高位为0&lt;/code&gt;，剩下的七位来分别表示这128个字符。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/asciifull.gif&quot; alt=&quot;ascii表格&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;二非ascii码&quot;&gt;二、非ASCII码&lt;/h1&gt;

&lt;p&gt;　　可是，当高1位为1的时候，还没有利用上。所以，有的国家就开辟了剩下的128个字符，但是随之而来的问题也接踵而来。问题是每个国家都可以扩充这后128位，最终导致前一128个都是相同的，但是后128个就不同国家都不一样了。如果再这么继续下去整个世界对于字符上就不再统一了，这简直就是个噩梦。于是，美国人开发出了unicode编码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/extend.gif&quot; alt=&quot;扩展的&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;三unicode码&quot;&gt;三、Unicode码&lt;/h1&gt;

&lt;p&gt;　　Unicode是一本很厚的字典，记录着世界上所有字符对应的一个数字。我们可以通过这两个网站查看到每个字符相对应的存储数值，&lt;a href=&quot;https://home.unicode.org/&quot;&gt;unicode.org&lt;/a&gt;和&lt;a href=&quot;http://www.chi2ko.com/tool/CJK.htm&quot;&gt;unicode对照表&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;四utf-8&quot;&gt;四、UTF-8&lt;/h1&gt;

&lt;p&gt;　　unicode主要遇到了两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何让计算机区分出来&lt;/li&gt;
  &lt;li&gt;如何使存储空间更小&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　UTF-8是目前互联网上使用最广泛的一种unicode编码方式了，它主要的特点就是变长。它可以使用1-4个字符表示一个字符（零几年还有6个字符表示的方法，但是后来取消掉了）。规则如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。&lt;/li&gt;
  &lt;li&gt;对于需要使用 N 个字节来表示的字符（N &amp;gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode 十六进制码点范围&lt;/th&gt;
      &lt;th&gt;UTF-8 二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0000 - 0000 007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0080 - 0000 07FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0800 - 0000 FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0001 0000 - 0010 FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　下面，我们用&lt;code&gt;帆&lt;/code&gt;字为例进行讲解&lt;/p&gt;

&lt;p&gt;　　帆的unicode十六进制是&lt;code&gt;5E06&lt;/code&gt;，补全后位&lt;code&gt;0000 5E06&lt;/code&gt;，二进制是&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;。跟具上表可以得知是在第三列范围内的。所以帆的utf8编码需要三个字节，即格式为&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;。从最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0，就得到了&lt;code&gt;11100101 10111000 10000110&lt;/code&gt;，转换成十六进制后得到utf8十六进制&lt;code&gt;E5 B8 86&lt;/code&gt;。我们可以通过&lt;a href=&quot;http://www.mytju.com/classcode/tools/encode_utf8.asp&quot;&gt;utf8和unicode转化工具&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;　　另外，说一下我们的通常表示法。utf8的16进制数表示开头加&lt;code&gt;0x&lt;/code&gt;，unicode开头加&lt;code&gt;U+&lt;/code&gt;。所以，帆字的utf8的16进制应该是&lt;code&gt;0xE5 0xB8 0x86&lt;/code&gt;，而unicode的16进制表示应该是&lt;code&gt;U+5E06&lt;/code&gt;。这个注意一下就好了，别人家写出来咱分辨不出来。&lt;/p&gt;

&lt;h1 id=&quot;五十六进制转换十进制方法&quot;&gt;五、十六进制转换十进制方法&lt;/h1&gt;

&lt;p&gt;　　这节其实是我在写这篇文章的时候遇到的问题。在这里我也就不单独拿出来写了，直接在这里温故而知新吧。我们在表示十六进制的时候，采用的表示法是&lt;code&gt;0x&lt;/code&gt;。比如我们表示&lt;code&gt;0xA4&lt;/code&gt;，其对应的十进制数怎么算呢？首先，我们要知道16进制的权为16，这个数转化为是十进制的方法和二进制转换成十进制一个道理。 是10(A) * 16的一次方+4 * 16的0次方，最终等于164.那我们算下&lt;code&gt;0xFF&lt;/code&gt;，是不是就等于255呢?答案是没错。&lt;/p&gt;

&lt;h1 id=&quot;六大端法和小端法&quot;&gt;六、大端法和小端法&lt;/h1&gt;

&lt;p&gt;　　计算机在存储器重排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34，它的存储方式为下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/09/26/ZxRMdziesI6Th9v.png&quot; alt=&quot;大端法和小端法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　TF-32用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理），如果不分大小端的话，那么就会出现解读错误，比如我们一次要处理四个字节 12 34 56 78，这四个字节是表示0x12 34 56 78还是表示0x78 56 34 12 ，不同的解释最终表示的值不一样。&lt;/p&gt;

&lt;h1 id=&quot;七utf-16&quot;&gt;七、UTF-16&lt;/h1&gt;

&lt;p&gt;　　utf-16也是边长字节表示，我们可以简单看看其表示的方法，不用太细的去看，等到真碰上了再思考也不迟。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于编号在U+0000到U+FFFF的字符（常用字符集），直接用两个字节表示。&lt;/li&gt;
  &lt;li&gt;编号在 U+10000到U+10FFFF之间的字符，需要用四个字节表示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　同样，UTF-16 也有字节的顺序问题（大小端），所以就有UTF-16BE表示大端，UTF-16LE表示小端。&lt;/p&gt;

&lt;h1 id=&quot;八utf-32&quot;&gt;八、UTF-32&lt;/h1&gt;

&lt;p&gt;　　utf-32是字符对应标号的证书二进制形式，四个字节，直接转化就可以了。比如&lt;code&gt;帆&lt;/code&gt;的unicode为&lt;code&gt;U+5E06&lt;/code&gt;，直接转化成二进制后得到：&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以根据他们高低字节的存储位置来判断他们所代表的含义，所以在编码方式中有 UTF-32BE 和 UTF-32LE ，分别对应大端和小端，来正确地解释多个字节（这里是四个字节）的含义。&lt;/p&gt;

&lt;h1 id=&quot;九随便用go玩玩&quot;&gt;九、随便用GO玩玩&lt;/h1&gt;

&lt;p&gt;　　本来想用GO实现下编码互转的，但是后来发现GO原声只支持UTF-8编码，如果想用GB2312等编码还得去get包，我尝试了下但是timeout了。哎，临近国庆，很多东西都用不了啦。以后有需要再弄吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;unicode/utf8&quot;
)

func main(){
	b := []byte(&quot;Hello, 帆&quot;)
	for len(b) &amp;gt;0{
		r,size := utf8.DecodeLastRune(b)
		fmt.Printf(&quot;%c %v\n&quot;,r,size)
		b = b[:len(b)-size]
	}
	c := []byte(&quot;帆&quot;)
	fmt.Println(c)
}

打印结果：
帆 3
  1
, 1
o 1
l 1
l 1
e 1
H 1

[229 184 134]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以看到，utf8的中文在GO中是占3个字符的。而且帆的utf8的16进制数&lt;code&gt;E5 B8 86&lt;/code&gt;转换成十进制就是&lt;code&gt;[229 184 134]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6bdc0d52620a&quot;&gt;彻底弄懂 Unicode 编码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode 和 UTF-8&lt;/a&gt;&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="charset" /><summary type="html">　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。</summary></entry><entry><title type="html">Mysql中的too many connections问题背后</title><link href="http://localhost:4000/tech/2019/09/23/01.html" rel="alternate" type="text/html" title="Mysql中的too many connections问题背后" /><published>2019-09-23T00:00:00+08:00</published><updated>2019-09-23T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/09/23/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/09/23/01.html">&lt;p&gt;　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。&lt;/p&gt;

&lt;p&gt;　　在中秋节前的那个周二，是我们公司上线的窗口期。在晚上6点左右的时候，同事告诉我50那台机子挂了，测试数据库也在这台机子上，所以也挂掉了。我们上线前QA是需要在测试线回归一下问题后才能上线的，但是由于测试数据库挂了，导致QA的测试不能够进行，时间太短又来不及去迁移整个数据库，看来只能求助OP同学了。后来，OP同学告诉我们50这台服务器是我们的自运维机器，OP们也不知道如何操作（他们其实是不愿意管）。好说歹说OP才腾出功夫将服务器重启了（后来得知，其实并没有重启，而是50这台服务器是虚机，因为某些原道导致机器卡住了，于是虚机就被暂存起来了，然而OP做的就是吧暂存的虚机重新打开就行了），这样看似一切正常的操作，突然mysql就出现了too many connections的报错，这回我是根本连不上mysql了。经过询问DBA，这种情况是数据库太多的僵尸链接导致的，僵尸链接没有放开连接，导致后边的连接根本请求不到资源。这下问题就来了，我没有root权限（其实知道这台机子因为年代久远的原因没有人知道他的root权限了），那怎么办才能够清除这些僵尸链接呢？好了，前言已经铺垫的很多了，我也确实需要回忆一下我的解决方案和问题背后涉及的原理了。&lt;/p&gt;

&lt;h3 id=&quot;问题解释&quot;&gt;问题解释&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if you get a Too many connections error when you try to connect to the mysqld server, this means that all available connections are in use by other clients.

发生too many connections的错误是因为所有可用的连接都被其他客户端保持着呢。

The number of connections permitted is controlled by the max_connections system variable. The default value is 151 to improve performance when MySQL is used with the Apache Web server. (Previously, the default was 100.) If you need to support more connections, you should set a larger value for this variable.

max_connections定义了被允许连接的数量。默认值是151，151是一个性能较高的值，尤其在web服务上。如果你需要更多的连接数，需要设置更大的数字。

mysqld actually permits max_connections+1 clients to connect. The extra connection is reserved for use by accounts that have the CONNECTION_ADMIN or SUPER privilege. By granting the privilege to administrators and not to normal users (who should not need it), an administrator who also has the PROCESS privilege can connect to the server and use SHOW PROCESSLIST to diagnose problems even if the maximum number of unprivileged clients are connected. See Section 13.7.6.29, “SHOW PROCESSLIST Syntax”. 
 
 mysqld进程使max_connections+1为客户端最大数量，这1个特别的连接是提供给最高用户权限的人用的。最高权限的人可以单独拥有这个链接，以此在发生问题时可以登录到mysql中查看问题所在，通过show processlist命令可以分析问题。也就是说151个连接全部被打满时，仍然有个第152链接等待这个最高权限的人进入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面的引用出自mysql用户手册的原语。这只是告诉了我们在这种错误的情况下我们是可以做出调整的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like '%max_con%' \G;
*************************** 1. row ***************************
Variable_name: max_connect_errors
        Value: 100
*************************** 2. row ***************************
Variable_name: max_connections
        Value: 151
*************************** 3. row ***************************
Variable_name: mysqlx_max_connections
        Value: 100
*************************** 4. row ***************************
Variable_name: performance_schema_max_cond_classes
        Value: 100
*************************** 5. row ***************************
Variable_name: performance_schema_max_cond_instances
        Value: -1
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;　　当我们拥有mysql的root权限的时候我们可以直接运行命令&lt;code&gt;set global max_connections = xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;　　当我们没有mysql的root权限时我们可以通过重启数据库来解决。还有一种是直接在命令端更改（参见：&lt;a href=&quot;https://www.percona.com/blog/2010/03/23/too-many-connections-no-problem/&quot;&gt;外国连接&lt;/a&gt;），外国人给了一个语句&lt;code&gt;gdb -p  $(cat mysqld.pid) -ex &quot;set max_connections=xxx&quot; -batch&lt;/code&gt;来操作，这个骚气的操作我暂时没看太懂，gdb怎么就能够操作这个呢？&lt;/p&gt;

&lt;h3 id=&quot;自己测试&quot;&gt;自己测试&lt;/h3&gt;
&lt;p&gt;　　知道了问题产生的原理了，那么我就自己模拟了一下，看看我能不能复现出这类问题&lt;/p&gt;

&lt;p&gt;　　首先，就是需要创建出是2个账号，然后再把max_connections设置为1.这样，当A用户连接上后，B去连接就连接不上了，然而我的root却能够登录。如果能够达到这样的效果，就说明了我复现成功了。&lt;/p&gt;

&lt;p&gt;　　值得注意的是mysql自升到了8.0以后，创建用户后需要紧跟着为用户分配权限。如果不这么做，你是之后再分配权限的话，就会得到&lt;code&gt;You are not allowed to create a user with GRANT&lt;/code&gt;的错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create user `A`@localhost identified by 'testA';
mysql&amp;gt; grant select on laravel562.* to `test3`@`localhost`; //创建用户后直接分配读权限

Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我一共创建了两个用户分别是testA和testB。当我登录testA的时候，我通过root登录后运行```show processlist``后发现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*************************** 1. row ***************************
                 host: locahost
                 user: testA
authentication_string: *94BDCEBE19083CE2A1F959FD02F964C7AF4CFC29
               plugin: mysql_native_password
*************************** 2. row ***************************
                 host: localhost
                 user: mysql.infoschema
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 3. row ***************************
                 host: localhost
                 user: mysql.session
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 4. row ***************************
                 host: localhost
                 user: mysql.sys
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 5. row ***************************
                 host: localhost
                 user: root
authentication_string: *332A08EE56001FE5139E2FB111080AA441242991
               plugin: mysql_native_password

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以发现结果中可以看到testA和root两个用户的连接情况。当我这个时候让testB连接的话，testB就会报too many connections的错误了。 我再让testA关闭掉，再连testB就可以了。&lt;/p&gt;

&lt;p&gt;　　之后，我删除了testA和testB，应用&lt;code&gt;drop user `test`@`localhost`;&lt;/code&gt;。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html">　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。</summary></entry><entry><title type="html">《创造力-跳出盒子思考》</title><link href="http://localhost:4000/books/2019/05/24/01.html" rel="alternate" type="text/html" title="《创造力-跳出盒子思考》" /><published>2019-05-24T00:00:00+08:00</published><updated>2019-05-24T00:00:00+08:00</updated><id>http://localhost:4000/books/2019/05/24/01</id><content type="html" xml:base="http://localhost:4000/books/2019/05/24/01.html">&lt;p&gt;1.请跳出盒子思考&lt;/p&gt;

&lt;p&gt;　　答案很简单，是不是？解这道题的关键在于，在正方形范围以外画线。你解不出这道题的原因在于，被正方形框住了。哈哈！&lt;/p&gt;

&lt;p&gt;　　其实，在我们的脑子里，类似的框框很多。这些框框，有的来自于我们的思维定势，有的来自于认知偏差，有的是因为经历、见识、眼光等方面的局限。&lt;/p&gt;

&lt;p&gt;　　所以，我们一定要抱着开放的心态，去看待万事万物。对于你不习惯的新鲜事物，不要轻易地否定，可以抱着“一切有待验证”的态度，去了解它，探寻它；对于没有经历和没有见过的事情，不要忙着下结论，以防出现“黑天鹅事件”。&lt;/p&gt;

&lt;p&gt;2.运用发散性思维&lt;/p&gt;

&lt;p&gt;　　发散性思维，就是遇到问题的时候，能从多角度、多侧面、多层次、多结构去思考，去寻找答案。就像下图中所说的那样：想想左边，又想想右边，想想低处，再想想高处。只要你尝试，你就会有许多奇思妙想！&lt;/p&gt;

&lt;p&gt;　　有两种方法可以很好地锻炼你的发散性思维：&lt;/p&gt;

&lt;p&gt;　　一是利用思维导图。当你思考某一个问题的时候，就在纸的中心画个圆圈，写下你思考的问题，然后向外画开，把各种可能的点子和方案都写下来。&lt;/p&gt;

&lt;p&gt;　　二是运用联想。比如说看到一个圆，你能想到什么？是数字0，字母O，还是排球、网球、乒乓球，或者是地球、月亮、太阳……放开你的思维，像儿童一样，自由地想象吧。&lt;/p&gt;

&lt;p&gt;3.勇敢突破舒适区&lt;/p&gt;

&lt;p&gt;　　心理学表明，人们天生喜欢稳定，喜欢呆在舒适区，不愿意冒风险。&lt;/p&gt;

&lt;p&gt;　　而创新则意味着变化，意味着不确定性，意味着冒风险，这与人与生俱来的惰性相违背。&lt;/p&gt;

&lt;p&gt;　　所以，必要的时候，你需要自己推自己一把，勇敢跳出舒适区，接受新的环境和挑战。&lt;/p&gt;

&lt;p&gt;　　比如，尝试学习一项新的技能，研究一个完全陌生的领域，学会与背景、教育、观点各不相同的人相处，敢于接受别人的质疑和挑战，等等。&lt;/p&gt;

&lt;p&gt;　　当你经常接触新鲜事物，你的头脑会更加灵光，你的思维会更加活跃。&lt;/p&gt;

&lt;p&gt;4.保持专注&lt;/p&gt;

&lt;p&gt;　　注意力分散，是创造性思考的大敌。&lt;/p&gt;

&lt;p&gt;　　但如今我们生活在一个全天无休的互联网时代。&lt;/p&gt;

&lt;p&gt;　　每天，我们的注意力被各种新奇好玩的东西所吸引，我们的大脑被海量的信息所超载，这对发挥创造性思维很不利。&lt;/p&gt;

&lt;p&gt;　　所以，我们必须对海量的信息进行断舍离，只专注于所擅长和热爱的领域。冥想有助于提升专注力，你也可以尝试下。&lt;/p&gt;

&lt;p&gt;5.对旧元素进行重新组合&lt;/p&gt;

&lt;p&gt;　　大多数时候，创造力在于重新排列、延伸或者组合现有的事物，将其变为崭新的事物。&lt;/p&gt;

&lt;p&gt;　　当你创作一幅画时，你就是通过对现有的颜料、线条、材质进行重新组合，当你的组合与别人的组合方式不同时，你就是在创造新作品。&lt;/p&gt;

&lt;p&gt;　　写文章也一样，当你读了很多的书，把很多人的观点进行整合，然后加上自己的感悟，就形成了你自己独到的见解，你就创造了新作品。&lt;/p&gt;

&lt;p&gt;　　所谓大道至简，从哲学层面上，各个领域的东西都是相通的。&lt;/p&gt;

&lt;p&gt;　　你经历的事情越多，学到的知识越广，你的感悟就会越深，你就越容易做到跨界整合、融会贯通，这就是一种创造力。&lt;/p&gt;

&lt;p&gt;6.及时记录整理灵感、思考和发现&lt;/p&gt;

&lt;p&gt;　　灵感转瞬即逝，必须把它记录下来，因为“书面化的思考更便于利用”。而且，这种凭直觉而来的思想，比坐着主动推理得出的想法会更有创意。把思维活动的结果保存下来，是真正的智力节约。&lt;/p&gt;

&lt;p&gt;　　有时候，灵感只是一些思维的片断。但如果你能一点点积累，有一天，它就会成为一个绝妙的创意，或者一个独到的发现。&lt;/p&gt;

&lt;p&gt;　　许多时候，灵感是在你深入思考某一问题后的一种顿悟。&lt;/p&gt;

&lt;p&gt;　　比如，有些人说，写文章需要有灵感，灵感没有的时候，就不动笔。但很多时候，灵感是在你落笔的时候突然出现的。也就是说，灵感不是想出来的，而是写出来的。&lt;/p&gt;

&lt;p&gt;　　如果你想要开始写作，那就不要等待，赶快动手吧。如果你非要等待灵感出现才开始写，那可能你一个字都不会写。呵呵。&lt;/p&gt;

&lt;p&gt;7.管理好精力能量&lt;/p&gt;

&lt;p&gt;　　研究表明，创造力与能量水平直接相关。你的精力越充沛，创造力就越强，所以你要照顾好自己，注意饮食，睡眠充足，每天坚持锻炼。&lt;/p&gt;

&lt;p&gt;　　当你苦思冥想，都想不出新点子的时候，你应该好好地休息一下，让潜意识帮你工作。&lt;/p&gt;

&lt;p&gt;　　除了管理好体能精力，你还要管理好自己的情绪精力、意志精力，等等，下一篇将详细讲解这个问题。有兴趣的朋友，可持续关注。&lt;/p&gt;

&lt;p&gt;　　以上，是我读了吉姆·兰德尔所著的简单有趣的个人管理丛书之一《创造力——跳出盒子思考》以后的一些思考和总结，与您分享。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="books" /><category term="思维,书籍" /><summary type="html">吉姆·兰德尔(Jim Randel)，现年60岁，毕业于哥伦比亚大学法学院。他是一位企业家——购买和销售商业地产，同时拓展新业务。作为一名致力于投资和企业家精神领域的讲演者，兰德尔已经在全美许多场馆作过演讲.其中包括哈佛大学和纽约大学商学院。兰德尔学习和研究成功这一主题长达30年之久。除了阅读所有他能找到的有关这一主题的资料以外，他还不厌其烦地向成功人士请_教_.了解他们的成功之道(直到他们找理由回绝)。因此，这本书的结论是多年研究、个人试验和向他人学习的结果。兰德尔得出的结论是：成功的秘密就是欲望、努力、钻研、决心和坚持…而这些都需要毅力和自律能力。兰德尔相信，如果你愿意付出代价，一切都是可能的。</summary></entry><entry><title type="html">redis外网访问相关设置</title><link href="http://localhost:4000/tech/2019/03/12/01.html" rel="alternate" type="text/html" title="redis外网访问相关设置" /><published>2019-03-12T00:00:00+08:00</published><updated>2019-03-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/12/01.html">&lt;p&gt;1 . 我的redis服务用的redis配置文件在哪里？&lt;/p&gt;

&lt;p&gt;答：我用的是centos系统，我知道redis是通过yum安装的，那么我需要通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# rpm -qa | grep redis
redis-3.2.12-2.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这样，我就知道了我装的redis版本，进而我能够知道redis用的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# rpm -ql redis-3.2.12-2.el7.x86_64
/etc/logrotate.d/redis
/etc/redis-sentinel.conf
/etc/redis.conf     （*）
/etc/systemd/system/redis-sentinel.service.d
/etc/systemd/system/redis-sentinel.service.d/limit.conf
/etc/systemd/system/redis.service.d
/etc/systemd/system/redis.service.d/limit.conf
/usr/bin/redis-benchmark
/usr/bin/redis-check-aof
/usr/bin/redis-check-rdb
/usr/bin/redis-cli
/usr/bin/redis-sentinel
/usr/bin/redis-server
/usr/lib/systemd/system/redis-sentinel.service
/usr/lib/systemd/system/redis.service
/usr/libexec/redis-shutdown
/usr/share/doc/redis-3.2.12
/usr/share/doc/redis-3.2.12/00-RELEASENOTES
/usr/share/doc/redis-3.2.12/BUGS
/usr/share/doc/redis-3.2.12/CONTRIBUTING
/usr/share/doc/redis-3.2.12/MANIFESTO
/usr/share/doc/redis-3.2.12/README.md
/usr/share/licenses/redis-3.2.12
/usr/share/licenses/redis-3.2.12/COPYING
/usr/share/man/man1/redis-benchmark.1.gz
/usr/share/man/man1/redis-check-aof.1.gz
/usr/share/man/man1/redis-check-rdb.1.gz
/usr/share/man/man1/redis-cli.1.gz
/usr/share/man/man1/redis-sentinel.1.gz
/usr/share/man/man1/redis-server.1.gz
/usr/share/man/man5/redis-sentinel.conf.5.gz
/usr/share/man/man5/redis.conf.5.gz
/var/lib/redis
/var/log/redis
/var/run/redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2 . 如何更改该redis配置，可以打开外网访问？还要更改下密码以保证安全性。&lt;/p&gt;

&lt;p&gt;答：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;注释掉bind 127.0.0.1，从而让redis不光监听本机的请求。&lt;/li&gt;
  &lt;li&gt;protected-mode no，默认是打开的，想要从别的host连接古来，就需要关闭。&lt;/li&gt;
  &lt;li&gt;requirepass 密码，设置密码。&lt;/li&gt;
  &lt;li&gt;重启redis服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3 . 重启redis服务，我如何让redis以守护进程方式启动呢？&lt;/p&gt;

&lt;p&gt;答：centos 7开始，使用systemd代替daemon了，所以管理系统服务的命令全部由systemctl命令代替。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl start redis //如果遇到问题就用systemctl status来查看问题原因
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4 . 防火墙还会挡住外网访问6379端口，怎么办？&lt;/p&gt;

&lt;p&gt;答：这个跟iptable的规则有关了，运维工程师们总是跟iptable打交道，我们只需要知道怎么用即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@iZ2ze33uzthv7txm85m303Z ~]# iptables -nvL   //查看目前服务的端口
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
7704K 1142M ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
12905  687K ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           
12984  779K ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           
   14   896 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:6379
 439K   25M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
5655K  271M ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:80
54310 2782K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:8080
6545K  323M REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 764K  624M DOCKER-ISOLATION  all  --  *      *       0.0.0.0/0            0.0.0.0/0           
 400K  597M DOCKER     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0           
 399K  597M ACCEPT     all  --  *      docker0  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
 364K   27M ACCEPT     all  --  docker0 !docker0  0.0.0.0/0            0.0.0.0/0           
    0     0 ACCEPT     all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0           
    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited

Chain OUTPUT (policy ACCEPT 4127 packets, 1019K bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain DOCKER (1 references)
 pkts bytes target     prot opt in     out     source               destination         
   42  4713 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.18.0.2           tcp dpt:80
   16  2316 ACCEPT     tcp  --  !docker0 docker0  0.0.0.0/0            172.18.0.4           tcp dpt:8080

Chain DOCKER-ISOLATION (1 references)
 pkts bytes target     prot opt in     out     source               destination         
 764K  624M RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　目前，我已经放开了服务器的6379端口外网访问，所以结果中会有6379条目。正常来说，新配环境的时候，6379是没有的，所以我们需要添加上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　之后，还需要保存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; service iptables save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后我们再通过查看语句就能看到6379了。至此我们配置完成了redis的外网访问及权限安全了。&lt;/p&gt;

&lt;p&gt;　　我准备再写一个实现主从redis配置的文章，改天研究研究。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,centos" /><summary type="html">1 . 我的redis服务用的redis配置文件在哪里？</summary></entry><entry><title type="html">git的rebase可以实现合并commit</title><link href="http://localhost:4000/tech/2019/03/08/01.html" rel="alternate" type="text/html" title="git的rebase可以实现合并commit" /><published>2019-03-08T00:00:00+08:00</published><updated>2019-03-08T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/08/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/08/01.html">&lt;p&gt;　　玩了那么多年的git了，现如今你只会add,commit,push,pull,merge，你都不好意思说你会git。chrrey-pick , filter branch, rebase等操作你还是需要盘一下的。&lt;/p&gt;

&lt;p&gt;　　git rebase是干什么的呢？学者们把他成为变基。说是把很多的commit合并到一个commit中。之前，我想不明白除了把commit合并为一个以外还有什么地方会用到。几天，我确实碰到了一个现实中的问题。这个问题是出自我的博客的，我的docs由于很多次提交了，每次要合到master上都得来一次filter branch。这个操作刚开始会很快，但是随着博客内容的增多，每次去合master的时候都得走一次从头到尾的遍历，实属受不了。（读者可能并不明白我再说什么，你们也不用想明白。）&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy&quot; data-original=&quot;https://s2.ax1x.com/2019/03/09/ASZxpD.gif&quot; src=&quot;/images/default.jpg&quot; alt=&quot;一顿操作&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以从图中看到，我首先创建了一个test文件。我们将第一行写入并置为第一次提交。之后再插入第二行作为第二行提交。现在，我想把第二次提交和第一次提交合并。这样，就不会有人再知道我曾经有过第二次提交了。这个操作就是rebase&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们用上面的命令，就可以将最近的两次提交合并到最早的提交。之后会出现一个界面。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy&quot; data-original=&quot;https://s2.ax1x.com/2019/03/09/ASB856.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;rebase的todo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这个界面前两行列出了rebase所包含的commit。剩下的就是此操作的介绍。我们只需要关心pick和squash两个关键字。通过英文我们了解到，图中的意义是将第二次操作合并至第一次操作，这样在log里面只会显示一次log，然而确实是两次更改。退出即可。如果，rebase发现没有版本冲突就会直接完成rebase操作。如果有冲突，我们就像一般解决冲突一样去纠正就好，然后git add即可，不用commit，然后运行 git rebase –continue即可。 有的时候，你并不太操心rebase发生的冲突，我们可以运行git rebase –skip跳过冲突。&lt;/p&gt;

&lt;p&gt;　　最后，我们还要考虑push到远端的操作。因为当前本地的版本和远端的版本不一样且不是继承版本状态。所以，系统会提示你先git pull，然后再git push。 当心，系统是好心，但如果你真像系统要求你一样去做了，那么你rebase的这些操作都会随着git pull更改为远端的版本。所以，我们在这里需要git push -f，也就是强制推送到远端不进行版本的对比。这个操作其实在多人合作的时候会产生很多副作用，让你瞬间就扮演上了小队破坏者的身份。因此，很多开发者都不建议在多人项目中用rebase这个命令，除非你和你的小队已经充分沟通过此事，而且大家也互相明白做此事的重要性，而且大家还不是新兵蛋蛋。&lt;/p&gt;

&lt;p&gt;　　好了，我就记录到这里吧。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="git" /><summary type="html">　　玩了那么多年的git了，现如今你只会add,commit,push,pull,merge，你都不好意思说你会git。chrrey-pick , filter branch, rebase等操作你还是需要盘一下的。</summary></entry><entry><title type="html">学习用GO写了个聊天室</title><link href="http://localhost:4000/tech/2019/03/07/01.html" rel="alternate" type="text/html" title="学习用GO写了个聊天室" /><published>2019-03-07T00:00:00+08:00</published><updated>2019-03-07T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/07/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/07/01.html">&lt;p&gt;　　最近在看GO语言，跟着教程一步一步手敲代码，拼出了个聊天室程序。其中涉及到了go语言中的go,defer,make,chan,select。了解了go中的变量类型以及部分的类型操作。同时，go语言的语言结构和逻辑控制也有了大概的初步认识。而且，也用到了go特有的语言性质。&lt;/p&gt;

&lt;p&gt;　　断断续续那么长时间学习go了，今天才第一次写出个像样的程序。总是感觉程序大都一个样，真正上手才是王道。&lt;/p&gt;

&lt;p&gt;　　创建一个聊天室服务端,chatroom_client.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;strings&quot;
)
//创建基于链接的哈希map，方便知道链接对应的端口号
var onlineConns = make(map[string]net.Conn) 
//创建一个频道，长度1000.用来存储信息
var messageQueue = make(chan string, 1000)
//创建一个返回布尔值的频道，用来应对没有信息的情况
var quitChan = make(chan bool)
//检查错误，通用方法
func CheckError(err error) {
	if err != nil {
		panic(err)
	}
}
//将消息存进频道中
func ProcessInfo(conn net.Conn){
	buf := make([]byte , 1024) 创建个1024字节的字节流
	defer conn.Close() //程序运行完毕时关闭链接
    //循环体
	for{
	   //从信息流读出消息
		numOfBytes,err:= conn.Read(buf) 
		if err != nil{
			panic(err)
		}
     //如果字节不等于零，就把消息字符化发到消息频道中
	   if numOfBytes != 0{
			message := string(buf[0:numOfBytes])
			messageQueue &amp;lt;- message
		}
	}
}
//消费消息
func ConsumeMessage(){
	for{
	   //select是配合频道使用的，选择进哪个通信操作
		select{
			case message:=&amp;lt;-messageQueue:
				//对消息进行解析
				doProcessMessage(message)
			case &amp;lt;- quitChan:
			   //空消息，什么都不做~
				break
			}
	}
}
//对消息进行解析
func doProcessMessage(message string){
    //将消息以“#”分开，如 127.0.0.1:3389#你好
    //就把这个消息分成两段，一段为127.0.0.1:3389，一段为你好
    //这里面没有考虑消息体里面包括#好的情况
	contents := strings.Split(message,&quot;#&quot;)
	if len(contents) &amp;gt;1 {
		addr := contents[0]
		sendMessage := contents[1]
     //将消息体格式化
		addr =strings.Trim(addr, &quot; &quot;)
		//判断哈希map中这个地址存不存在，存在就往这个链接里写消息体
		if conn,ok := onlineConns[addr]; ok{
			_,err := conn.Write([]byte(sendMessage))
			if err != nil{
			  //不存在就写发送失败
				fmt.Println(&quot;online conns send failure!!!!&quot;)
			}
		}
	}
}
//主函数
func main(){
  //监听127.0.0.1:8080端口。
	listen_socket , err := net.Listen(&quot;tcp&quot;,&quot;127.0.0.1:8080&quot;)
	CheckError(err)
	//程序退出后监听关闭
	defer listen_socket.Close()
   //增加用户体验，让用户知道程序在运行中
	fmt.Println(&quot;server is waitting...&quot;)
  //开启协程来消费消息
	go ConsumeMessage()
  //无限循环，来监听消息并处理消息
	for{
		conn,err := listen_socket.Accept()
		CheckError(err)
     //打印出连接过来的远端地址
		addr := fmt.Sprintf(&quot;%s&quot;, conn.RemoteAddr())
		//将这个连接并存储到hashmap
		onlineConns[addr] = conn
     //循环hashmap，打印连接上来的连接
		for i := range onlineConns{
			fmt.Println(i)
		}
		//运行协程，将连接存到频道中。程序不停，此过程不断
		go ProcessInfo(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　再创建一个客户端文件,chatroom_client.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func CheckError(err error) {
	if err != nil {
		panic(err)
	}
}
//发送消息
func MessageSend(conn net.Conn) {
	var input string
	//无限循环，发送消息
	for {
	   //监听输入将键入的信息记下来
		reader := bufio.NewReader(os.Stdin)
		//将记下来的消息以每行开始读
		data, _, _ := reader.ReadLine()
		//将data字符化存入到input
		input = string(data)
     //如果input为exit就退出，结束连接
		if strings.ToUpper(input) == &quot;EXIT&quot; {
			conn.Close()
			break
		} else {
		  //否则，往这个连接中写入字节流
			_, err := conn.Write([]byte (input))
			if err != nil {
				conn.Close()
				fmt.Println(&quot;client connect failure&quot; + err.Error())
			}
		}
	}
}

func main() {
  //连接8080端口
	conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8080&quot;)
	CheckError(err)
	defer conn.Close()
   //开启协程发送消息，无限循环的
	go MessageSend(conn)
	//创建1024长度的字节流
	buf := make([]byte, 1024)
	//无限循环，读取字节流信息并打印
	for {
		_, err := conn.Read(buf)
		CheckError(err)
		fmt.Println(&quot;server receive message content: &quot; + string(buf))
	}

	fmt.Println(&quot;client program done&quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　以上程序可以运行起来了。先go run chatroom_server.go。之后再起两个client。server中能看到连接上来的两个ip:port。在client中输入ip:port#文字。就可以在对应的client看到发送过来的信息了。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="go,聊天室" /><summary type="html">　　最近在看GO语言，跟着教程一步一步手敲代码，拼出了个聊天室程序。其中涉及到了go语言中的go,defer,make,chan,select。了解了go中的变量类型以及部分的类型操作。同时，go语言的语言结构和逻辑控制也有了大概的初步认识。而且，也用到了go特有的语言性质。</summary></entry><entry><title type="html">不支持caching_sha2_password的MYSQL8应如何连接</title><link href="http://localhost:4000/tech/2019/03/01/01.html" rel="alternate" type="text/html" title="不支持caching_sha2_password的MYSQL8应如何连接" /><published>2019-03-01T00:00:00+08:00</published><updated>2019-03-01T00:00:00+08:00</updated><id>http://localhost:4000/tech/2019/03/01/01</id><content type="html" xml:base="http://localhost:4000/tech/2019/03/01/01.html">&lt;p&gt;　　真的好长时间没有在这个博客写东西了。自从17年底到18年下旬自己发生了天翻地覆的变化，所以没有太多时间也没有太多心情来写东西。虽然，目前的状况也还不太稳定。但是，心情变得好多了。所以，我想过来写一写东西了。&lt;/p&gt;

&lt;p&gt;　　这次想写的东西还挺多，一是顺便把之前的事情都按照时间点归总一下然后写个回忆录啥的。二是接着把我这段时间学过的东西、用过的东西、见过的东西写一写。这次写的东西就是我昨天重起php5.6时，遇到的早已见过的mysql8把plugin从“mysql_native_password”换成后“caching_sha2_password”服务连接不上的问题。其实，网上很多文章已经写了这个问题了，我也是在2018年4月份第一批遇到此问题的那批用户，那么我为啥要写这篇文章呢？因为，我想把我一边遇到问题一边解决问题的过程和为什么这么做的原因描述一下。我觉得这应该会更加有意义吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.caching_sha2_password和mysql_native_password是什么&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这两个是MYSQL的加密插件的规则，也可以说是加密算法。mysql8之前的mysql5都用的是native，后来才改成了sha2。安全方面的考虑吧。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.在哪里我可以看到这个值呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;登录mysql&lt;/li&gt;
  &lt;li&gt;use mysql;&lt;/li&gt;
  &lt;li&gt;select * from user \G;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　这里面包含的就是系统记录的登录用户，如果你一般用的是账户为root的用户，那么你就会发现User一列会有个root的记录。其后还会包括plugin，这个就是你在用的加密算法。之后的authentication_string就是你的密码被算法加密后的密文了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;            Host: localhost
                User: root             (*)
           Select_priv: Y
           Insert_priv: Y
           Update_priv: Y
           Delete_priv: Y
           Create_priv: Y
             Drop_priv: Y
           Reload_priv: Y
         Shutdown_priv: Y
          Process_priv: Y
             File_priv: Y
            Grant_priv: Y
       References_priv: Y
            Index_priv: Y
            Alter_priv: Y
          Show_db_priv: Y
            Super_priv: Y
 Create_tmp_table_priv: Y
      Lock_tables_priv: Y
          Execute_priv: Y
       Repl_slave_priv: Y
      Repl_client_priv: Y
      Create_view_priv: Y
        Show_view_priv: Y
   Create_routine_priv: Y
    Alter_routine_priv: Y
      Create_user_priv: Y
            Event_priv: Y
          Trigger_priv: Y
Create_tablespace_priv: Y
              ssl_type:
            ssl_cipher:
           x509_issuer:
          x509_subject:
         max_questions: 0
           max_updates: 0
       max_connections: 0
  max_user_connections: 0
                plugin: mysql_native_password             (*)
 authentication_string: *332A08JD6001FESDFDSLI11083DS41242991       (*)
      password_expired: N
 password_last_changed: 2019-02-28 19:43:03
     password_lifetime: 0
        account_locked: N
      Create_role_priv: Y
        Drop_role_priv: Y
Password_reuse_history: NULL
   Password_reuse_time: NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.比如你在用PHP连接MYSQL时会报“requested authentication method unknown to the client [caching_sha2_password]”的错误，我们如何解决呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　首先，我们要明确一下问题。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;正如上面列的mysql数据，你数据中plugin是什么？authentication_string加密前的密码是正确的么？如果你不确定密码的话你最好重置一下密码，如果不需要就跳到问题【5】&lt;/li&gt;
  &lt;li&gt;你的My.cnf（*unix）中的配置应该怎么配?&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;4.如何重置mysql密码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;关闭mysql服务。&lt;/li&gt;
  &lt;li&gt;找到mysql的安装位置，并进入bin文件夹，会发现mysqld运行文件&lt;/li&gt;
  &lt;li&gt;运行 mysqld –skip-grant-tables #跳过登录检验环节直接启动mysql&lt;/li&gt;
  &lt;li&gt;use mysql;&lt;/li&gt;
  &lt;li&gt;ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘你的密码’ PASSWORD EXPIRE NEVER; #修改密码规则&lt;/li&gt;
  &lt;li&gt;ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’; #更新用户密码&lt;/li&gt;
  &lt;li&gt;flush privileges; #刷新权限，必须做&lt;/li&gt;
  &lt;li&gt;重启你的机器，建议你做这一步&lt;/li&gt;
  &lt;li&gt;开启mysql服务&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;5.My.cnf的配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　下面的配置是我的配置，标（*）的地方就是要将密码规则插件改mysql_native_password。（*）要在[mysqld]下面。因为在用php连接服务的时候会走这个配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;# For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html
# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the
# *** default location during install, and will be replaced if you
# *** upgrade to a newer version of MySQL.
[mysqld]
default_authentication_plugin=mysql_native_password (*)
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin =~/logs/mysql/mysql-bin
# These are commonly set, remove the # and set as required.
# basedir = /usr/local/var/mysql/
 datadir = /usr/local/var/mysql
 port = 3306
# server_id = .....
 socket = /usr/local/var/run/mysql.sock
# Remove leading # to set options mainly useful for reporting servers.
# The server defaults are faster for transactions and fast SELECTs.
# Adjust sizes as needed, experiment to find the optimal values.
# join_buffer_size = 128M
# sort_buffer_size = 2M
# read_rnd_buffer_size = 2M
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
[client]
socket = /usr/local/var/run/mysql.sock
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;更改密码规则及密码&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;登录mysql&lt;/li&gt;
  &lt;li&gt;use mysql;&lt;/li&gt;
  &lt;li&gt;ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘你的密码’ PASSWORD EXPIRE NEVER; #修改密码规则&lt;/li&gt;
  &lt;li&gt;ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’; #更新用户密码&lt;/li&gt;
  &lt;li&gt;flush privileges; #刷新权限，必须做&lt;/li&gt;
  &lt;li&gt;重启Mysql服务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　自此，sha2的连接问题可以告一段落了。我有时间把我18年4月份折腾mysql8的数据库文件的经验发出来吧。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html">　　真的好长时间没有在这个博客写东西了。自从17年底到18年下旬自己发生了天翻地覆的变化，所以没有太多时间也没有太多心情来写东西。虽然，目前的状况也还不太稳定。但是，心情变得好多了。所以，我想过来写一写东西了。</summary></entry><entry><title type="html">多git账号共存</title><link href="http://localhost:4000/tech/2018/09/01/01.html" rel="alternate" type="text/html" title="多git账号共存" /><published>2018-09-01T00:00:00+08:00</published><updated>2018-09-01T00:00:00+08:00</updated><id>http://localhost:4000/tech/2018/09/01/01</id><content type="html" xml:base="http://localhost:4000/tech/2018/09/01/01.html">&lt;blockquote&gt;
  &lt;p&gt;Are you serious about network security? Then check out SSH, the Secure Shell, which provides key-based authentication and transparent encryption for your network connections&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在我们的工作中，版本控制工具通常会用git工具。当你公司用git的时候你肯定不想用你github的账号进行推送。反过来也一样。那我就说一下如何配置才能将不同git域分开来。&lt;/p&gt;

&lt;p&gt;首先，我默认读者具备SSH keys的知识。&lt;/p&gt;

&lt;p&gt;在~/.ssh文件夹内有个config文件。这个文件就是用来实现多git账号共存的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; Host github@github.com   //是git服务的主机
 HostName github.com    //git的域名
 User naffan2014    //登录名，是你这个网站的用户ID
 IdentityFile ~/.ssh/id_rsa_github //ssh keys存储的文件位置

 Host git@sina.com
 HostName sina.com
 User naffan@sina.com
 IdentityFile ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们还需要将这个配置加载到ssh-agent。用ssh-add命令。但是，这个命令只是暂时将sshkey添加到ssh agent当中。 重启电脑以后就会失效。所以我们需要添加-K 参数。让他添加到mac的keychain中。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="ssh,Github" /><summary type="html">Are you serious about network security? Then check out SSH, the Secure Shell, which provides key-based authentication and transparent encryption for your network connections</summary></entry><entry><title type="html">贝壳-是个有情怀的公司</title><link href="http://localhost:4000/life/2018/08/14/01.html" rel="alternate" type="text/html" title="贝壳-是个有情怀的公司" /><published>2018-08-14T00:00:00+08:00</published><updated>2018-08-14T00:00:00+08:00</updated><id>http://localhost:4000/life/2018/08/14/01</id><content type="html" xml:base="http://localhost:4000/life/2018/08/14/01.html">&lt;p&gt;　　　　今天，带着愉快的心情我入职了贝壳公司。我对中国的房地产行业有着很大的兴趣，也希望自己的工作和房地产保持长久的关系。贝壳给了我机会，我入职到了贝壳楼盘字典部门，作为一名phpRD开始了我的贝壳生涯。谁知道，在这家公司我后来经历了转型GO语言，转型JAVA语言的美好奇遇呢。&lt;/p&gt;

&lt;p&gt;　　　　贝壳坚持的是做难而正确的事情。客户至上，诚实可信，合作共赢，拼搏进取。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="charset" /><summary type="html">　　　　今天，带着愉快的心情我入职了贝壳公司。我对中国的房地产行业有着很大的兴趣，也希望自己的工作和房地产保持长久的关系。贝壳给了我机会，我入职到了贝壳楼盘字典部门，作为一名phpRD开始了我的贝壳生涯。谁知道，在这家公司我后来经历了转型GO语言，转型JAVA语言的美好奇遇呢。</summary></entry><entry><title type="html">《超级快速阅读》</title><link href="http://localhost:4000/books/2018/01/05/01.html" rel="alternate" type="text/html" title="《超级快速阅读》" /><published>2018-01-05T00:00:00+08:00</published><updated>2018-01-05T00:00:00+08:00</updated><id>http://localhost:4000/books/2018/01/05/01</id><content type="html" xml:base="http://localhost:4000/books/2018/01/05/01.html">&lt;p&gt;这本书是我在2017年10月中旬读完的，读这本书的起因是因为我总觉得自己读书的效率太低下了。我曾经听到我的舅妈说她和她女儿，也就是我的妹妹一起看小说时，我舅妈刚看到一页的中间位置时妹妹已经看完整页了，于是我舅妈就很诧异“你读那么快都记住了么？”，妹妹一听自然而然的就把这页讲到过的事情复述了一遍。这下一来，舅妈就被妹妹的读书速度所震惊到了。&lt;/p&gt;

&lt;p&gt;说者无意，听者有心。当时，我脑子里就在想妹妹为什么能够读书那么快呢？后来我自己有意地去试了下自己的读书速度，我能够明显感觉到自己读书的方式是在一行一行的看，速度不但慢，有时还会因为分心想别的事情，然而等回过神后，发现这段时间里面所读的内容通通没有印象，只能又重新读过。&lt;/p&gt;

&lt;p&gt;自打我在上初中的时候，学校就有专门安排过快速阅读这门课程。当时的我傻傻什么都不懂，根本不知道这门课程的重要性，每每上这课的时候。我总是遥看窗外的操场，心早就飞的不知踪影了。若干年后我家装修，突然从柜子里面翻出了当时这门课程的教材，还挺贵20块1本呢。于是，我就拿起这个教材来准备认真的学一学。但是，后来觉得这玩意太枯燥就早早放弃了。到了现在，我对阅读的渴望越变越大，一直惯用的读书技巧早已过时，而且有的时候我都觉得自己受制于这种习惯，所以这次我忽然在寻找图书的时候发现了这本书，于是就准备再好好的重新学一下这门课程。&lt;/p&gt;

&lt;p&gt;总的来说，本书所要传授的阅读方法用下面这张图就可以总的概括起来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://kupai-open.essintra.ejucloud.cn/14c9cb67-154c-479d-a838-cb36dc2c51f2.jpeg@imageMogr2/thumbnail/700x&quot; alt=&quot;学习流程示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视觉卡片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中最为重要的一环，就是作者多次强调的“制作视觉卡片”。这是因为作者研究了人脑如何能够快速的记忆事情。他得出的结果是认为人脑与生俱来的就对图很敏感。故把一些事情记录在不同的图片上，就会给读者留下更深的印象。同时，再加上关键词的辅助，就更能够让大脑理解这些东西了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大纲是了解全书的第一方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，要了解一本书的话。应该先将书中的大纲翻一翻，就像在拼图之前首先要看清包装上的完整图像。这就相当于在阅读的时候粗略了解一下整本书的大致内容。在阅读的过程中应该主动的去思考，由于人脑的左脑和右脑各自负责的功能是不一样的，只有让两个半脑分工配合起来，才会记东西越来越快。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左脑与右脑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;左脑负责的有逻辑，语言，数字，次序，因果，线性分析等。右脑负责的有节奏，幻想，白日梦，色彩，空间感，全貌等。对于一段要记忆的文字来说，我们通过反复阅读很难记住故事的内容，这是因为死记硬背的机械式方法不仅消耗了大量时间，还无法保证长期记忆。一个星期以后你完全有可能全部忘记。然而我们可以采用右脑思维顺利的解决这类问题。具体事例可以在书中寻找。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视线范围&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大多数人以为自己的实现移动轨迹是从左向右移动然后换行再从左向右移动，其实不然。真正的实现其实是在向后跳跃着，因为我们想要看清一个物体的时候，首先就要将实现停止下来，然后进行对焦，直到生成清晰的图像。这样就会产生三个问题：低效阅读、无法集中注意力及视线的下意识游移。作者首先就要带领我们改变这个习惯，作者建议我们用手指作为参照物，当手指平行移动的时候，实现要跟住手指的移动方向进行阅读。当阅读的速度提高起来的时候，就到了我们可以慢慢从一目几行，一目多行，乃至一目十行的时候了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;舒适区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要掌握新的阅读技巧，首先我们必须超越自己现有的阅读水平。这意味着我们必须勇敢迈出自己现有的舒适区。每次离开原有的舒适区，都是一次学习新知识的旅程。一分耕耘，一分收获，练得越勤，你的阅读能力进步的就越快。&lt;/p&gt;

&lt;p&gt;这本工具书在阅读能力上给我了很大帮助，我记得我按照这本书的要求做了阅读能力的测试，当时我的阅读速度是每分钟250个字。但是，利用书中教我的方法我可以让自己的速度一下子翻6倍。而且，我对读过的内容大致也都能记得下来。所以，我很推荐这本书。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="books" /><category term="工具,书籍" /><summary type="html">　　本书是《快速阅读》作者克里斯蒂安•格吕宁的成名之作。他在临近大学毕业准备德国司法考试期间，因为不能像其他同学一样有充足的时间复习备考，于是在参考众多学习方法类书籍的基础上独辟蹊径，创造出一套风靡全球的学习方法。</summary></entry></feed>