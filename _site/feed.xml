<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://naffan.cn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://naffan.cn/" rel="alternate" type="text/html" /><updated>2021-05-25T19:10:16+08:00</updated><id>https://naffan.cn/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">赛格广场晃动，原因竟然是共振</title><link href="https://naffan.cn/thinking/2021/05/22/01.html" rel="alternate" type="text/html" title="赛格广场晃动，原因竟然是共振" /><published>2021-05-22T00:00:00+08:00</published><updated>2021-05-22T00:00:00+08:00</updated><id>https://naffan.cn/thinking/2021/05/22/01</id><content type="html" xml:base="https://naffan.cn/thinking/2021/05/22/01.html">&lt;blockquote&gt;
  &lt;p&gt;赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0519%2F79a605c9j00qtcuwt00a4c0010400r4m.jpg&amp;amp;thumbnail=650x2147483647&amp;amp;quality=80&amp;amp;type=jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月18日，深圳市福田区华强北街道赛格大厦出现摇晃，大厦已经封闭，大厦内人员已全部撤出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月19日，大楼在下午一点半到两点之间出现过晃动。目前大厦原则上只能让商家等内部工作人员出入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月20日12时30分左右在35楼、55楼、60楼等多个楼层感受到晃动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2020年5月21日，深圳市赛格集团有限公司的通知显示自21日起暂停所有业主、商户、租户进出赛格大厦写字楼和电子市场，待相关检测工作完成后再有序开放，有关事宜另行通知。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　最近，赛格大厦晃动的事件在民间讨论的沸沸扬扬，一石激起千层浪，媒体的曝光更加让本来疑云密布的事件罩上了更多的阴谋论。其中一家媒体爆料说是20年前就有一篇&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1700150908927741800&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;《深圳赛格广场建设项目评析》&lt;/a&gt;的硕士论文中指出，大厦是边设计边施工。这位硕士学生是一名华中科技大学非建筑学科且并未参与过赛格广场建设的学生，她的名字叫金典琦。此文章一出各种小道每天就开始各种添油加醋，疯狂的不分青红皂白的就开始说赛格大厦是豆腐渣工程，是中国体系内的不负责任的典型。那么事情真的是这样么？我在网上翻到了当时这名学生的论文并且通读以后得出了结论：&lt;/p&gt;

&lt;p&gt;　　金典琦是学工商管理的在职硕士，全程参与了赛格大厦建设的管理工作。对赛格大厦建造过程中选取的技术和解决方案以及施工方的预算和组织架构有充足的了解和深入的分析。对于建设过程中遇到的问题和解决方案有自己独有的理解和路径分析，形成了自己理论体系内的底层逻辑，逻辑能够自洽，对当时的市场分析和市场判断有比较全面的认知和实践。论文中也给出了详细的问题列表和抓手，对待施工时施工单位采用的方案有给出追种方案的比较并得到了学界内权威人士的认可与支持。&lt;/p&gt;

&lt;p&gt;　　论文中两次提到赛格大厦晃动的经历，一次为大厦顶部的两根天线设计不合理并重新进行了调整；一次为95年因大厦耸入云间，由于云彩移动导致广场上的人们误以为大厦要倾倒的趣事。还有一次提到了共振问题导致晃动。一次边设计边建造的问题根源。&lt;/p&gt;

&lt;p&gt;　　综上所述，论文给出了客观且符合当事人认知的合理判断与真实建造情况。所以，对于这些媒体给出的偏颇结论我认定为是媒体的误导及看到这些文章后唯恐天下不乱的人们不经过自己调研后就轻易下结论的事实。&lt;/p&gt;

&lt;p&gt;　　接下来，让我们的目光集中在&lt;code&gt;共振&lt;/code&gt;这一物理名词上。首先让我们看看bilibili上科普博主用通俗的语言讲的共振的机制和影响吧。&lt;/p&gt;

&lt;div align=&quot;middle&quot;&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=714516015&amp;amp;bvid=BV1qX4y1V7cE&amp;amp;cid=308414800&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/2e7857ed9bfb4122aaf35d697dbbf8b3.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;三百多年前，荷兰科学家惠更斯（Christian Huygens）在房间里的墙上并排放置不同速率的摆钟。当他第二天再回来时，发现这几个摆钟的钟锤都以同速率同步摆动。最终根据这一现象惠更斯写出了《摆钟轮》（Horologium Oscillatorium），摆钟现象被后来许多人相继重复实验，实际上这就是今天说的共振。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/dfce68126e974af08a03e71a2b578caa.gif&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振动图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　让我们来看看数学上是如何解释共振机理的吧，出自《数学指南》，科学出版社出版：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic2.zhimg.com/v2-afd3f984658ef92358a21e3245278824_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-e531f3ecae8171692340dd76189c3fe9_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-062748cdc1ecca03d291bdcb76c6b5aa_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理3&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　通过上面的数学方程式，我们了解到。如果我们一直给弹簧施加一个周期性的力，当力的频率等于弹簧固有震频时，力的作用方向和振子运动方向一直保持一致。这就意味着，力对振子做的功永远为正，于是振子的能量越来越大，对物体内部结构的破坏就越来越大，最终会导致物体被摧毁。&lt;/p&gt;

&lt;p&gt;　　2021年特斯拉上架了ModelY，当发售两个月后车主就曝出了modelY低频共振的问题。据说，很多车主都遇到过这个问题，并且有些车主花钱去做了&lt;a href=&quot;https://club.autohome.com.cn/bbs/thread/870af073c080e909/94575641-1.html&quot;&gt;后备箱隔音&lt;/a&gt;，但仍于事无补。据业内人士分析，ModelY的低频噪音多来自尾部，或许是因为车辆行驶过程中的噪音通过底盘传至车身，由于后尾门存在空腔，且钢板较薄，很容易因为刚性不足而放大噪音，从而产生低频共振的现象。这个就是通过后备箱的声音传过来的声波和车主的耳膜一致造成了共振现象，当振幅越来越大时就会给车主的耳朵造成不可逆的创伤。&lt;/p&gt;

&lt;p&gt;　　在我弹吉他的时候，每次拿出来吉他都要进行调音测试，为了让每条弦能够弹出准确的声音。调音手段中有一个利用共振原理来进行调弦的方法。就是波动一条弦后，其他弦的空弦如果与这条弦的声调一致就会跟着颤抖起来。&lt;/p&gt;

&lt;p&gt;　　在航天航空中，宇航员升天时会与宇宙飞船产生共振。我们国家英雄杨利伟就曾说：“2003年10月15日上午9时整，火箭尾部发出巨大的轰鸣声，几百吨高能燃料开始燃烧，8台发动机同时喷出炽热的火焰，高温高速的气体，几秒钟就把发射台下的上千吨水化为蒸汽。火箭和飞船总重达到487吨，当推力让这个庞然大物升起时，大漠颤抖、天空轰鸣。火箭逐步地加速，我感到压力在渐渐增加。因为这种负荷我们训练时承受过，我的身体感受还挺好，觉得没啥问题。但就在火箭上升到三四十公里的高度时，火箭和飞船开始急剧抖动，产生了共振。这让我感到非常痛苦。人体对10赫兹以下的低频振动非常敏感，它会让人的内脏产生共振。而这时不单单是低频振动的问题，还是这个新的振动要叠加在大约6G的一个负荷上。这种叠加太可怕了，我们从来没有进行过这种训练。我担心的意外还是发生了。”&lt;/p&gt;

&lt;p&gt;　　在现实生活中，我们周边还会有许许多多的共振现象。要解决共振其实很简单，只要找到物体共振频率，在此频率上减小激励力就能够避免共振了。对于高楼大厦来说，一般都是用类似阻尼器的装置来减小共振。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="共振" /><summary type="html">赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。</summary></entry><entry><title type="html">敬给我最尊重的老板，贝壳董事长-左晖</title><link href="https://naffan.cn/life/2021/05/20/01.html" rel="alternate" type="text/html" title="敬给我最尊重的老板，贝壳董事长-左晖" /><published>2021-05-20T00:00:00+08:00</published><updated>2021-05-20T00:00:00+08:00</updated><id>https://naffan.cn/life/2021/05/20/01</id><content type="html" xml:base="https://naffan.cn/life/2021/05/20/01.html">&lt;blockquote&gt;
  &lt;p&gt;我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic3.zhimg.com/80/v2-929a9e08b764aafea5ab50701fc66f82_720w.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;左晖&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面是我们公司的老板说的话，他的精神永远激励着我们，我们将矢志不渝的坚持长期主义，团结一心为新居住产业发展做难而正确的事！&lt;/p&gt;

&lt;p&gt;　　我很早就把我的行业固定在了中国的房地产行业之中，我又是从事互联网的技术人员。所以很自然的就干上了产业互联网之事。而我选择链家就是因为我在见证了链家这20年来的发展，坚定了链家作为中国（将来）最好的企业之一的信念以及我对中国房地产相关产业的看好。&lt;/p&gt;

&lt;p&gt;　　我是18年8月入职贝壳的，其实在四月份我就来链家面过试。那个时候福道大厦还不是贝壳的logo呢。我对链家是有一种执着的信念的，我愿意追随这样一位好领导，干有意义且难但正确的事情。入职贝壳以来，我专心落地到了为左晖先生提的”做有尊严的服务者“这句话的意义上奉献，长达3年的贝壳工作，我一直服务于链家的经纪人产品。&lt;/p&gt;

&lt;p&gt;　　经过这几年的工作，从入职php，到改为写go，再到现在的java。感觉这几年对语言的转型让我对语言已经有深刻的理解了。目前我正在做自己负责的业务，并且一直致力于学习。在2020年10月，和21年4月，我得到了部门给我的晋升机会。虽然通过自己的努力，最终没有晋级成功。但是，两次折磨的过程让我重新认识到了我目前缺乏的东西，第一次是技术，但是在第二次评委已经不说我技术问题了，而是产品高度。在接下来的工作和生活中，我将以提高我的这个能力为前提努力的认真工作。左晖先生的精神，会激励着我，一直向前。&lt;/p&gt;

&lt;p&gt;　　今天下午3点，在得知左晖先生离开后，我心情难以平复，本来未来可期，本来还有一番事业等待着他带领我们一起航行，可是就这样戛然而止，希望左晖先生一路走好，后面还有大S帮您完成您的愿望，我们会一起努力!&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="链家,癌症" /><summary type="html">我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。</summary></entry><entry><title type="html">redis连接池源码分析</title><link href="https://naffan.cn/tech/2021/05/15/01.html" rel="alternate" type="text/html" title="redis连接池源码分析" /><published>2021-05-15T00:00:00+08:00</published><updated>2021-05-15T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/15/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/15/01.html">&lt;p&gt;　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。&lt;/p&gt;

&lt;p&gt;　　你在开发时，可以通过jedis连接redis。jedis支持直连模式和连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直连模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; public static void main(String[] arg){
        //1个实例
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379,100);
        jedis.incr(&quot;threadSafe&quot;);
        jedis.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/089f91fe840610d38104189b092092042801300138f312.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;直连&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　你不应该将一个redis实例共享给不同线程，时用时消的用法会造成产生很多的socket和tcp连接，即浪费时间又耗费资源，也提高了服务不可用的风险。如果你只是在本机环境或者使用者相对少的环境中使用，这种模式比较适宜。但是，如果你需要大量使用redis时，应该采用连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接池模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] arg){
        JedisPool pool = new JedisPool(new JedisPoolConfig(),&quot;localhost&quot;);
        try (Jedis jedis = pool.getResource()) {
            jedis.set(&quot;foo&quot;, &quot;bar&quot;);
            String foobar = jedis.get(&quot;foo&quot;);
            jedis.zadd(&quot;sose&quot;, 0, &quot;car&quot;); jedis.zadd(&quot;sose&quot;, 0, &quot;bike&quot;); 
            Set&amp;lt;String&amp;gt; sose = jedis.zrange(&quot;sose&quot;, 0, -1);
        }
        pool.close();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08af91fe84061087a50a189b09208b052801300138b9f703.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;连接池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　为了避免由单一redis实例引发的未知的服务不可用的风险，我们应该采用这种方案。这种方案背后的原理就是连接池（common-pool2）。当服务到达时服务会从连接池中borrow一个jedis连接，当用完或者发生错误时，连接会归还到连接池中。如果没有borrow到连接，那么服务就会报错且关闭。&lt;/p&gt;

&lt;p&gt;　　我的上一篇&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/12/01.html&quot;&gt;池化技术&lt;/a&gt;已经提到过连接池的概念，所以这篇文章是我想记录并分享我所学习到的jedis连接池的知识。通过上一段代码我们看到当jedisPool实例化以后，我们从pool中通过getResource来获取一个jedis实例。那么我们的代码研究就从这里开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/jedisPool.class
    public Jedis getResource() {
        //调用父集getResource
        Jedis jedis = (Jedis)super.getResource();
        //将当前实例暴露出dataSource，供后续redis操作使用
        jedis.setDataSource(this);
        return jedis;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/client/util/Pool.class
    //genericObjectPool是ObjectPool的实现，ObjectPool是common.pool2中关于池化对象的接口。其中定义了几个标准的对象方法，这些方法就是管理池的核心方法。
    protected GenericObjectPool&amp;lt;T&amp;gt; internalPool;
    ……
    public T getResource() {
        try {
            //通过调用common.pool2中的borrowObject，完成对jedis实例的借取。
            return this.internalPool.borrowObject();
            //如果出现了异常了，按照异常的分类进行处理。
        } catch (NoSuchElementException var2) {
            if (null == var2.getCause()) {
                throw new JedisExhaustedPoolException(&quot;Could not get a resource since the pool is exhausted&quot;, var2);
            } else {
                throw new JedisException(&quot;Could not get a resource from the pool&quot;, var2);
            }
        } catch (Exception var3) {
            throw new JedisConnectionException(&quot;Could not get a resource from the pool&quot;, var3);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在common-pool2中，对象池的核心接口叫做ObjectPool，他定义了对象池的实现的行为。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;addObject方法：往池中添加一个对象。池子里的所有对象都是通过这个方法进来的。&lt;/li&gt;
  &lt;li&gt;borrowObject方法：从池中借走到一个对象。借走不等于删除。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;returnObject方法：把对象归还给对象池。归还不等于添加。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;invalidateObject：销毁一个对象。这个方法才会将对象从池子中删除，当然这其中最重要的就是释放对象本身持有的各种资源。&lt;/li&gt;
  &lt;li&gt;getNumIdle：返回对象池中有多少对象是空闲的，也就是能够被借走的对象的数量。&lt;/li&gt;
  &lt;li&gt;getNumActive：返回对象池中有对象对象是活跃的，也就是已经被借走的，在使用中的对象的数量。&lt;/li&gt;
  &lt;li&gt;clear：清理对象池。注意是清理不是清空，改方法要求的是，清理所有空闲对象，释放相关资源。&lt;/li&gt;
  &lt;li&gt;close：关闭对象池。这个方法可以达到清空的效果，清理所有对象以及相关资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　在common-pool2中，objectPool的核心实现类就是GenericObjectPool。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectedPool
    @Override
    public T borrowObject() throws Exception {
        //getMaxWaitMillis()是BaseGenericObjectPool中设定的volatile类型的值，代表最长等待时间（毫秒），配置文件中的&quot;maxWait&quot;
        return borrowObject(getMaxWaitMillis());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接下来我们来分析下borrowObject方法，刚才说过borrowObject是实现了ObjectPool。那么先看一下这个接口中对borrowObject的描述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    /**
     * Obtains an instance from this pool.
     * &amp;lt;p&amp;gt;
     * Instances returned from this method will have been either newly created
     * with {@link PooledObjectFactory#makeObject} or will be a previously
     * idle object and have been activated with
     * {@link PooledObjectFactory#activateObject} and then validated with
     * {@link PooledObjectFactory#validateObject}.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * By contract, clients &amp;lt;strong&amp;gt;must&amp;lt;/strong&amp;gt; return the borrowed instance
     * using {@link #returnObject}, {@link #invalidateObject}, or a related
     * method as defined in an implementation or sub-interface.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * The behavior of this method when the pool has been exhausted
     * is not strictly specified (although it may be specified by
     * implementations).
     * &amp;lt;/p&amp;gt;
     *
     * @return an instance from this pool.
     *
     * @throws IllegalStateException
     *              after {@link #close close} has been called on this pool.
     * @throws Exception
     *              when {@link PooledObjectFactory#makeObject} throws an
     *              exception.
     * @throws NoSuchElementException
     *              when the pool is exhausted and cannot or will not return
     *              another instance.
     */
     /*
     这个method返回实例，这个实例将是一个被makeObject()创建的对象，或者是一个之前就是idle并且经过activateObject()激活过的并且经过validatedObject()验证过的对象。
     根据约定，客户端必须调用过returenObject(),invalidateObject()或者一个在子类中实现了归还逻辑的方法后归还。
     这个方法在池子耗尽时的表现没有指明具体如何处理（尽管他有可能被他的实现制定过。）
     */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接着我们再来看看这个方法的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectPool.class
    /**
     * Equivalent to &amp;lt;code&amp;gt;{@link #borrowObject(long)
     * borrowObject}({@link #getMaxWaitMillis()})&amp;lt;/code&amp;gt;.
     * &amp;lt;p&amp;gt;
     * {@inheritDoc}
     * &amp;lt;/p&amp;gt;
     */
     //通过获取配置中MaxWait配置，当做传输调用重载的方法。
    @Override
    public T borrowObject() throws Exception {
        return borrowObject(getMaxWaitMillis());
    }
    
    /**
     * Borrows an object from the pool using the specific waiting time which only
     * applies if {@link #getBlockWhenExhausted()} is true.
     * &amp;lt;p&amp;gt;
     * If there is one or more idle instance available in the pool, then an
     * idle instance will be selected based on the value of {@link #getLifo()},
     * activated and returned. If activation fails, or {@link #getTestOnBorrow()
     * testOnBorrow} is set to {@code true} and validation fails, the
     * instance is destroyed and the next available instance is examined. This
     * continues until either a valid instance is returned or there are no more
     * idle instances available.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If there are no idle instances available in the pool, behavior depends on
     * the {@link #getMaxTotal() maxTotal}, (if applicable)
     * {@link #getBlockWhenExhausted()} and the value passed in to the
     * {@code borrowMaxWaitMillis} parameter. If the number of instances
     * checked out from the pool is less than {@code maxTotal,} a new
     * instance is created, activated and (if applicable) validated and returned
     * to the caller. If validation fails, a {@code NoSuchElementException}
     * is thrown.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If the pool is exhausted (no available idle instances and no capacity to
     * create new ones), this method will either block (if
     * {@link #getBlockWhenExhausted()} is true) or throw a
     * {@code NoSuchElementException} (if
     * {@link #getBlockWhenExhausted()} is false). The length of time that this
     * method will block when {@link #getBlockWhenExhausted()} is true is
     * determined by the value passed in to the {@code borrowMaxWaitMillis}
     * parameter.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * When the pool is exhausted, multiple calling threads may be
     * simultaneously blocked waiting for instances to become available. A
     * &quot;fairness&quot; algorithm has been implemented to ensure that threads receive
     * available instances in request arrival order.
     * &amp;lt;/p&amp;gt;
     *
     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
     *                            to become available
     *
     * @return object instance from the pool
     *
     * @throws NoSuchElementException if an instance cannot be returned
     *
     * @throws Exception if an object instance cannot be returned due to an
     *                   error
     */
     /*
     当getBlockWhenExhausted()返回true时，需要提供等待时间从对象池中借出对象，
     如果有1个或多个空闲实例的话，就通过getLifo()方法，也就是先进先出的策略选择由哪个空闲实例承接工作。如果激活失败了，或者testOnBorrow设置为true并且检测失败了，这个实例就会销毁，接下来由下一个可用实例进行承接。这个流程一直持续，直到没有可用的实例可供使用或者没有空闲实例可供使用。
     如果在对象池中没有空闲实例了，接下来的走向取决于maxTotal,getBlockWhenExhausted()和传进来的等待时间参数决定。如果当前对象池中的实力数量小于maxtotal，一个新的实例将被创建，激活并且检测最终返回给调用者。如果检测失败，一个NoSuchElementException异常将被抛出。
     如果对象池已经占满了（也就是说没有可用的空闲实例并且没有容量可以被创建），这个方法要不堵塞（如果getBlockWhenExhausted设置为true的情况下才会堵塞）要不就抛出一个NoSuchElementException（相反getBlockWhenExhausted为false的情况）异常。具体阻塞的时间跟传入的borrowMaxWaitMillis时间大小有关。（还记得刚才说的maxWait的设置么？）
     当对象池已经耗尽，多个调用线程将被同时堵塞，他们一起等待可用的jedis实例接客。接客的规则采用公平算法。其实就是先到先被接~哈哈
     */
    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        //这一步就是检查一下对象池的状态，如果之前已经关闭了，就会抛出IllegalStateException异常。
        assertOpen();
        //移除已经被抛弃的实例
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;
                (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;
                (getNumActive() &amp;gt; getMaxTotal() - 3) ) {
            /*
            被抛弃的实例不为null
            borrow时去除被抛弃的实例
            空闲线程实例&amp;lt;2
            当前活动的实例数量大于最大实例数量-3
            */
            removeAbandoned(ac);
        }
        //定义一个PooledObject类型的对象，T是真正的实例对象。如jedis，db等。
        PooledObject&amp;lt;T&amp;gt; p = null;

        // Get local copy of current config so it is consistent for entire
        // method execution
        /*
        获取一个本地的拷贝，这个拷贝是目前的配置。这样就能够保证整体的一致性。
        这个getBlockWhenExhausted()最终是获取的一个volatile类型的值，这个值是从配置中获取的，代表当线程池满时，是否对新来的任务给予堵塞。但是，我们得注意volatile这个类型了，而且设计者在这个地方单独获取出来这个值，肯定是为了什么。接着往下看吧。
        */
        final boolean blockWhenExhausted = getBlockWhenExhausted();
        //是否为新建，请区别于created。为什么仅在这里定义了变量而没有初始化呢？
        boolean create;
        //当前的毫秒，用来就算
        final long waitTime = System.currentTimeMillis();
        //循环开始，第一次p=null开始循环
        while (p == null) {
            //初始化create=false，代表目前这个线程不是新建的。
            create = false;
            /*
            private final LinkedBlockingDeque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleObjects;
            idleObjects是一个阻塞有序队列，队列的类型是刚才的封装类型，封装的是实际的资源。从名字上可以看出，这里叫做空闲对象组
            可以看到，从空闲对象组里拿出第一个元素。pollFirst()是LinkedBlockingDeque.java中的方法。就是通过操作节点来把第一个节点删除并返回。
            */
            p = idleObjects.pollFirst();
            //如果p为空代表弹出的是null，说明没有空闲。那就创建一个新的对象。
            if (p == null) {
                p = create();
                //p可能会创建失败，创建失败的时候 create=false。 创建成功create=true
                if (p != null) {
                    create = true;
                }
            }
            //如果设置了对象池耗尽后堵塞等待的标示
            if (blockWhenExhausted) {
                if (p == null) {
                    //p没有创建成功
                    if (borrowMaxWaitMillis &amp;lt; 0) {
                        //如果没有设置为-1，只有这种情况会符合小于0.所以就直接从空闲对象组中获取第一个有效的空闲对象。这个方法有锁的实现，所以这块可能会一直堵塞着直到有一个空闲对象可以使用。
                        p = idleObjects.takeFirst();
                    } else {
                    //如果设置等待时间了，就在这段时间里获取。超过了就返回null
                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                TimeUnit.MILLISECONDS);
                    }
                }
                //到这里如果还是空，就说明没等待到空闲的资源了。所以就要报异常了。
                if (p == null) {
                    throw new NoSuchElementException(
                            &quot;Timeout waiting for idle object&quot;);
                }
            } else {
                //如果没有设置blockWhenExhausted标示且p是null，那真是获取不到资源了，因为池子已经被占满了。
                if (p == null) {
                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);
                }
            }
            /*
            到这里其实p应该不是null了，说明肯定是有资源了。有可能是获得了空闲资源或是创建了一个新的资源。这个时候就要让系统给他分配内存了。跟进allocate()代码中，发现这是一个synchronized方法，保证了线程安全。（这块会有线程安全问题。为什么呢？）方法体判断了当前池状态（空闲状态或者测试中状态）然后更改状态位，置lastBorrowTime,lastUseTime,borrowedCount++等，然后返回boolean。
            我们可以推算出，当前的池资源状态可能会被另一个线程改写。有一种情况就是，空闲的连接还需要进行test和validate才能够正确分配。但是如果在test或validate阶段失败了，那线程就不能够被分配资源了，因为前后状态不一致了。所以需要allocate的同步操作来保证当时的空闲资源不被改写。
            */
            if (!p.allocate()) {
                //没有成功分配资源，当然p就应该置为null，等待重新进行遍历。
                p = null;
            }
            //到这里，分配成功的p应该进行校验阶段了。没有成功分配的p目前还是null，所以跳过下面的判断。
            if (p != null) {
                //从这开始p是有资源了
                try {
                    /*
                    private final PooledObjectFactory&amp;lt;T&amp;gt; factory;
                    通过池工厂（PooledObjectFactory.java）对返回来的实例重新初始化。因为PooledObjectFactory是个接口。所以，我以Jedis为T进行解析（JedisFactory.java），别的实际类型会有不同的行为，但是基本差不多。
        这个方法里就是获取了BinaryJedis，判断当前的库是不是库0.如果不是就就简单做个select操作。如果是的话什么都不做。
                    这块的设计有一个小心思，就是作者用这种代码结构来给开发者留出了很大的实现空间。
                    */
                    factory.activateObject(p);
                } catch (final Exception e) {
                    //激活异常
                    try {
                        //摧毁对象，释放资源
                        destroy(p, DestroyMode.NORMAL);
                    } catch (final Exception e1) {
                        // 摧毁的程序都报异常了，我可管不了了。采取鸵鸟算法。
                    }
                    //help GC
                    p = null;
                    //如果是新建的资源，就说明分配成功，但是激活失败。抛个错吧。
                    if (create) {
                        final NoSuchElementException nsee = new NoSuchElementException(
                                &quot;Unable to activate object&quot;);
                        //用什么错误原因呢？就用上面这个吧
                        nsee.initCause(e);
                        throw nsee;
                    }
                }
                /*
                如果分配成功了， 激活也成功了，并且开启了TestOnBorrow，逻辑进来再让我蹂躏下吧。如果失败了跳过这个逻辑吧。
                testOnBorrow的目的是不论资源是否是从池子里借的，都要在返回钱进行一次验证。如果失败了资源会被清除出池子并且毁掉。然后再向池对象尝试借一次。
                */
                if (p != null &amp;amp;&amp;amp; getTestOnBorrow()) {
                    boolean validate = false;
                    Throwable validationThrowable = null;
                    try {
                    /*
                    我依然以JedisFactory.java分析吧。
                    依然是首先获取一个BinaryJedis资源。判断连接的Port和设置的port是否相等。判断连接的host和设置额host是否相等。相等就返回true。否则就返回false。
                    */
                        validate = factory.validateObject(p);
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        validationThrowable = t;
                    }
                    //如果检查没有通过依然是摧毁。如果是新建的就报错。和上面激活的流程一样。
                    if (!validate) {
                        try {
                            destroy(p, DestroyMode.NORMAL);
                            destroyedByBorrowValidationCount.incrementAndGet();
                        } catch (final Exception e) {
                            // Ignore - validation failure is more important
                        }
                        p = null;
                        if (create) {
                            final NoSuchElementException nsee = new NoSuchElementException(
                                    &quot;Unable to validate object&quot;);
                            nsee.initCause(validationThrowable);
                            throw nsee;
                        }
                    }
                }
            }
        }
        //恭喜获得了一个有效的p资源。然后统计一下数据吧，比如消耗时间。
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
        //返回吧。记住返回的是一个PooledObject对象。真正的资源需要通过getObject(）获取。
        return p.getObject();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，看懂了jedis是如何从连接池中拿到资源的了。这里面经常有一些线程安全的判断，这也是难点所在，因为池化技术最重要的功能就是对线程资源的管理与利用。所以，代码中用了很多sychronize方法。不光这些，作者还要考虑到资源的释放和销毁还有扩展。&lt;/p&gt;

&lt;p&gt;　　最后看到了getObject()方法。为什么作者不直接暴露资源呢？为什么还要包一层呢？接下来我来分析一下吧。PooledObject是一个接口，我们先看看接口的描述是什么。详情看我的之前一篇文章&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/13/01.html&quot;&gt;common-pool对象池学习&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Defines the wrapper that is used to track the additional information, such as
 * state, for the pooled objects.
 * &amp;lt;p&amp;gt;
 * Implementations of this class are required to be thread-safe.
 * &amp;lt;/p&amp;gt;
 *
 * @param &amp;lt;T&amp;gt; the type of object in the pool
 *
 * @since 2.0
 */
 /*
 定义一个封装结构，这个封装结构使用来记录额外信息的。比如池资源的状态等。
 实现这个接口的class文件必须是线程安全的。（为什么呢？）
 
 */
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42340670/article/details/106876879&quot;&gt;对象池：commons-pool2源码解析：GenericObjectPool的borrowObject方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,java" /><summary type="html">　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。</summary></entry><entry><title type="html">common-pool对象池学习</title><link href="https://naffan.cn/tech/2021/05/13/01.html" rel="alternate" type="text/html" title="common-pool对象池学习" /><published>2021-05-13T00:00:00+08:00</published><updated>2021-05-13T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/13/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/13/01.html">&lt;blockquote&gt;
  &lt;p&gt;问如果你要设计一个池化对象，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　设计一个T类型的池子，把T类型的资源都放到池子中。资源负责资源的事情，池子负责管理资源。管理池子要做到资源数量的管理，资源状态的管理，资源创建和销毁，线程安全，资源记录。还要考虑到复用的可能。&lt;/p&gt;

&lt;p&gt;　　让我们看看common-pool2的组成部分吧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ObjectPool: 存取和状态管理的实现。我们直接操作的线程池就是在这里定义的。这里定义的是如何获取和释放对象等操作。至于具体创建对象的代码，是由PooledObjectFactory来负责的。&lt;/li&gt;
  &lt;li&gt;PooledObject: 将真正的资源进行封装，封装的过程中添加一些附加信息，比如状态信息，时间等信息。这些信息方便再操作连接资源时完成特定的操作。&lt;/li&gt;
  &lt;li&gt;PooledObjectFactory:创建，初始化，销毁对象的具体实现的地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08e792838506108fff0318c10420d0022801300138d233.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//一个简单的池结果。它继承了Closeable接口，也就是说是可以关闭的数据源或目标。T是实际存在于池中的类型。
public interface ObjectPool&amp;lt;T&amp;gt; extends Closeable{
    
    //通过PooledObjectFactory创建对象或者通过其他机制放入空闲池对象。addObject也用来预热空闲池。
    void addObject() throws Exception, IllegalStateException,
            UnsupportedOperationException;
            
    //传入参数count，调用count次addObject。 方法的类型是default，也就是说这个方法直接实现方法体，不用实现者实现这个方法。
    default void addObjects(final int count) throws Exception {
        for (int i = 0; i &amp;lt; count; i++) {
            addObject();
        }
    }
    
    /*
    从对象池中获取一个实例。
    创建的实例要不是通过PooledObjectFactory中makeObject()新建出来的，要不就是用了前一个已经被PooledObjectFactory中activateObject()和PooledObjectFactory中validateObject()的空闲对象。
    activateObject()和validateObject()这两个方法需要在不同的池类型文件中自己去实现。
    */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
    
    //清除随机对象放回到池中作为空闲对象。释放这个对象的相关引用资源。在clear之前一定是经过PooledObjectFacotry的destroyObject()过。
     void clear() throws Exception, UnsupportedOperationException;
     
    //继承自Closeable接口，负责关闭并释放有关联系的系统资源。如果之前已经关闭了， 则调用此方法无效。
    @Override
    void close();
    
    //返回当前有多少实例从池对象中被借出了。如果返回的是负数代表这个信息不可用。
    int getNumActive();
    
    //返回当前当前池中有多少空闲对象。这个值是一个近似值，因为他只代表还没有创建成新资源的被借走的对象。我理解的是还没有被分配内存地址（allocate）。
    int getNumIdle();
    
    /*
    使池中对象失效
    按照约定，参数obj必已经被borrwoObject()或者被一个定义在子实现类中定义的方法实现了获取逻辑的对象。如果失败了就返回异常
    */
     void invalidateObject(T obj) throws Exception;
     
     //比上面多了一个DestoryMode。DestoryMode是个枚举，分别为普通摧毁和被禁的摧毁。最终调用的是PooledObjectFactory的destoryObject()。但不知为啥，我发现其实mode参数最终没有用上……。往下看，看到工厂的destoryObject（）
     default void invalidateObject(final T obj, final DestroyMode mode) throws Exception {
        invalidateObject(obj);
    }
    
    /*
    返回一个池对象中的实例。同invalidateObject()
    异常中会抛出IllegalStateException。原因是如果有任何（把除了已经被分配内存的有状态的资源，即被借出了的。或者返回一个对象超过一次以上或者返回一个从未被借出过的对象）操作就会触发这个异常
    */
     void returnObject(T obj) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
用来定义池对象的一个wrapper 接口，用于跟踪对象的附加信息，比如状态、创建时间、使用时间等。这个类的实现必须是线程安全的。
*/
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {

    //返回被包装的实际对象
    T getObject();

    //返回该对象的创建时间
    long getCreateTime();
    
    //以毫秒为单位获得该对象最后在活动状态中使用的时间(它可能仍然处于活动状态，在这种情况下后续调用将返回一个增加的值)。
    long getActiveTimeMillis();

    //借出的次数
    default long getBorrowedCount() {
        return -1;
    }

    //空闲时间
    long getIdleTimeMillis();

    //上次借用时间
    long getLastBorrowTime();

    //上次归还时间
    long getLastReturnTime();

     /**
     * 返回上次使用时间的一个估计值,如果Pooled Object实现了TrackedUse接口
     * 那么返回值将是TrackedUse.getLastUsed()和getLastBorrowTime()的较大者，
     * 否则返回值和getLastBorrowTime()相等
     */
    long getLastUsedTime();

     /*
     因为接口继承了Comparable接口。所以这个接口需要实现自己的排序逻辑。
     默认是按照空闲时间排序的。
     */
    @Override
    int compareTo(PooledObject&amp;lt;T&amp;gt; other);

    @Override
    boolean equals(Object obj);

    @Override
    int hashCode();

    @Override
    String toString();

    //尝试将池对象置于PooledObjectState.EVICTION状态，即收回
    boolean startEvictionTest();

     //是否完成了收回测试
    boolean endEvictionTest(Deque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleQueue);

    //分配内存，这个比较重要。因为连接池中的资源被分配后才能算真正的解除。分配内存的过程中可能会出现抢占资源的情况，所以会发生异常。反正，最终返回ture/false来代表是否分配内存成功，即完成了borrow，状态改为PooledObjectState.ALLOCATED
    boolean allocate();

    //与上面一个方法作用相反,将PooledObjectState.ALLOCATED置为PooledObjectState.IDLE
    boolean deallocate();

    //将对象置为PooledObjectState.INVALID无效状态
    void invalidate();

    //设置是否记录对象使用的堆栈信息,可用于池泄漏时问题追溯
    void setLogAbandoned(boolean logAbandoned);

     /*
     设置记录堆栈信息时的策略，是全量还是只记泄露的信息。
     设置为false时，泄露信息只包括调用类的信息而不是方法名。
     设置为数字时，制使用包含完整堆栈跟踪信息的堆栈遍历机制；否则，如果可能，使用更快的实现。
     参数是自common-pool2-2.7.0开始有的。
     */
    default void setRequireFullStackTrace(final boolean requireFullStackTrace) {
        // noop
    }

     //记录当前对象最后一次使用的堆栈信息
    void use();

    //打印对象的调用堆栈信息
    void printStackTrace(PrintWriter writer);

    //返回对象目前的状态
    PooledObjectState getState();

    //标记该对象发生了泄漏
    void markAbandoned();

    //标记该对象正在被归还到对象池
    void markReturning();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
这个接口主要提供给ObjectPool接口使用。因为这个接口定义了池中对象的生命周期相关的所有方法。
按照约定，以下情况ObjectPool会代理到PooledObjectFactory中：
1.不论何时创建一个实例调用makeObject()时
2.当实例在借出之前，已经处于passivated，每次实例在调用activateObject时
3.当一个实例被激活时。当一个实例已经返回到池里并且正在做检查，又在passivated（卸载）之前时。当acitvated实例且确定能被借出时
4.每个实例返回到连接池后，在调用passivateObject()时
5.当实例正在从池中销毁时，destoryObject()调用时

这个工厂必须确保线程安全，工厂只需要ObjectPool保证操作的实际类型和工厂一致即可。
*/
public interface PooledObjectFactory&amp;lt;T&amp;gt; {
  
   //创建一个资源实例，这个资源实例可以被封装起来。
  PooledObject&amp;lt;T&amp;gt; makeObject() throws Exception;

   /*
   销毁一个不再被池子需要的实例。用的销毁模式是normal。
   实现了这个方法的类需要注意的是：方法内没有任何保证资源处于什么状态和实现的方法如何去处理非预期的errors
   所以，实现者需要考虑到对象没有被摧毁，即被垃圾收集器忘掉了，从而永远储存在了内存中。
   */
  void destroyObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //同上，只是采用了DestoryMode模式。但是其实感觉是mode根本没用用上。。。
  default void destroyObject(final PooledObject&amp;lt;T&amp;gt; p, final DestroyMode mode) throws Exception {
      destroyObject(p);
  }

  //确保实例能够安全的返回到池子里
  boolean validateObject(PooledObject&amp;lt;T&amp;gt; p);

   //重新初始化池返回的实例
  void activateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //卸载要返回到空闲对象池的实例
  void passivateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，我分析完了三个接口。三个接口各司其职，互相协助。我用一张我画的图片来描述的话，一个管对象的打包，一个管对象的创建，一个管对象的进出口。用jedis举例的话就是，jedis资源打包成封装格式，封装格式被工厂创建，创建成真正使用的资源。这些资源再被借出或者归还。多么的形象哈哈。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08eede83850610aaa80818b90e20b8082801300138e0f401.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　下面这张图是这三个接口相关的关系。
&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08cbdf83850610abd30818850620bb032801300138af8401.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　另外，上面的接口都用到了对象的状态，对象状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public enum PooledObjectState {
    /**
     * 在队列中,未被使用,空闲状态。调用allocate()方法后对象应该被置于该状态
     */
    IDLE,

    /**
     * 已分配,在使用中,调用allocate()方法后应该讲对象置于该状态
     */
    ALLOCATED,

    /**
     * 在队列中, 当前正在测试，可能会被回收。在此状态被借出后状态回被置为EVICTION_RETURN_TO_HEAD
     */
    EVICTION,

    /**
     * 不在队列中。当借用该对象时发现对象，发现正在进行回收测试，故将EVICTION更
     * 改EVICTION_RETURN_TO_HEAD，表明曾经在回收过程中被借出，在回收完后它应该从新添加到队列的头部。
     */
    EVICTION_RETURN_TO_HEAD,

    /**
     * 在队列中,目前正在进行校验
     */
    VALIDATION,

    /**
     * 不在队列中，当前正在验证。当对象从池中被借出，
     * 在配置了testOnBorrow的情况下，对像从队列移除和进行预分配的时候会进行验证(借用时校验)
     */
    VALIDATION_PREALLOCATED,

   /**
     * 不在队列中，正在进行验证。从池中借出对象时，发现对象正在进行校验，并将对象状态改为该状态
     */
    VALIDATION_RETURN_TO_HEAD,

    /**
     *无效的，并且将要或已经被销毁。
     */
    INVALID,

    /**
     * 泄漏的
     */
    ABANDONED,

    /**
     *归还中,调用markReturning()方法会将对象状态改为此状态，表明正在归还一个对象
     */
    RETURNING
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq447995687/article/details/80413227&quot;&gt;commons-pool2源码走读(一)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liyantianmin/article/details/86591742&quot;&gt;common-pool对象池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="pool,java" /><summary type="html">问如果你要设计一个池化对象，你会怎么做？</summary></entry><entry><title type="html">池化技术</title><link href="https://naffan.cn/tech/2021/05/12/01.html" rel="alternate" type="text/html" title="池化技术" /><published>2021-05-12T00:00:00+08:00</published><updated>2021-05-12T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/12/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/12/01.html">&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3a3f5840610fee80b18b90e20b8082801300138d074.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　池化技术就是把一些能复用的实例放在一起，一般指的是内存里，而池这个概念也是一个虚拟的概念。这样做的好处是省去了每次消耗在新建、销毁这些实例的时间，从而提高了整体服务性能。在开发中，我们经常遇到的就是数据库的连接池和多线程的线程池。连接池的管理是核心。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;数据库连接池&quot;&gt;数据库连接池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　数据库包括关系型数据库和非关系型数据库两种。关系型数据库指的是mysql，非关系型数据库指的是redis。&lt;/p&gt;

&lt;p&gt;　　mysql连接池有两个重要的配置：最小连接数和最大连接数。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前连接数小于最小连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;如果连接池中有空闲连接，则使用空闲连接。
3。 如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接。这等价于建立一个新的连接。这些连接使用完成不会立马清除，而是放在池中等待复用最终空闲超过一段时间后自动释放。&lt;/li&gt;
  &lt;li&gt;如果当前连接数大于等于最大连接数，并且没有空闲连接了，则进入等待队列，在超时时间内等待空闲连接。&lt;/li&gt;
  &lt;li&gt;超时之后，则提示超时失败。获取数据库连接失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　redis连接池有3个重要的配置：最大连接数，最小空闲数，最大空闲数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前连接小于最大连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;当前连接数大于等于最大连接数，超出的连接进入等待队列&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;，判断是否开启&lt;code&gt;blockWhenExhausted&lt;/code&gt;，是则等待获取连接，否则抛错连接池已耗尽。&lt;/li&gt;
  &lt;li&gt;当前连接数小于最小空闲数，则预热最小空闲数连接。&lt;/li&gt;
  &lt;li&gt;当前连接数大于最大空闲数，则强制销毁这些多出来的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;线程池&quot;&gt;线程池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　JDK1.5中引入的ThreadPoolExecutor就是一种线程池的实现，它有两个重要的参数：coreThreadCount和maxThreadCount。这两个参数控制着线程池的执行过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程数少于coreThreadCount时，则创建新的线程处理请求。&lt;/li&gt;
  &lt;li&gt;如果当前线程数大于coreThreadCount则将超出的任务进队列，由当前空闲的线程执行。&lt;/li&gt;
  &lt;li&gt;当队列中的任务对接满时，则继续创建线程，直到maxThreadCount。&lt;/li&gt;
  &lt;li&gt;当前线程数达到maxThreadCount时还有新的任务，就将其按照抛弃策略进行抛弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc7xbdxj67j30wk0ouqb3.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JDK线程池提交任务示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　连接池和线程池在开发过程中并不陌生，但是想真正弄懂他们还是需要借助阅读源码的帮助。在使用上如果遇到了一些困惑的话，可以查阅相关资料或者探索源码如何解决的。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">一种优化连接的方案，各种地方都有可能用到这种技术</summary></entry><entry><title type="html">我对JVM的解析和总结</title><link href="https://naffan.cn/tech/2021/05/11/01.html" rel="alternate" type="text/html" title="我对JVM的解析和总结" /><published>2021-05-11T00:00:00+08:00</published><updated>2021-05-11T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/11/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/11/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;java运行时数据区&quot;&gt;Java运行时数据区&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jvm会将内存划分为若干个不同的数据区域。如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://cdn.jikewenku.com/wp-content/uploads/2021/01/74e01322f26270ccfe235ead6215d271.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JVM运行时数据区域&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序计数器：线程私有，指向当前线程正在执行的字节码指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈：java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧压入栈，当方法&lt;code&gt;正常返回&lt;/code&gt;或者&lt;code&gt;抛出未捕获的异常&lt;/code&gt;时，栈帧就会出栈。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jmm-java内存模型&quot;&gt;JMM Java内存模型&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;堆的内存划分&quot;&gt;堆的内存划分&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;gc垃圾回收&quot;&gt;GC垃圾回收&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;hotspot-虚拟机详解&quot;&gt;HotSpot 虚拟机详解&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot,jvm" /><summary type="html">Java运行时数据区</summary></entry><entry><title type="html">spring-data-redis中的Jackson2JsonRedisSerializer研读</title><link href="https://naffan.cn/tech/2021/05/07/01.html" rel="alternate" type="text/html" title="spring-data-redis中的Jackson2JsonRedisSerializer研读" /><published>2021-05-07T00:00:00+08:00</published><updated>2021-05-07T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/07/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/07/01.html">&lt;p&gt;spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。&lt;/p&gt;

&lt;p&gt;首先，Jackson2JsonRedisSerializer一共有6个方法。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(JavaType javaType)&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;deserialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;serialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;setObjectMapper&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getJavaType&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Creates a new {@link Jackson2JsonRedisSerializer} for the given target {@link Class}.
	 *
	 * @param type
	 */
	public Jackson2JsonRedisSerializer(Class&amp;lt;T&amp;gt; type) {
		this.javaType = getJavaType(type);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据传入的参数类型，通过getJavaType方法指定为databind的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Returns the Jackson {@link JavaType} for the specific class.
	 * &amp;lt;p&amp;gt;
	 * Default implementation returns {@link TypeFactory#constructType(java.lang.reflect.Type)}, but this can be
	 * overridden in subclasses, to allow for custom generic collection handling. For instance:
	 *
	 * &amp;lt;pre class=&quot;code&quot;&amp;gt;
	 * protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
	 * 	if (List.class.isAssignableFrom(clazz)) {
	 * 		return TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, MyBean.class);
	 * 	} else {
	 * 		return super.getJavaType(clazz);
	 * 	}
	 * }
	 * &amp;lt;/pre&amp;gt;
	 *
	 * @param clazz the class to return the java type for
	 * @return the java type
	 */
	protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
		return TypeFactory.defaultInstance().constructType(clazz);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaType类属于com.fasterxml.jackson.databind包。它是一种令牌类的基类，用于保存信息和反序列化器的key。通过getJavaType方法经过反射来构造出指定的class。我们看到其中应用到了TypeFactory,用TypeFactory的作用就是快速的获取到clazz相对应的具体类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class TypeFactory implements java.io.Serializable
{
    //将clazz传入，通过_formAny方法构造。Class&amp;lt;?&amp;gt; 是实现了Type接口
    public JavaType constructType(Type type) {
        return _fromAny(null, type, EMPTY_BINDINGS);
    }
    
    ....
    
     /**
     * Factory method that can be used if type information is passed
     * as Java typing returned from &amp;lt;code&amp;gt;getGenericXxx&amp;lt;/code&amp;gt; methods
     * (usually for a return or argument type).
     */
    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class&amp;lt;?&amp;gt;) {
            // Important: remove possible bindings since this is type-erased thingy
            //判断type是一个简单class。然后调用_formClass
            //ClassStack是一个工具类，用来记录调用栈信息的上下文。
            //EMPTY_BINDINGS是TypeBindings中的常量。TypeBindings是用于解析给定类的类型参数的助手类。也就是说这个常量为空绑定关系。
            resultType = _fromClass(context, (Class&amp;lt;?&amp;gt;) type, EMPTY_BINDINGS);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {...}
    ...
    }
    
    /**
     * @param bindings Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(ClassStack context, Class&amp;lt;?&amp;gt; rawType, TypeBindings bindings)
    {
        // Very first thing: small set of core types we know well:
        //第一件事就是通过rawType来判断是哪种众所周知的简单类型。首先判断是否是原始类型，并且是否是BOOL，INT，LONG。如果不是就是String，Object。否则返回null
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance
        final Object key;
        if ((bindings == null) || bindings.isEmpty()) {
        //key是这种Bool Int Long String object中的一种
            key = rawType;
        } else {
            key = bindings.asKey(rawType);
        }
        //_typeCache是一个LRUMap。LRUMap其实底层是个ConcurrentHashMap。它用来帮助我们避免核心类型的重复解析。尤其为了泛型的解析。
        result = _typeCache.get(key); // ok, cache object is synced
        if (result != null) {
            return result;
        }
        //一般到这里就结束了。但是，如果通过我们传入的rawType没有找到绑定的关系，那就有可能是个复杂结构的结构体（递归引用）。接下来就需要通过调用栈来追踪整个结构了。
        // 15-Oct-2015, tatu: recursive reference?
        if (context == null) {
            context = new ClassStack(rawType);
        } else {
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                //可以看到，resolvedRecursiveType这个方法是用来自我引用的一个内部类型。他继承自TypeBase，TypeBase继承自javaType。
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
            }
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
        }
        //到这里，可以将递归引用的结构解析到context变量里了。
        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
         //首先解析父类型层次结构   
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                //返回的是一个JavaType的数组。
                //如果是个超接口（superInterface），通过反射返回的必须是实际用过的类型（interface or class）。
                //如果是个class，返回的是个数组，数组中包含着所有实现过的接口。
                //如果是个interface，返回的是个数组，数组中包含所有直接继承过的接口。
                //如果是个class或者interface，就返回个一个长度为0的数组。
                //如果是基础类型或者void，就返回一个长度为0的数组。
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so cannot drop those
                //返回class表示的实体(类、接口、基本类型型或void)的直接超类
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, &quot;simple&quot; class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
            }
        }
        context.resolveSelfReferences(result);
        // 16-Jul-2016, tatu: [databind#1302] is solved different way, but ideally we shouldn't
        //     cache anything with partially resolved `ResolvedRecursiveType`... so maybe improve
        if (!result.hasHandlers()) {
            _typeCache.putIfAbsent(key, result); // cache object syncs
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonReisSerializer(JavaType javaType)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个构造方法，参数是JavaType类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;deserialize(@Nullable byte[] bytes)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;反序列化方法，可为null的byte数组为参数。如果是空或者null的话，返回null。否则，通过ObjectMapper将byte数组进行反序列化。&lt;/p&gt;

&lt;p&gt;ObjectMapper提供读和写JSON的能力。不论是转成POJO还是从POJO转出，或者是转成JSON还是从JSON转出，还是一些相关的转化功能。ObjectMapper都可以高定制化的兼容不同种的JSON格式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;serialize(@Nullable Object t)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;序列化方法，同上。t如果为null，则返回空byte数组。否则，将t序列化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setObjectMapper(ObjectMapper objectMapper)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法比较有用，它可以用来自定义JSON序列化进程的。相关设置可以参见ObjectMapper.java中的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ObjectMapper mapper = new ObjectMapper();
		mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		serializer.setObjectMapper(mapper);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getJavaType(Class&amp;lt;?&amp;gt; clazz)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法是被Jackson2JsonRedisSerializer方法调用的，用途就是返回指定class的jackson格式。&lt;/p&gt;

&lt;p&gt;通过简单阅读了这个类的源码，我对这个类也有了大致的了解。作为spring-data-redis对redis的封装中的一个策略，这个策略满足了要保存的数据有比较复杂的层级结构，而且效率还是非常高的。建议用这个策略进行保存，只是可读性差了一些。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。</summary></entry><entry><title type="html">springboot的策略模式</title><link href="https://naffan.cn/tech/2021/05/02/01.html" rel="alternate" type="text/html" title="springboot的策略模式" /><published>2021-05-02T00:00:00+08:00</published><updated>2021-05-02T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/02/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/02/01.html">&lt;p&gt;策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。&lt;/p&gt;

&lt;p&gt;当你用springboot的时候，会牵扯到如何将类委托给spring容器，如果你按照策略模式的传统写法，就会遇到类似问题。所以，我们应该将不同的策略实现公用的接口，也就是面向接口编程。&lt;/p&gt;

&lt;p&gt;首先，我们定义一个接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ICreateOrderAndMissionStrategy {

	/**
	 * 创建订单和任务。不同的策略应该对这个方法进行重写
	 */
	void doCreateOrderAndMission(KCameraOrderAbstractCreateDTO oscVo);

	/**
	 * 获取类型，每个策略都需要你定义一个类型，比如业务1就定义为1，比如业务2就定义为2。当然，你也可以定义成不同类型。按照你的习惯即可
	 * @return Integer
	 */
	Integer getType();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，构造一个类，这个类的目的就是驱动你的策略。同时，也是这个类将你的策略装配到spring中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class CreateOrderMissionStrategyService {

	/**
	 * 策略类中的成员map变量，保存各种策略类.可以看到我将ICreateOrderAndMissionStrategy接口构造成一个map。通过我之前定义的数字来获取value。也就是能够拿到相应的策略。
	 */
	Map&amp;lt;Integer, ICreateOrderAndMissionStrategy&amp;gt; strategyMap = new HashMap&amp;lt;&amp;gt;(8);

	/**
	 * 构造函数，通过将spring管理的所有策略类注册进成员map变量中。
	 * 这个方法很重要，因为它驱动了策略类的装配。
	 * @param strategies List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt;
	 */
	public CreateOrderMissionStrategyService(List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt; strategies) {
		for (ICreateOrderAndMissionStrategy strategy : strategies) {
			strategyMap.put(strategy.getType(), strategy);
		}
	}

	/**
	 * 处理策略程序。通过strategyType得到我想要的策略类，然后进行调用
	 * @param strategyType 策略类型
	 * @param oscVo 业务变量
	 * @throws BizException 业务异常
	 */
	public void executeStrategy(Integer strategyType, KCameraOrderAbstractCreateDTO oscVo) throws BizException{
		ICreateOrderAndMissionStrategy strategy = strategyMap.get(strategyType);
		if(strategy == null){
			throw new BizException(&quot;未找到事件处理实现类，strategyType:&quot; + strategyType);
		}
		strategy.doCreateOrderAndMission(oscVo);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我可以开始根据不同的业务进行不同的策略了。我举两个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略A
public class AStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.A.getCode();  // 这个是我定义的策略类型的枚举类。我A为1，B为2
	}
	
	/**
	 * A策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略B
public class BStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.B.getCode();  	}
	
	/**
	 * B策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在真正的逻辑中，我们就可以直接使用这个模式了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Demo{

    public void Business(){
        String[] taskTypeList = oscVo.getTaskTypes().split(&quot;,&quot;);
			for (String i : taskTypeList) {
    createHouseSourceOrderAndMission.executeStrategy(Integer.valueOf(i),oscVo);
            			}
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。</summary></entry><entry><title type="html">2021年的五一劳动节</title><link href="https://naffan.cn/life/2021/05/01/01.html" rel="alternate" type="text/html" title="2021年的五一劳动节" /><published>2021-05-01T00:00:00+08:00</published><updated>2021-05-01T00:00:00+08:00</updated><id>https://naffan.cn/life/2021/05/01/01</id><content type="html" xml:base="https://naffan.cn/life/2021/05/01/01.html">&lt;blockquote&gt;
  &lt;p&gt;我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2021年的劳动节是自疫情之后中国的第一个能够群体聚集的首个节日。为了这个节日中国政府将五一前后的周末各调休了一天，用来凑出这次有五天假期的劳动节。就是因为这五天的假期，全国人名举国出游。很庆幸，我们没有参与其中，我们只是全程在抖音上参观景点的盛景。看着视频里“我后悔了，不想出来玩了，我想回家”，心中虽有偷着乐的愉悦心情，但也还是计划着接下来的几天出去走走，只是仅在北京周边自驾玩一玩。&lt;/p&gt;

&lt;p&gt;五一前一周末我从网上订购了一款4人帐篷以及户外炊具，就想着用特斯拉载着家人去环郊，找一片草坪停下车来，打开帐篷，烧着咖啡，看着风景，带上一本好书，悠闲的享受整个下午。&lt;/p&gt;

&lt;p&gt;五一当天，雷打不动的还是固定节目-跟家人们吃饭。说心里话，这种正日子一起坐下来吃个饭，聊聊天，悠闲的慢生活是最佳选择。但是，妈妈偏偏把之前商量好的包饺子改成了做家常饭。妈妈跟我说回来吃一次不容易，还是想给我做一些我喜欢吃的菜。结果是，大家坐在一起吃饭，还不到10分钟就已经吃完了，加上收拾碗筷和擦桌子洗碗，总共加起来不超过20分钟。就这样，难得的中午时光被这么临时的改动浪费了。其实，在前几天我已经跟他们沟通叫上双方的服务一起在我家的小院烤肉，可是在做决定的那天下午，手机的头条发来五一会有8级大风，于是我才同意的改为在705吃饺子。这么说，其实这都是天意。我也没得办法。&lt;/p&gt;

&lt;p&gt;下午，父母是需要睡午觉的，但是我和媳妇不困，不想睡觉了。于是，我提议我们俩去新华百货转一转，让父母睡完觉再跟我联系，到时候一起赶赴大家庭的晚餐聚会。跟媳妇转商场没有什么说的，就是逛和买。但想喝一杯DQ的脏脏奶昔，结果发现到了新街口豁口，DQ却在装修，查了一下最近的DQ门店远在2.4km以外，于是作罢。媳妇提议去对面的咖啡店喝杯咖啡，因为之前媳妇和她闺蜜去喝过，感觉很好喝，所以她建议我跟她再去一次。首先我是拒绝的，但是我也没有什么好的建议，于是妥协了。不过，也是因为这次妥协，我也真正意义的喝上了一杯手磨的咖啡。也学会了一些品咖啡的方法。咖啡的苦要像巧克力的苦，酸要像果酸，咽下去的时候喉咙会感受到回甘。老婆给我点的咖啡应该还是不错的，只是自己没有经验，我也就学着尝试品尝了。回想之前在回龙观的酒吧，老板教我品威士忌，两者相比较来说方法有些相像。&lt;/p&gt;

&lt;p&gt;晚上，大家的聚会还是比较圆满的，只是餐馆包间的桌子比较小。很多人都是侧着身吃饭，这可把我的三姨尴尬坏了，看得出来三姨对这次选地的不满意，但是我也不想让三姨觉得难过，所以还是以很好吃夸赞了这次晚饭，只是我能感觉的出来三姨知道我是在宽慰她。&lt;/p&gt;

&lt;p&gt;回到705写下了这篇日记。晋升的失败没有跟妈妈说，我怕她为我担心，我的不干不应写在脸上。我需要时间再次审视自己的缺陷。在接下来的一年中补齐这块短板。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="劳动节" /><summary type="html">我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。</summary></entry><entry><title type="html">阴平古道，邓艾灭蜀</title><link href="https://naffan.cn/thinking/2020/05/16/01.html" rel="alternate" type="text/html" title="阴平古道，邓艾灭蜀" /><published>2020-05-16T00:00:00+08:00</published><updated>2020-05-16T00:00:00+08:00</updated><id>https://naffan.cn/thinking/2020/05/16/01</id><content type="html" xml:base="https://naffan.cn/thinking/2020/05/16/01.html">&lt;blockquote&gt;
  &lt;p&gt;早入蜀都,先到先得。偷渡阴平，直取蜀汉！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这是三国杀中邓艾的武将台词。从这两句中我感受最多的是一种豪言壮志，和一丝凄凉。一个为魏国，一个为蜀国。&lt;/p&gt;

&lt;p&gt;　　不知什么时候，我了解三国后就把蜀国当做了三国的主角，魏国当成了三国的反派，而吴国只是一个配角，但是在读完了关羽败走麦城后，我把吴国定性为了非盗既奸的小人国家。这些都是我个人的主观色彩使然，其实在漫漫的历史长河中，任何人任何事都有两面性，历史不是被任何一个人任何一件事就能够主导或者改变的。三国中有很多名场面，很多都耳熟能详，我也略知一二。但是，今天我不知道哪来的兴趣，想了解一下让蜀国的灭亡直接的战役，想看看这场战役中到底是谁占有举足轻重的作用。&lt;/p&gt;

&lt;p&gt;　　我18年去过重庆和成都，对当地的地形有了一定的了解，我每次去重庆的时候都要坐一夜的火车，但凡白天我看到的都是连续的隧道，正因为这里的山多，所以我们要进入四川就要穿过众多的山脉，相比于重庆来说，成都的地形较为平坦。这种地势在今天看来当然已经有科技帮我们客服了这种物理上的限制，但是对于古代的人们，可不会轻易的选择凿山穿洞的方法向前进行。然而，当时邓艾灭蜀打造的阴平小道是怎么实现的？这个问题让我颇感兴趣。&lt;/p&gt;

&lt;p&gt;　　历史上讲魏国攻打蜀国（公元263年秋）时，钟会带领20（有说10万）万大军，因剑门关是进入成都平原的最后一道重要关隘，所以被姜维死死地挡在了剑阁之外。因为，一般入蜀只有这条道可以通过，原因是周围山脉层峦叠嶂。就算钟会有百万雄师，也只能挨个从剑阁通过。那么剑阁这个地方到底长什么样子呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;何为剑阁道？剑阁道，属金牛道（石牛道）南段。其行程是从昭化（葭萌关）越牛头山，入剑门至剑阁县。此段乃石牛道上有名的险峻去处，约100公里，沿途坡陡路险，十分难行。特别是未入剑门关前的15公里，原本无路，三国时，诸葛亮北伐在峭壁悬崖上修了15公里阁道，剑阁道也由此而得名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://gss0.baidu.com/70cFfyinKgQFm2e88IuM_a/baike/pic/item/1e30e924b899a9012afdc0c314950a7b0308f57f.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;剑门关&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08d1bb848506108ba32b18ee04209906280130013881bc02.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;剑门关&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这就是剑门关，被誉为“蜀北之屏障，两川之咽喉”的雄关险隘。目前剑门关是我国5A级旅游景区，国家级风景名胜区，全国100个红色经典旅游景区之一，已列入世界文化遗产预备名单。剑门关两边有着大小剑山72峰，峰峦叠嶂，近处是刀削斧劈似的悬崖峭壁。古蜀道穿过关楼，厚重的青石板沿着山壁一级一级伸向远方。仰望关搂，耳边的风声仿佛成了万人攻关的呐喊声。&lt;/p&gt;

&lt;p&gt;　　就是这么一个极其重要的战略宝地，易守难攻，那为啥蜀国还是被邓艾掏了老窝了呢？这就要说到邓艾的丰功伟绩了，这就是偷渡阴平了。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3c584850610a4931618ff0420bf032801300138d28802.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;灭蜀路线图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　从图中，我们可以看到。魏国大军分为三路，分别由邓艾，诸葛绪，钟会进攻蜀都。中间的军事过程可以参见下面的这个视频。p.s.这里的诸葛绪因为退后30里让姜维南下的事让他躲过了一劫，最终是这三个人里面下场最好的人。&lt;/p&gt;
&lt;div align=&quot;middle&quot;&gt;
&lt;script&gt;
	document.write(&quot;&lt;iframe src='//player.bilibili.com/player.html?aid=413378551&amp;bvid=BV1FV411y7jP&amp;cid=197675942&amp;page=1'allowfullscreen='true'&gt; &lt;/iframe&gt;&quot;);
&lt;/script&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果我是邓艾，当时我会怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　当时时局姜维正在迎战邓艾，邓艾位于进军路线的西头。诸葛绪位于中间向桥头进军，意图与邓艾前后夹击姜维。钟会在最东边，钟会是第一次带重兵打仗，是当时进军路线最好，最有可能攻入蜀都的。当姜维得知汉中被钟会攻破后，马上掉头去剑阁防守。由于原来是邓艾牵制姜维，可现在邓艾被凉在旁边了，眼前的方向貌似只有追着姜维去剑阁这一条路线了。&lt;/p&gt;

&lt;p&gt;　　接下来我对比一下当时的&lt;a href=&quot;https://baike.baidu.com/item/%E9%82%93%E8%89%BE/6770?fr=aladdin&quot;&gt;邓艾&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/%E9%92%9F%E4%BC%9A/18087?fr=aladdin&quot;&gt;钟会&lt;/a&gt;身世经历。可以看到，钟会从小生活的环境要比邓艾好且有才数技艺，博学多闻，尤其精通玄学，弱冠（20岁）时就与名士、玄学代表人物王弼并知名。相反邓艾幼年丧父，出身卑微，年幼屯田，但受到了良好的教育。典故有一幕&lt;code&gt;邓艾喜欢军事。每见高山大川，都要在那里勘察地形，指划军营处所，遭别人讥笑也不介意。&lt;/code&gt;我想邓艾最终偷渡阴平跟他一直喜欢勘探地形有极大的关系。&lt;/p&gt;

&lt;p&gt;　　如果我是邓艾，在知道如果沿着路去追杀姜维面对的只有一种结果就是和钟会一块被姜维挡在剑阁之外，最终会因粮草短缺而退兵。而蜀军此时会将重兵屯于剑阁之后，即使攻破剑阁到时候面临的仍将是一场恶斗。我相信当时邓艾的军队一定会有密探在蜀国内部（双方都有间谍，这很正常），他肯定知道蜀国国君幼小，奸臣当道，国家也腐败。所以，如果能够跨过敌军绕道背后一定能够直取蜀都。那样擒贼先擒王，先到就先得了。而阴平这个地方地势凶险蜀国一定不会排重兵把守，所以要是我我一定想办法从阴平这修一条小道绕过蜀国重兵，直接来到绵竹。邓艾从小喜欢勘探地形这个特点天然的兼容这套方案啊。所以与其老老实实的失败还不如出其不意呢，万一失败了原路退回来不就行了。反正攻破剑阁也不是立马的事情。到时候随便找个托词给司马昭，得不到荣誉就得不到呗。但是修个阴平小道带来的收益绝对大于面对的风险。所以，我要是邓艾我就会铤而走险，修阴平小道。&lt;/p&gt;

&lt;p&gt;　　当时修阴平小道的难度应该是很大，摆在邓艾前面的就两个问题：山和水。我们来看一眼现在的G5京昆高速的一个关键地界。我们可以看到G5是在山坡上河流里修建的，风险度极高的。而西成铁路倒是一条直线，但是需要凿山挖隧道，隧道出来就是嘉陵江，过了嘉陵江面前有事一座大山，所以又得凿山。可想而知，这种难度对于邓艾来说会有多困难。根据记载邓艾选了几千精兵，一共花了20多天把长700公里的阴平小道建成的。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic2.zhimg.com/33638cf728e134c719eb7a20dad51ed0_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;现在的路况&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;蜀中诸道，皆不必多忧；惟阴平之地，切须仔细。此地虽险峻，久必有失&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这是公元234年，诸葛亮临死前向众人交代后事，并且特地对姜维说的27个字。简单来说，诸葛亮在临死前特地叮嘱姜维一定要守好阴平，并且还强调这地方虽然地势险要，但难保以后没有魏国人来偷袭，所以必须小心防守才行。别人说这句话没有被姜维重视，但是我不觉得，当时诸葛亮的每一句话都是箴言，并且前有诸葛亮的锦囊妙计，任何人都不可能视诸葛亮之话而不顾，更别说当时的蜀国守国大将军姜维了。另外，邓艾进军的时候姜维不就在阴平北的沓中么，这不也就说明姜维在守着阴平这块么。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;冬十月，艾自阴平道行无人之地七百馀里，凿山通道，造作桥阁。山高谷深，至为艰险，又粮运将匮，频於危殆。艾以毡自裹，推转而下。将士皆攀木缘崖，鱼贯而进。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　邓艾过了天险，一般来说都需要养精蓄锐，哪有说上来就干仗的。我理解这正是邓艾军事家视野之功，他笃定马邈因腐败会因天降神兵而弃城投降。最终却是也是这样的。有人说是上天眷顾邓艾，但是老天哪里会随随便便眷顾没有准备的人呢。这样邓艾兵不血刃的得了涪城，接下来诸葛瞻带领刘禅给的七万人迎战邓艾三万人马。那为啥邓艾能够迅速歼灭诸葛瞻之军呢？第一，邓艾的军队都是精兵良将，而诸葛瞻都是老弱病残或是临时拼凑。因为刘禅肯定会把精英派去剑阁防守。第二，邓爱军对刚多下涪城，此时士气正浓，然而诸葛瞻的军队士气肯定要落后很多。战场上士气这玩意真的很重要，士气高涨的军队，经常能够以少胜多。所以自古兵家很重视士兵的士气。第三，诸葛瞻战术问题，他没打过硬仗，长平之战时赵国还有廉颇和年轻的李牧，但此时的成都除了诸葛瞻，也没有什么其他人选可用了。&lt;/p&gt;

&lt;p&gt;　　那为什么姜维知道了后方失守却为什么不回来救呢？其实我理解如果回头救的话，可能钟会会突破剑阁，到时候前后受敌，兵家大忌。与其这样还不如继续防守，后方听天由命了。但是，最终等来的消息却是刘禅的一封投降书。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="三国" /><summary type="html">早入蜀都,先到先得。偷渡阴平，直取蜀汉！</summary></entry></feed>