<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-23T17:22:47+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">Arduino由哪些元件组成？它是怎么运转起来的？</title><link href="http://localhost:4000/tech/2022/02/22/1.html" rel="alternate" type="text/html" title="Arduino由哪些元件组成？它是怎么运转起来的？" /><published>2022-02-22T00:00:00+08:00</published><updated>2022-02-22T00:00:00+08:00</updated><id>http://localhost:4000/tech/2022/02/22/1</id><content type="html" xml:base="http://localhost:4000/tech/2022/02/22/1.html">&lt;p&gt;　　Hello，大家好。2022春节前和同事聊天的时候聊到了硬件方面的知识，同事说他们大学的时候参加电子竞赛时用的是一款叫Arduino的板子进行开发的，他还说学校里组织的竞赛都是用的Arduino。我立刻起了兴趣，于是上网找了一些关于Arduino的文章，看完以后我的兴趣是越来越浓了。以前在写程序的时候一直想能够造一些东西出来，但是苦于自己的方向是后端，所以做出来的东西均是服务相关的产品。然而，Arduino一下子让我这名后端工程师豁然开朗，各种未来的黑科技在我脑中冒了出来，于是我打算深入了解一下Arduino啦。&lt;/p&gt;

&lt;p&gt;　　首先，万里之行始于足下，我需要了解Arduino到底是什么，它是由什么组成的。简单来说，它是一个物理硬件，包括一个电路板和不同的电子元件组合起来。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fasset.ibanquan.com%2Fimage%2F5c120b0b53f4e37756003331%2Fs.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;Arduino&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面这个图，是Arduino各元件的中文解释。大概可以看得出USB接口是可以和计算机进行交互的，DC插头是交流电入口，两边的端口负责外置元件的供电和控制信号，最长的那个芯片肯定是这款板子的大脑。上面的指示灯可以帮助我们来确认各种状态。接下来，让我们先从它的大脑-ATMEGA328P说起吧！但是在说之前，我先声明下本人并不是硬件工程师，以下总结的皆是本人通过学习和探究所得的。如有不对，一定是看的网站写的不对！&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;ATMEGA328P是啥？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;可以先看下面的参考文献链接。它是一个ATMEL公司研发的8位（8-bit）的精简指令(RISC)为基础的单片机，它结合着32KB大的可同时读写的ISP闪存，同时包括了1024B EEPROM，2KB SRAM等等。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://www.microchip.com/content/dam/mchp/mrt-dam/ic-images/spdip/28-lead-m3x/ATmega328P-M3X-Regular.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;ATMEGA328P&quot; /&gt;&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;什么是单片机？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;单片机就是一个微信的CPU。单片机也叫单片微控制器。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;单片机能用来做什么？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;通过把程序烧录到芯片里面，通过控制不同的外围电路实现不同产品的功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;你刚才说的那些ISP,EEPROM,SRAM都是干什么的？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;其实这些东西在刚学Arduino时并不需要了解的，因为之后的学习中会涉及到背后的原理，到时候自然就会碰到这些概念。不过可以先提一下，这些涉及到硬件上的存储以及代码的刷新等功能。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;我看网络上很多单片机都有提到51单片机和STM单片机和AVR单片机。这些有什么区别么？
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;首先我们要明白的是，单片机是一种技术，他们的功能都和其内部的芯片息息相关。所以，这三种单片机的区别你可以暂时理解为，他们的制造商不同，采用的规格不同，所以功能上有些许的差异。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;什么是芯片？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;芯片是由电路板和集成电路组合起来的。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;什么是电路板，什么是集成电路呢？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;电路板就是那种绿油油的板子，电路板使用来走电路用的。集成电路是由各种电子元件按照一定规格组合起来的电路器件。将制作好的集成电路压在走好线的电路板上就形成了一个芯片。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;所以说，51单片机和STM单片机和AVR单片机的区别主要在厂商制作芯片的不同而不同啦？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;是的，没错。如果想了解芯片之间的不同的话，就需要去了解芯片中的微处理架构和指令架构了。这些知识更深有点偏底层了，会越讲越深。这里就举个例子，像刚才说的RISC就是适合于移动办公的指令集架构。一般移动设备使用这个芯片。相对于精简指令集还有个对应的指令集叫CISC（复杂指令集），复杂指令集多应用于桌面系统。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们说完了Arduino的大脑之后，再接着说说它的心脏-晶振。在上图中没有标明晶振，晶振其实就是USB转串口芯片的下面的那个银色标有T16.000的元件。因为晶振给芯片提供了时钟信号，所以说晶振是芯片的心脏。&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;什么是晶振？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;晶振就是以石英石为原料的元件，它能提供时钟信号。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;为什么晶振能够提供时钟信号呢？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;因为晶振可以产生固定频率的振动哈。因为有了频率振动所以就有了时间的功能。这样芯片就能将时钟作为时间的参考。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;频率是什么？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;频率的定义是在单位时间内物体重复运动的次数。这是个物理概念哈。晶振在通电以后，会产生固定的频率振动。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;晶振为什么会产生振动的频率？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;这其实跟石英晶体的物理特性有关，石英晶体有一种特性，如果在它上面施加压力，响应施力的方向就会产生一定的点位。相反的，如果施加电场，就会使晶体发生形变。如果施加的是交变电场，晶体就会产生机械振动，机械形变振动又会产生交变电场，尽管这种交变电场的电压极其微弱，但其振动频率是十分稳定的。当外加交变电压的频率与晶片的固有频率（与切割后的晶片尺寸有关，晶体愈薄，切割难度越大，谐振频率越高）相等时，机械振动的幅度将急剧增加，这种现象称为“压电谐振”。就是因为压电谐振才会产生振动的。可以看看下面的参考文献，我引用了一段bilibili的视频，从视频里你能清楚的看到晶振发生震动的细节。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接下来，我们再看看为它提供能量的电源吧。Arduino一共有三个可供电源接入的地方。一个是DC插头，一个是USB接口，一个是GND+VIN排针脚处。DC插头适配的是直径为2.1mm插头的电源，USB接口外接的是PC，外接电池可以插入GND+VIN针脚。&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;安全电压是多少？&lt;/p&gt;
&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;官方说推荐输入电压是6-20V，极限输入电压是7-12V。也就是说，电路板可以安全的接6-20V的外部电源，但是如果你低于7V或者超过12V就会出现问题，低的话电路会不稳，高的话稳压器会过热，会烧坏电路板的。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;当有电流瞬时保障时有什么保护措施么？&lt;/p&gt;
&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;目前，在板子上有一个可以防止USB瞬间电流过大的保护器，就是图中的自恢复保险丝。他可以防止USB带来的过流电流烧毁板子。至于DC的保护应该在变压器上做的吧？如果是直接接引脚的话，应该没有保护吧？这块还不太确定，等之后确定了再回来补充吧。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　最后，让我们再说说板子上的两个种端口，一个是模拟端口，一个是数字端口。数字端口中包括14个接口，模拟端口中包括5个接口。顾名思义，数字端口就是用来通信数字信号的，模拟端口就是通信模拟信号的，哈。&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;模拟信号和数字信号的区别是什么？&lt;/p&gt;
&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;如果你在百度直接搜索的话一定会找到类似“模拟信号：时间连续，幅值连续。数字信号：时间离散，幅值离散。”这样的回答。这样的回答真的是太抽象了，一点不适合人类的理解。根据我的学习，模拟信号就是真实世界物理物体振动产生的，人类为了记录这些信号起先是通过将这些振动转换在黑胶唱片上的（通过一些物理的手段，因为传递了振动，所以可以通过针刻在黑胶盘上），这种记录形式能够记录模拟信号。更多知识可以看看下边的参考文献。然而，因为技术的发展，通过更紧密的仪器慢慢的就能收集到更多的信号了，但是物理上很难找到极为精密的介质，所以科学家们将模拟信号转换成了数字信号，模拟信号通过采样，量化手段转换成了只有1和0来表示的信号，就叫做数字信号。希望我这么说大家能够明白了。具体里面的细节我可以以后再说，但这已经跟这个文章的主题没有关系了。
&lt;/code&gt;&lt;/pre&gt;

&lt;font color=&quot;red&quot;&gt;Q:&lt;/font&gt;
&lt;p&gt;那能说说这两个端口都是干什么的么？&lt;/p&gt;

&lt;font color=&quot;blue&quot;&gt;A:&lt;/font&gt;
&lt;pre&gt;&lt;code&gt;模拟端口（A1到A5）用来接收外部元件传过来的模拟信号的。数字端口中的（引脚3、5、6、9、10、11）即可以当数字信号输入输出，又可以当模拟信号的输出。其它引脚都可以输入输出。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　到这里，我们就对Arduino关键的元件进行了说明，Arduino有了大脑，心脏，动力，输入输出，就能够转起来了。&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.microchip.com/en-us/product/ATMEGA328P&quot;&gt;ATMEGA328P官方网站&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1gf4y1B7MK/&quot;&gt;全网第一份拆解无源晶振的视频，想知道晶振内部结构吗？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Do4y1f7zZ/&quot;&gt;一分钟看懂晶振的工作原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_40407893/article/details/100929676&quot;&gt;Arduino 解读系列（1）数字接口／模拟接口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/42466881&quot;&gt;黑胶唱片是如何录制声音的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="c,Arduino" /><summary type="html">　　Hello，大家好。2022春节前和同事聊天的时候聊到了硬件方面的知识，同事说他们大学的时候参加电子竞赛时用的是一款叫Arduino的板子进行开发的，他还说学校里组织的竞赛都是用的Arduino。我立刻起了兴趣，于是上网找了一些关于Arduino的文章，看完以后我的兴趣是越来越浓了。以前在写程序的时候一直想能够造一些东西出来，但是苦于自己的方向是后端，所以做出来的东西均是服务相关的产品。然而，Arduino一下子让我这名后端工程师豁然开朗，各种未来的黑科技在我脑中冒了出来，于是我打算深入了解一下Arduino啦。</summary></entry><entry><title type="html">《瞌睡虫学编程》第一集剧本</title><link href="http://localhost:4000/drama/2022/02/18/1.html" rel="alternate" type="text/html" title="《瞌睡虫学编程》第一集剧本" /><published>2022-02-18T00:00:00+08:00</published><updated>2022-02-18T00:00:00+08:00</updated><id>http://localhost:4000/drama/2022/02/18/1</id><content type="html" xml:base="http://localhost:4000/drama/2022/02/18/1.html">&lt;p&gt;时间：2022年2月18日
地点：
人物：
A：孙
B：帆&lt;/p&gt;

&lt;p&gt;一、地铁，车厢内&lt;/p&gt;

&lt;p&gt;1车厢外地铁进站，A入，排队。地铁呼啸而来，车门打开。
2车厢内A走进来，背过身抓好扶手，打开airpods，带上耳机
3近景侧脸，撩起头发，带上耳机。车厢内的嘈杂声褪去，想起悠扬的音乐
4兜里，掏出手机，打开
5快速搜索：“硬件学习   零基础”。点击第一个结果，展示
6全景A沉浸在看手机中经过一天的辛苦工作，她又打开手机开始查阅自己感兴趣的内容……7车厢外到站，走出车厢，坐电梯，刷卡8地铁站外A走出地铁站&lt;/p&gt;

&lt;p&gt;二、回家路上&lt;/p&gt;

&lt;p&gt;1进景天冷，搓搓手，呼口哈气，做出冷的表情，搓搓耳朵。
2远景等红灯，绿灯后，前行
3远景前行往旁边看去4进景卖吃的的地方5远景进去买一份晚饭老板，xxx怎么卖？&lt;/p&gt;

&lt;p&gt;三、家、卧室&lt;/p&gt;

&lt;p&gt;正常景吃的还完好的摆在桌上（场景四的位置！！）。电脑是开着的状态，google上还展示着搜索结果。A慢慢从从椅子上醒来。关机，站起来，走出。B：A睡觉啦!A:  来啦!&lt;/p&gt;

&lt;p&gt;四、家&lt;/p&gt;

&lt;p&gt;1厕所，外进厕所，开灯，关门，换衣服。厕所镜子上透出曼妙身材老公，帮我拿下睡衣好吗？
2书房，近景拿着食物，走到椅子旁近景放下食物（这块先拍！！！），按下电脑开关，启动电脑，吃东西电脑启动声音近景打开浏览器，输入google.com，搜索”arduino”（电脑鼠标从此不要再动）喊出，我要买一个arduino！近景arduino盒子砸在脑子上，掉在桌上arduino盒子在桌子上抽出，arduino，左右观察。喊老公，过来看看。
3正常景A单手拍，一手拿arduino，拍B走进来B：呦，你还懂这个那？A:嗯，可不是B拿过来，观察参看对话一&lt;/p&gt;

&lt;p&gt;对话一：
B：你知道Arduino是用来做什么的么？&lt;/p&gt;

&lt;p&gt;A：我只知道好像这东西能够控制不同的硬件。&lt;/p&gt;

&lt;p&gt;B:是的，你说的没错，但其实咱们现实中用到的设备其实大多数都是51单片机去实现的。arduino只是让你将编程和真正硬件效果能够有个直观感受用的。&lt;/p&gt;

&lt;p&gt;A:那我也能用它做出来点什么吧？&lt;/p&gt;

&lt;p&gt;B:嗯，当然能，现在它有好多配套的原件或者配套的模块可以购买。基本上什么都能做出来。&lt;/p&gt;

&lt;p&gt;A:你刚才说的51单片机是什么？&lt;/p&gt;

&lt;p&gt;B：哦，他是因特尔生产的一个芯片，51是8051的缩写，这个是芯片的型号。我再给你普及下知识吧。&lt;/p&gt;

&lt;p&gt;芯片是由电路板和集成电路组成的。电路板就是那些绿绿的板子，集成电路就是将电子器件按照一定工艺制造在一起，形成的具有一定功能的微型结构。&lt;/p&gt;

&lt;p&gt;A：那电子器件是什么？&lt;/p&gt;

&lt;p&gt;B：晶体管、电阻、电容和电感之类的。&lt;/p&gt;

&lt;p&gt;A：那arduino只是适合学习吧？&lt;/p&gt;

&lt;p&gt;B：是的，因为很多底层的东西arduino都帮助开发者封装了，开发者在学习的时候直接去用就行了，免去了自己花时间去了解背后的原理了。&lt;/p&gt;

&lt;p&gt;A: 这样说的话，是不是代表我可以快速上手呀？&lt;/p&gt;

&lt;p&gt;B：那是必须的，咱只需要下一个arduino IDE就行。他里面有各种示例，通过示例学习就行了。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="drama" /><category term="瞌睡虫学编程" /><summary type="html">时间：2022年2月18日 地点： 人物： A：孙 B：帆</summary></entry><entry><title type="html">Async和Transactional注解使用时的动态代理问题</title><link href="http://localhost:4000/tech/2021/12/11/01.html" rel="alternate" type="text/html" title="Async和Transactional注解使用时的动态代理问题" /><published>2021-12-11T00:00:00+08:00</published><updated>2021-12-11T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/12/11/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/12/11/01.html">&lt;blockquote&gt;
  &lt;p&gt;代理是指由被委托人接受委托人的委托全权去办理一件事情，在办理这件事情的过程中委托人会限制被委托人的行事边界。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哈喽 大家好，这次我想写一些关于我在工作中遇到的有关java动态代理问题的排查与解决，希望能够帮助自己总结的同时对网络上的其他小伙伴有些许的帮助。首先我要列举几个@Async和@Transactional的例子。&lt;/p&gt;

&lt;h1 id=&quot;transactional&quot;&gt;@Transactional&lt;/h1&gt;

&lt;p&gt;这种情况属于“自调用”的情况。自调用的意思就是通过CGLIB方式动态代理的方法，调用了类内其他方法。这种“自调用”的情况会使注解无效。具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class Galaxy {

    @Autowired
    private UserRepository userRepository;

    public void alpha(){
        beta();//这就是“自调用”：在Galaxy类内注解的方法内调用了同类内的其他方法。
    }

    //对beta()方法开启了事务
    @Transactional
    public void beta(){
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain(); //断点
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在beta()方法中打下断点，数据库中是没有事务的。说明注解没有生效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; select * from information_schema.innodb_trx \G;
Empty set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; select * from user;
+----+-------------+-----------+--------+
| id | account     | name      | pwd    |
+----+-------------+-----------+--------+
|  3 | zhouhuajina | 周华健    | 123456 |
|  4 | Jay zhou    | 周杰伦    | 123456 |
+----+-------------+-----------+--------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　通过断点时的堆栈信息，我们发现实际调用beta()的是&lt;code&gt; Galaxy$$EnhancerBySpringCGLIB$$76b76f24&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;beta:44, Galaxy (com.example.service.galaxy)
alpha:31, Galaxy (com.example.service.galaxy)
invoke:-1, Galaxy$$EnhancerBySpringCGLIB$$76b76f24 (com.example.service.galaxy)
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Galaxy\(EnhancerBySpringCGLIB\)76b76f24方法是通过cglib做动态代理时被jvm建立起来的一个虚拟的文件，这个文件是对Galxy类的增强类(GalxyEnhence)，增强类继承了Galaxy类并对注解的类进行方法增强。方法增强指的是你使用的那个注解会把相关代码（注解开发人员早已经写好了的代码）用重写的方式将你的代码增强起来。所以，这个被jvm虚拟出来的文件大概应该长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Galaxy$$EnhancerBySpringCGLIB$$76b76f24 extend Galaxy{
  
  		//因为beta方法被注解了，所以通过重写的方式增强这个方法。其他没有被注解的方法，不重写
     @Override
     public void beta(){
      try {
            // 开启事务
            startTransaction();
            UserDomain UserDomain = new UserDomain();
            UserDomain.setId(4L);
            UserDomain.setName(&quot;周杰伦&quot;);
            UserDomain.setAccount(&quot;Jay zhou&quot;);
            UserDomain.setPwd(&quot;123456&quot;);
            userRepository.save(UserDomain);
            UserDomain = new UserDomain();
            UserDomain.setId(3L);
            UserDomain.setName(&quot;周华健&quot;);
            UserDomain.setAccount(&quot;zhouhuajina&quot;);
            UserDomain.setPwd(&quot;123456&quot;);
            userRepository.save(UserDomain);
        } catch (Exception e) {
            // 出现异常回滚事务
            rollbackTransaction();
        }
        // 提交事务
        commitTransaction();
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这段代码出现了一个问题：&lt;code&gt;beta()的调用者是隐含的this&lt;/code&gt;。这就是“自调用”的意思，那实际的调用链是：Galaxy.alpha() =&amp;gt;  Galaxy.beta()。它没有走我们的增强类的beta()！所以就出现了刚才的结果。按照这种思路可以这样改：&lt;/p&gt;

&lt;h3 id=&quot;解决方案1利用transactional的传递性在总方法上加transactional&quot;&gt;解决方案1：利用@Transactional的传递性，在总方法上加@Transactional。&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class Galaxy {

    @Autowired
    private UserRepository userRepository;

    //解决方案1：将注解加到alpha上。
    //借助@transactional的传递性，会把beta()也加到事务里来。
  	@Transactional
    public void alpha(){
        beta();
    }
  
    public void beta(){
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain(); //断点
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在beta()方法中打下断点，数据库中出现了事务，说明起效了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;mysql&amp;gt; select * from information_schema.innodb_trx \G;
*************************** 1. row ***************************
                    trx_id: 422025326292896
                 trx_state: RUNNING
               trx_started: 2021-12-12 21:54:14
     trx_requested_lock_id: NULL
          trx_wait_started: NULL
                trx_weight: 0
       trx_mysql_thread_id: 6022
                 trx_query: NULL
       trx_operation_state: NULL
         trx_tables_in_use: 0
         trx_tables_locked: 0
          trx_lock_structs: 0
     trx_lock_memory_bytes: 1128
           trx_rows_locked: 0
         trx_rows_modified: 0
   trx_concurrency_tickets: 0
       trx_isolation_level: REPEATABLE READ
         trx_unique_checks: 1
    trx_foreign_key_checks: 1
trx_last_foreign_key_error: NULL
 trx_adaptive_hash_latched: 0
 trx_adaptive_hash_timeout: 0
          trx_is_read_only: 0
trx_autocommit_non_locking: 0
       trx_schedule_weight: NULL
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用链为：Galaxy\(EnhancerBySpringCGLIB\)76b76f24.alpha()=&amp;gt; Galaxy\(EnhancerBySpringCGLIB\)76b76f24.beta()&lt;/p&gt;

&lt;h3 id=&quot;解决方案2在被代理类的外部调用其方法&quot;&gt;解决方案2：在被代理类的外部调用其方法。&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// Galaxy.java
@Service
public class Galaxy {

    @Autowired
    private UserService userService;

    public void alpha(){
        userService.beta();//调用者换成了外部类userService。
    }
}

//UserService.java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    //将注解放到这里。
    @Transactional
    public void beta(){
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain();  //断点
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用链为：Galaxy.alpha =&amp;gt; UserService.beta()。这其实不能算是一种解决方案，而是一种解决思路。&lt;/p&gt;

&lt;h3 id=&quot;解决方案3自注入&quot;&gt;解决方案3：自注入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class Galaxy {

  	//注解自己进入spring容器里。
  	@Autowired
  	private Galaxy galaxy
      
    @Autowired
    private UserRepository userRepository;
  	
    public void alpha(){
        galaxy.beta();  //beta()的调用者换成了galaxy类，就可以让spring直接从容器里拿增强类。
    }
  
    @Transactional
    public void beta(){
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain(); //断点
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　调用链为：Galaxy.alpha()=&amp;gt;Galaxy\(EnhancerBySpringCGLIB\)76b76f24.beta()&lt;/p&gt;

&lt;h1 id=&quot;async-和-transactional&quot;&gt;@Async 和 @Transactional&lt;/h1&gt;

&lt;p&gt;看下面的列子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class Galaxy {

    @Autowired
    private UserRepository userRepository;

    @Transactional(rollbackFor = Exception.class)
    public void alpha() throws Exception{
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain();
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        beta();
    }

    @Async(value = &quot;beta&quot;)
    public void beta() throws InterruptedException {
        Thread.sleep(3000);
        System.out.println(&quot;这是beta线程&quot;); //断点
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这个例子的意图是：alpha方法首先入库数据，然后调用异步方法beta。预期的效果应该是，alpha()直接插入数据，立刻退出。不会等到beta()中的数据输出。但是，实际情况却是alpha()在等待beta()3秒后，输出beta线程文案后退出。这意味着beta()上的@Async没有起效。&lt;/p&gt;

&lt;p&gt;我在beta()中打了个断点，让我们看看当时的堆栈是什么情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;beta:47, Galaxy (com.example.service.galaxy)
alpha:41, Galaxy (com.example.service.galaxy)
。。。。。
alpha:-1, Galaxy$$EnhancerBySpringCGLIB$$d543df13 (com.example.service.galaxy)
。。。。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照刚才的理论来讲，应该是jvm制造出来了一个增强类叫&lt;code&gt; Galaxy$$EnhancerBySpringCGLIB$$d543df13&lt;/code&gt;，这个类继承了Galaxy类并且重写了alpha()和beta()。调用链应该是： Galaxy\(EnhancerBySpringCGLIB\)d543df13.alpha() =&amp;gt; Galaxy.beta()。因为调用的是Galaxy.beta()而不是 Galaxy\(EnhancerBySpringCGLIB\)d543df13.beta()，所以@Async没有生效。&lt;/p&gt;

&lt;p&gt;　　但是，按照上面解决方案2来重新构造代码发现@Async仍然没有生效，这就有些矛盾了。通过搜索找到了这篇&lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/11806&quot;&gt;issue&lt;/a&gt;。根据文中所述，是@Async和@Transactional的order先后的顺序导致了这个问题。因为spring开发者认为@Async的顺序应该是最优先的，所以即使@Async和@Transactional放在了一起，也会是先实现异步再进行事务。那接下来让我们试一试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Galaxy.java
@Service
public class Galaxy {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

  //1.先异步线程
    @Async(value = &quot;alpha&quot;)
    public void alpha() throws Exception{
        System.out.println(&quot;alpha thread start&quot;);
        userService.beta(); //2.进入事务中
        System.out.println(&quot;alpha thread end&quot;);
        userService.gamma(); //3.抛出异常，回滚
    }
}


//UserService.java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    @Transactional(rollbackFor = Exception.class)
    public void beta() throws Exception{
        System.out.println(&quot;这是beta线程&quot;);
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain();
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }

    public void gamma() throws Exception {
        throw new Exception();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　最终结果，符合预期，数据库里的数据被回滚了。然后再试一次两个注解在一起的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Galaxy.java
@Service
public class Galaxy {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserService userService;

  //1.先异步线程
    @Async(value = &quot;alpha&quot;)
    @Transactional(rollbackFor = Exception.class)
    public void alpha() throws Exception{
        System.out.println(&quot;alpha thread start&quot;);
        userService.beta(); //2.进入事务中
        System.out.println(&quot;alpha thread end&quot;);
        userService.gamma(); //3.抛出异常，回滚
    }
}


//UserService.java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public void beta() throws Exception{
        System.out.println(&quot;这是beta线程&quot;);
        UserDomain UserDomain = new UserDomain();
        UserDomain.setId(4L);
        UserDomain.setName(&quot;周杰伦&quot;);
        UserDomain.setAccount(&quot;Jay zhou&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
        UserDomain = new UserDomain();
        UserDomain.setId(3L);
        UserDomain.setName(&quot;周华健&quot;);
        UserDomain.setAccount(&quot;zhouhuajina&quot;);
        UserDomain.setPwd(&quot;123456&quot;);
        userRepository.save(UserDomain);
    }

    public void gamma() throws Exception {
        throw new Exception();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　最终，也符合预期。最后，至于注解的时序原理等我有时间研究一下再写出来。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">代理是指由被委托人接受委托人的委托全权去办理一件事情，在办理这件事情的过程中委托人会限制被委托人的行事边界。</summary></entry><entry><title type="html">聊聊我使用ffmpeg时总结的最佳实践</title><link href="http://localhost:4000/tech/2021/11/25/01.html" rel="alternate" type="text/html" title="聊聊我使用ffmpeg时总结的最佳实践" /><published>2021-11-25T00:00:00+08:00</published><updated>2021-11-25T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/11/25/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/11/25/01.html">&lt;blockquote&gt;
  &lt;p&gt;FFmpeg is the leading multimedia framework, able to &lt;strong&gt;decode&lt;/strong&gt;, &lt;strong&gt;encode&lt;/strong&gt;, &lt;strong&gt;transcode&lt;/strong&gt;, &lt;strong&gt;mux&lt;/strong&gt;, &lt;strong&gt;demux&lt;/strong&gt;, &lt;strong&gt;stream&lt;/strong&gt;, &lt;strong&gt;filter&lt;/strong&gt; and &lt;strong&gt;play&lt;/strong&gt; pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation. It is also highly portable: FFmpeg compiles, runs, and passes our testing infrastructure &lt;a href=&quot;http://fate.ffmpeg.org/&quot;&gt;FATE&lt;/a&gt; across Linux, Mac OS X, Microsoft Windows, the BSDs, Solaris, etc. under a wide variety of build environments, machine architectures, and configurations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;部门的项目涉及到视频处理的功能，公司里负责存储服务的同学并没有这方面的能力支持（虽然他们也正在建设此方面的能力，因为公司内部需要视频处理的业务越来越多了。），所以我们只能硬着头皮开搞ffmpeg。曾经在看游戏的时候短暂的接触过半年多ffmpeg，但那个时候解决问题的能力不足，靠别人帮助的情况比较多。这么多年过去了，自己在开发领域的驾轻就熟，让我有了底气接了这摊子事儿。那么接下来我就总结下这几个月对ffmpeg的学习和使用吧。&lt;/p&gt;

&lt;h1 id=&quot;一框架选择---jave&quot;&gt;一、框架选择 - jave&lt;/h1&gt;

&lt;p&gt;　　项目是java的项目，借助github和google，了解到目前处理ffmpeg的框架最好用的是一个叫做&lt;a href=&quot;https://github.com/a-schild/jave2&quot;&gt;jave&lt;/a&gt;的开源项目。jave其实就是一个对ffmpeg包装的java库。目前jave的版本已经发展到了3.2.0，只需要在项目中引用jave-all-deps即可，他包括了jave-core和不同平台的ffmpeg脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;ws.schild&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jave-all-deps&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们公司的maven库的阿里镜像源超时的原因（那个时候找不到人来解决这个问题。），导致我用不到3.2.0版本的jave，我能获取到最新的版本就是2.7.3。这就导致了我在使用2.7.3时发现了问题去github上提&lt;a href=&quot;https://github.com/a-schild/jave2/issues/160&quot;&gt;concat mp4 not working properly. version 2.7.3 &lt;/a&gt;，开发者明确表示他没有资源去解决老版本的问题。反正，经过各种方面的努力，我也找到了我们公司管理maven库的同学，在他的帮助下我可以获取到3.2.0版本的jave了。但是，jave框架在视频拼接的处理上做的实在够差，我提了很多类似拼接的issue，比如&lt;a href=&quot;https://github.com/a-schild/jave2/issues/166&quot;&gt;The ffmpeg version included in 2.7.3 is a vry old one, which might cause the issue. &lt;/a&gt;。开发者在我的追问下已经不再回答我了。还有一次给他提了一个多个视频拼接时监控代码会报NPE问题的issue，&lt;a href=&quot;https://github.com/a-schild/jave2/issues/178&quot;&gt;when lots of videos to concat . EncoderProgressListernr get a NPE Exception&lt;/a&gt;，感觉开发者实在忙不过来了，转而求助我对此框架的修复。&lt;/p&gt;

&lt;p&gt;　　最终，拼接视频的代码我自己写了。格式转换的用了jave的。总的来说，jave可以帮助门外汉快速上手，因为我们可以通过看他的代码一步一步了解他封装ffmpeg时使用的方法以及他在遇到不同操作情况时是采用的什么方案。但是，当你慢慢了解ffmpeg的时候，jave框架会因为他的封装不够扩展而让开发举步维艰。&lt;/p&gt;

&lt;p&gt;　　当对ffmpeg有了一些最基本的了解后，ffmpeg官方网站（https://ffmpeg.org）就成为了进阶时最信得过的锦囊宝典。&lt;/p&gt;

&lt;h1 id=&quot;二ffmpeg官网&quot;&gt;二、FFmpeg官网&lt;/h1&gt;

&lt;p&gt;　　FFmpeg官网的左边栏，我们可以下载到ffmpeg最新的命令行。通过Documentation我们可以实时查看目前现有的所有功能，因为这个页面每晚都会重新生成。里面最常用的就是“&lt;strong&gt;Command Line Tools Documentation&lt;/strong&gt;”和“&lt;strong&gt;Components Documentation&lt;/strong&gt;”还有“&lt;strong&gt;General Documentation&lt;/strong&gt;”。&lt;/p&gt;

&lt;p&gt;　　官网同时还提供了IRC和MAIL等联系方式，IRC的频道是#ffmpeg 和 #ffmpeg-devel。两个频道分别面向的是使用者和开发者。我曾经在使用ffmpeg发生各种问题时进到IRC的频道里去寻求帮助，虽然里面会有4百多位处在挂机状态，但不时还是会有一些人进行交流的。我总得看下来，感觉里面说的东西都是C方面的问题，别的问题感觉里面的人不太感兴趣。我就因为又一次遇到了问题在里面提问了，确实有人回应我了，人家要我给出命令行以及错误堆栈。在IRC中你不能直接贴出来代码，需要一些专门托管代码片段的网站专门来制作代码片段连接，这一点有点让我觉得麻烦，可是又没别的好办法。等过了一会我把连接贴出来后，就没人再回应了。总体来说，体验很差，浪费了自己很多宝贵时间。我建议后来的人还是不要在IRC上浪费时间了。&lt;/p&gt;

&lt;h1 id=&quot;三音视频流的概念&quot;&gt;三、音视频流的概念&lt;/h1&gt;

&lt;p&gt;让我们先看一个视频的详细信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffprobe 1_1637395707\&amp;amp;88966_1637395335_1637395635.mp4 -hide_banner
[aac @ 0x7f846a808600] Input buffer exhausted before END element found
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from '1_1637395707&amp;amp;88966_1637395335_1637395635.mp4':
  Metadata:
    major_brand     : mp42
    minor_version   : 0
    compatible_brands: isommp42
    creation_time   : 2021-11-20T08:07:16.000000Z
    com.android.version: 9
  Duration: 00:04:59.78, start: 0.000000, bitrate: 575 kb/s
  Stream #0:0(eng): Video: h264 (Constrained Baseline) (avc1 / 0x31637661), yuv420p, 1280x720, 478 kb/s, SAR 1:1 DAR 16:9, 6.15 fps, 90k tbr, 90k tbn, 180k tbc (default)
   Metadata:
     creation_time   : 2021-11-20T08:07:16.000000Z
     handler_name    : VideoHandle
     vendor_id       : [0][0][0][0]
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 96 kb/s (default)
    Metadata:
      creation_time   : 2021-11-20T08:07:16.000000Z
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　视频一共有三种流：音频流，视频流，字幕流。我建议还是去看看FFmpeg官网对这几种结构的解释，介绍的挺全的，比我写的强多了。&lt;/p&gt;

&lt;p&gt;　　一般来说一个视频会有一个视频流和多个音频流及多个字幕流。他们的顺序安排按照约定俗成的顺序是第一个是视频流，对应着Stream #0:0；第二个及多个是音频流，对应着Stream#0:1，字幕流按此规则依次展开（当然，在我做ffmpeg的时候，经历过audio和video反了的情况，这种反了情况如果不去做处理ffmpeg其实会智能帮助挑选的，但是在某些时候就会报错失败。所以建议还是按照这个顺序来）。所以，我们可以从上面的代码片段中看到1_1637395707\&amp;amp;88966_1637395335_1637395635.mp4这个mp4文件包含以下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视频持续时间 00:04:59.78，开始时间是0.000000，码率是575kb/s&lt;/li&gt;
  &lt;li&gt;#0:0是视频流（Video），h264编码，profile等级为baseline,视频格式是yuv420p，分辨率1280*720，平均码率478kb/s，帧率 6.15fps，时间基线 90k。（我列举出来的这几个是挺重要的参数，其他参数我还没有太明白）&lt;/li&gt;
  &lt;li&gt;#0:1是音频流（Audio）,aac编码，采样率16000Hz，单声道，码率96kb/s&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;四concat&quot;&gt;四、concat&lt;/h1&gt;

&lt;p&gt;　　　拼接的意思就是，将两段或者多段音视频片段拼接成一个完整的音视频。ffmpeg官网&lt;a href=&quot;https://ffmpeg.org/faq.html#How-can-I-concatenate-video-files_003f&quot;&gt;指出&lt;/a&gt;，根据不同的情况，有多种方案可以进行选择。&lt;/p&gt;

&lt;h2 id=&quot;1拼接的3种方案&quot;&gt;1、拼接的3种方案&lt;/h2&gt;

&lt;h3 id=&quot;1concat-filter&quot;&gt;（1）concat filter&lt;/h3&gt;

&lt;p&gt;过滤器法适用于同步视频和音频流的片段，每个视频段都必须具有相同数量的流（包括类型），而且最终输出的视频也会按照这个顺序进行合并。这种方法会对视频进行重新编码，速度慢，耗cpu和内存。&lt;/p&gt;

&lt;p&gt;因为有些流不一定会和别的流的时间一致，举例来说一段视频有1个视频流和2个音频流，其中有一个音频流长度很短。那么这个方法就会按照这个视频最长时间的那个流为基准，其他流就会填补上静音。手册里明确说明最后一个视频不能这样。&lt;/p&gt;

&lt;p&gt;　　如果想让合并如预期那样工作，一定要保证所有视频片段的时间戳都是从0开始的。否则会出现，画面和声音不同步的情况。&lt;/p&gt;

&lt;p&gt;合并的时候还会遇到不同视频片段中有不同类型，不同采样率，不同通道的音频流。FFmpeg会自动的选择一个值来进行处理。另外，还有一些值是不能被FFmpeg自动填充的。还是需要人为的指定。另外，如果每段视频片段拥有不同的帧率，我们在最终结果视频制作时一定要设定个值，否则制作出来的视频就会按照每段自己的帧率进行合并了，这样的结果就是视频卡顿。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffmpeg -i opening.mkv -i episode.mkv -i ending.mkv -filter_complex \
  '[0:0] [0:1] [0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2]
   concat=n=3:v=1:a=2 [v] [a1] [a2]' \
  -map '[v]' -map '[a1]' -map '[a2]' output.mkv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个bash脚本的具体意思，怎么使。我看到了一篇CSDN上的文章，直接在这里做个&lt;a href=&quot;https://blog.csdn.net/xiaoluer/article/details/81136478&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2demuxer&quot;&gt;（2）demuxer&lt;/h3&gt;

&lt;p&gt;　　当我们的视频文件不支持文件级别的拼接并且我们想要避免重新编译，就应该采用这种方案。&lt;/p&gt;

&lt;p&gt;　　这种方案，通过读取一个文件里面的视频，将他们一个一个进行拼接。这些视频片段的时间都会被重新调整，第一个视频的开始时间调整为0，后面的视频等待前一个文件拼接完毕再进行拼接。如果他们的流时间长短不一，就会在他们之间产生间隙。&lt;/p&gt;

&lt;p&gt;　　如果他们的duration不同，那就会产生伪影（这个伪影，是翻译软件的翻译，我出现过这个问题，形象讲就是还在说话但是画面不动了。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 文件名为file，内容为
file '/mnt/share/file-1.mp4'
file '/mnt/share/file 2.mp4'
file '/mnt/share/file 3.mp4'

# ffmpg -y -f concat -i file  output.mp4 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3protocol&quot;&gt;（3）protocol&lt;/h3&gt;

&lt;p&gt;物理上进行拼接的方案，这个方案支持文件级拼接，也是最快的方案。一定要保证拼接的视频文件格式都一样。我最终就是选择用这个方案来进行拼接的，因为这种方案更稳定，更高效。（当然，如果你每个文件都不一样的结构，那这个方案就不行。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bas&quot;&gt;# ffmpeg -y -i &quot;concat:a.mp4|b.mp4&quot; output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2拼接时我遇到的各种问题&quot;&gt;2、拼接时我遇到的各种问题&lt;/h2&gt;

&lt;h4 id=&quot;1-channel-element-10-is-not-allocated&quot;&gt;（1） channel element 1.0 is not allocated&lt;/h4&gt;

&lt;p&gt;在采用demuxer拼接方案时，遇到了这个错误。错误的根本原因是拼接的视频文件中的流顺序和第一个文件的流顺序不一致导致的。&lt;/p&gt;

&lt;p&gt;　　demuxer的方案，是以第一个文件作为基准的。如果第一个视频的流顺序 #0:0是video，#0:1是audio，那么后面的所有视频文件的流顺序也得是 #0:0是video，#0:1是audio。这种情况是很可能发生的，因为你的输入可能是别人给你的，别人在操作视频的时候因为个人的疏忽或者经验缺失，有可能在制作的过程中将这种顺序弄混。如果你真遇到了这种情况，通过下面的命令，就能将顺序调整成第一个流是video,第二个流是audio。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffmpeg -i input.mp4 -y output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2non-monotonous-dts-in-output-stream-01-previous-3277744-current-3276712-changing-to-3277745-this-may-result-in-incorrect-timestamps-in-the-output-file&quot;&gt;（2）Non-monotonous DTS in output stream 0:1; previous: 3277744, current: 3276712; changing to 3277745. This may result in incorrect timestamps in the output file.&lt;/h4&gt;

&lt;p&gt;首先需要了解一下DTS和PTS是什么意思。简单说，PTS就是这一帧应该在什么时候显示，DTS就是这一帧应该在什么时候进行解码。所以，这个问题是有关于帧的时间的报错。我们可以通过以下三篇文章了解到更多。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fanyun_01/article/details/89608876&quot;&gt;《DTS和PTS的解释》&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/linyilong3/p/9940230.html&quot;&gt;《图解DTS和PTS》&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/qingquan/archive/2011/07/27/2118967.html&quot;&gt;《I,P，B帧和PTS，DTS的关系》&lt;/a&gt;]&lt;/p&gt;

&lt;p&gt;想要理解DTS和PTS还要知道I、B、P帧的概念。上面那篇《图解DTS和PTS》中的图片表达的很清楚了。为了解决数据存储问题在I帧和P帧的基础上增加了B帧的概念。有了B帧以后才又有了DTS的概念，因为B帧和P帧的组合可以用更少的存储量表示出同样数量的I帧的画面。我们可以看到图中的B帧只有小人的身体，B帧通过把I帧没有移动的背景和P帧中运动的小人整合起来，通过DTS来控制实际解压出来的画面顺序：I &amp;gt;P&amp;gt;B，这样就达到了同样是看了3个画面但实际存储量远小于3个I帧的数据量。注意，每帧蓝色的背景表示的就是实际节省下来的数据量。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08c4b0f98c0610a3e11d18f4082092032801300138a168.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;IBP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　然后，我们得再了解下采样率是什么，有什么用途。我百度了很多关于采样率的文章，感觉大家都在抄互相的东西，让人看的一头雾水。&lt;/p&gt;

&lt;p&gt;首先要确定一点，采样率的意义是模拟信号转成数字信号时的参考。因为根据Nyquist和Shannon定理指出，当采样率大于被采信号最大频率的两倍时才能无损的重建原始的模拟信号。如果采样率低的话，就无法从采样信号中重建，或者可能产生混叠的现象。采样率实际上表明了采集的频率，单位是KHZ，意思就是每秒做了1000次采集。例如：音频CD的采样率是44.1khz，这意味着模拟信号每秒采样44100次，就能在数字信号中还原模拟信号。更多内容可以参考这个&lt;a href=&quot;https://www.sweetwater.com/insync/7-things-about-sample-rate/&quot;&gt;《7 Questions About Sample Rate》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　所以，问题的关键就是让各文件的采样率一致了。就是因为各文件的采样率不一致导致的，拼接视频时解码的时间3277744之后应该是3277745，但突然变小了 3276712就出现了问题。&lt;/p&gt;

&lt;h4 id=&quot;3多个mp4文件拼接不成功---found-duplicated-moov-atomfound-duplicated-moov-atom&quot;&gt;（3）多个mp4文件拼接不成功 - Found duplicated MOOV Atom.Found duplicated MOOV Atom.&lt;/h4&gt;

&lt;p&gt;如果想直接拼接的话，采用concat protocol的方案，最终拼接出来的mp4和第一个视频一模一样。以下两个视频均是同样设备和参数采集的视频a.mp4和b.mp4。两个mp4拼接出来的视频为abd.mp4&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffprobe a.mp4 -hide_banner
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'a.mp4':
  Metadata:
    major_brand     : isom
    minor_version   : 512
    compatible_brands: isomiso2avc1mp41
    encoder         : Lavf59.4.101
  Duration: 00:04:59.78, start: 0.000000, bitrate: 680 kb/s
  Stream #0:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x720 [SAR 1:1 DAR 16:9], 607 kb/s, 6.15 fps, 6.15 tbr, 82935000.00 tbn, 12.31 tbc (default)
    Metadata:
      handler_name    : VideoHandle
      vendor_id       : [0][0][0][0]
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 71 kb/s (default)
    Metadata:
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]
      
      
# ffprobe b.mp4 -hide_banner
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'b.mp4':
  Metadata:
    major_brand     : isom
    minor_version   : 512
    compatible_brands: isomiso2avc1mp41
    encoder         : Lavf59.4.101
  Duration: 00:04:59.20, start: 0.000000, bitrate: 653 kb/s
  Stream #0:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x720 [SAR 1:1 DAR 16:9], 582 kb/s, 4.08 fps, 4.08 tbr, 13713750.00 tbn, 8.16 tbc (default)
    Metadata:
      handler_name    : VideoHandle
      vendor_id       : [0][0][0][0]
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 70 kb/s (default)
    Metadata:
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]
      
# ffmpeg -y -i &quot;concat:a.mp4|b.mp4&quot; abd.mp4
[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7f9575c0fa40] Found duplicated MOOV Atom. Skipped it
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'concat:a.mp4|b.mp4':
  Metadata:
    encoder         : Lavf59.4.101
    major_brand     : isom
    minor_version   : 512
    compatible_brands: isomiso2avc1mp41
  Duration: 00:04:59.78, start: 0.000000, bitrate: 1332 kb/s
  Stream #0:0(eng): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x720 [SAR 1:1 DAR 16:9], 607 kb/s, 6.15 fps, 6.15 tbr, 82935000.00 tbn (default)
    Metadata:
      handler_name    : VideoHandle
      vendor_id       : [0][0][0][0]
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 71 kb/s (default)
    Metadata:
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]
Stream mapping:
  Stream #0:0 -&amp;gt; #0:0 (h264 (native) -&amp;gt; h264 (libx264))
  Stream #0:1 -&amp;gt; #0:1 (aac (native) -&amp;gt; aac (native))
Press [q] to stop, [?] for help
[libx264 @ 0x7f95768062c0] using SAR=1/1
[libx264 @ 0x7f95768062c0] using cpu capabilities: MMX2 SSE2Fast SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2
[libx264 @ 0x7f95768062c0] profile High, level 3.1, 4:2:0, 8-bit
[libx264 @ 0x7f95768062c0] 264 - core 164 r3065 ae03d92 - H.264/MPEG-4 AVC codec - Copyleft 2003-2021 - http://www.videolan.org/x264.html - options: cabac=1 ref=3 deblock=1:0:0 analyse=0x3:0x113 me=hex subme=7 psy=1 psy_rd=1.00:0.00 mixed_ref=1 me_range=16 chroma_me=1 trellis=1 8x8dct=1 cqm=0 deadzone=21,11 fast_pskip=1 chroma_qp_offset=-2 threads=18 lookahead_threads=3 sliced_threads=0 nr=0 decimate=1 interlaced=0 bluray_compat=0 constrained_intra=0 bframes=3 b_pyramid=2 b_adapt=1 b_bias=0 direct=1 weightb=1 open_gop=0 weightp=2 keyint=250 keyint_min=6 scenecut=40 intra_refresh=0 rc_lookahead=40 rc=crf mbtree=1 crf=23.0 qcomp=0.60 qpmin=0 qpmax=69 qpstep=4 ip_ratio=1.40 aq=1:1.00
Output #0, mp4, to 'abd.mp4':
  Metadata:
    compatible_brands: isomiso2avc1mp41
    major_brand     : isom
    minor_version   : 512
    encoder         : Lavf59.4.101
  Stream #0:0(eng): Video: h264 (avc1 / 0x31637661), yuv420p(progressive), 1280x720 [SAR 1:1 DAR 16:9], q=2-31, 6.15 fps, 82935000.00 tbn (default)
    Metadata:
      handler_name    : VideoHandle
      vendor_id       : [0][0][0][0]
      encoder         : Lavc59.3.102 libx264
    Side data:
      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 69 kb/s (default)
    Metadata:
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]
      encoder         : Lavc59.3.102 aac
frame= 1843 fps=191 q=-1.0 Lsize=   23688kB time=00:04:59.84 bitrate= 647.2kbits/s speed=31.1x
video:20986kB audio:2629kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: 0.311686%
[libx264 @ 0x7f95768062c0] frame I:8     Avg QP:11.52  size:147506
[libx264 @ 0x7f95768062c0] frame P:747   Avg QP:16.26  size: 20112
[libx264 @ 0x7f95768062c0] frame B:1088  Avg QP:22.94  size:  4858
[libx264 @ 0x7f95768062c0] consecutive B-frames: 17.1%  9.7%  8.3% 64.9%
[libx264 @ 0x7f95768062c0] mb I  I16..4: 16.2% 26.1% 57.7%
[libx264 @ 0x7f95768062c0] mb P  I16..4:  1.4%  2.4%  1.6%  P16..4: 19.9%  5.1%  3.8%  0.0%  0.0%    skip:65.9%
[libx264 @ 0x7f95768062c0] mb B  I16..4:  0.1%  0.3%  0.2%  B16..8: 19.3%  2.8%  1.0%  direct: 0.9%  skip:75.3%  L0:52.0% L1:40.5% BI: 7.5%
[libx264 @ 0x7f95768062c0] 8x8 transform intra:41.5% inter:26.0%
[libx264 @ 0x7f95768062c0] coded y,uvDC,uvAC intra: 62.9% 46.9% 24.0% inter: 8.0% 4.5% 0.2%
[libx264 @ 0x7f95768062c0] i16 v,h,dc,p: 15% 24% 13% 47%
[libx264 @ 0x7f95768062c0] i8 v,h,dc,ddl,ddr,vr,hd,vl,hu: 28% 25% 19%  4%  4%  5%  5%  5%  6%
[libx264 @ 0x7f95768062c0] i4 v,h,dc,ddl,ddr,vr,hd,vl,hu: 26% 21% 13%  6%  7%  7%  7%  6%  7%
[libx264 @ 0x7f95768062c0] i8c dc,h,v,p: 51% 19% 21%  8%
[libx264 @ 0x7f95768062c0] Weighted P-Frames: Y:0.0% UV:0.0%
[libx264 @ 0x7f95768062c0] ref P L0: 77.2%  8.7% 10.2%  3.9%
[libx264 @ 0x7f95768062c0] ref B L0: 91.6%  6.8%  1.6%
[libx264 @ 0x7f95768062c0] ref B L1: 97.3%  2.7%
[libx264 @ 0x7f95768062c0] kb/s:573.94
[aac @ 0x7f9576807680] Qavg: 20877.602
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们注意，其中有个报错是&lt;code&gt;Found duplicated MOOV Atom.&lt;/code&gt; ，MOOV Atom是个什么东西呢？我们可以参考这篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88196225&quot;&gt;理解 MPEG 的 moov atom&lt;/a&gt;，通过这篇文章我们了解到mp4是个封装容器，一个视频文件只能有一个MOOV Atom，现在两个mp4文件要进行拼接，就会有两个MOOV Atom。所以，ffmpeg就会选择第一个文件作为最终文件直接输出出来，而后面的都会选择跳过。&lt;/p&gt;

&lt;p&gt;所以，想用concat方法直接去拼接mp4文件的想法应该立刻停止。我们可以选择其他方案继续进行，比如ts类型文件就是少数可以这么做的类型之一。ts文件是在DVD标准上存储的视频流文件。它使用的是标准的MPEG-2（.MPEG）来压缩视频数据。我们只需要记住ts文件主要存储的是流媒体，流媒体可以直接拼。&lt;/p&gt;

&lt;p&gt;　　最后，我的方案就是：先转成ts文件，然后再按照concat protocol拼接起来。完美，perfect。此种方法耗费cpu资源和少量内存资源。可以说，是最佳方案，而且健壮性很强。我为什么说健壮性很强呢，因为下面的问题。&lt;/p&gt;

&lt;h4 id=&quot;4使用filter方案无缘无故的停止ffmpeg线程&quot;&gt;（4）使用filter方案，无缘无故的停止ffmpeg线程&lt;/h4&gt;

&lt;p&gt;之前，我拼接时采用的方案是filter，功能一切正常，直到有一天系统拼接失败数量直线上升，我立刻进行排查。我发现了好多源视频都没有声音，后来跟端上的同学询问，可能是端上加载别的sdk导致音频流丢失了，这就导致了我的拼接系统拼不出来了。因为filter方案，是需要自己map每个视频的声音和视频流的，如果音频流没了的话就会造成意想不到的错误。&lt;/p&gt;

&lt;h4 id=&quot;5could-not-find-codec-parameters-for-stream-0--xxxx-consider-increasing-the-value-for-the-analyzeduration-and-probesize-options&quot;&gt;（5）Could not find codec parameters for stream 0  XXXX Consider increasing the value for the ‘analyzeduration’ and ‘probesize’ options&lt;/h4&gt;

&lt;p&gt;　　ffmpeg在avformat_find_stream_info中会读取一部分源文件的音视频数据，来分析文件信息。其中有两个参数来控制：probesize和analyzeduration。该函数的作用是通过读取一定时间内或一定长度内的字节码流数据来分析码流的基本信息。比如编码信息，时长，码率，帧率等等。如果这两个值设置的过小就会增加此函数的耗时，严重的可能会导致读取数据量不足，从而无法解析出来关键信息。这样就会导致播放失败或者有音频没有视频，有视频没有音频的问题。&lt;/p&gt;

&lt;p&gt;我就是因为没有设置这两个值，端上采集的视频由于电视的cpu持续飙高，视频中的关键信息被延迟写入到视频内，我的ffmpeg以默认的值去读取视频而没有获取到关键信息，最终拼接出来的视频有声音但是没有图像。&lt;/p&gt;

&lt;h1 id=&quot;五anullsrc空源&quot;&gt;五、ANULLSRC（空源）&lt;/h1&gt;

&lt;p&gt;我需要做一个黑屏没有声音的视频放在拼接视频的最前面，通过查询ffmpeg的手册。用以下方法能够制作出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffmpeg -f lavfi -i color=size=1280x720:rate=25:color=black -f lavfi -i anullsrc=channel_layout=mono:sample_rate=16000 \
# -metadata:s:a:0 language=eng -metadata:s:v:0 language=eng \
# -video_track_timescale 12800k \
# -vcodec h264-acodec aac  \
# -threads 1 -t 30 \
# -y abc.mp4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这里面有几个参数我需要说明下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-f lavfi 代表输入是一个虚拟输入源。-i 后面的就是这个是什么样的输入源&lt;/li&gt;
  &lt;li&gt;Language = eng 代表的是元数据中视频或者音频的stream是英文。&lt;/li&gt;
  &lt;li&gt;-video_track_timescale 设置视频tbn，tbn是容器的时间基准。经过测试，他的作用是如果设置的过大视频就会以几倍速的速度快速播放。如果设置的小就会以原来的几分之一的速度播放。最终，会造成和音频流不同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　因为，空源视频是放在所有视频之前的，所以tbn这个值一定要设置好。因为后面的所有视频都以它为基准进行拼接。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="ffmpeg" /><summary type="html">FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation. It is also highly portable: FFmpeg compiles, runs, and passes our testing infrastructure FATE across Linux, Mac OS X, Microsoft Windows, the BSDs, Solaris, etc. under a wide variety of build environments, machine architectures, and configurations.</summary></entry><entry><title type="html">借助DDD思想，实践出质量检测系统</title><link href="http://localhost:4000/tech/2021/09/12/01.html" rel="alternate" type="text/html" title="借助DDD思想，实践出质量检测系统" /><published>2021-09-12T00:00:00+08:00</published><updated>2021-09-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/09/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/09/12/01.html">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;DDD 是 Domain-Driven Design 的缩写。&lt;/strong&gt;其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散沙，无法继续演进。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;　　大屏项目借助链家门店中的终端设备（比如电视，pad等），构建智慧门店各场景的解决方案，助力门店业务发展。同时，协同交易签约场景打造居住服务中心智慧标杆，提供全新体验并优化签约流程。&lt;/p&gt;

&lt;p&gt;　　我们希望借助大屏深挖签约过程中更有价值的需求点，比如在签约过程中会录音录像（经过客业双方授权）。我们借助录制的视频可以保存下来作为客业（客户业主）双方斡旋时的证据，也能联合内部AI能力借助ASR转化来检测签约经理在服务环节中的关键讲解进而提升签约经理的服务质量。于是，我们就对此需求进行了立项，立项通过后进入了开发环节。&lt;/p&gt;

&lt;h1 id=&quot;项目背景&quot;&gt;项目背景&lt;/h1&gt;

&lt;p&gt;　　首先，简单介绍下项目交互和情况。实际发生签约时，客业及经纪人落座签约室进行签约过程。签约过程包括但不限于接待、斡旋、风险视频播放、起草合同等环节。每个环节的切换都是由签约经理通过电视进行操控的，所以每个环节的打点时间是有的，就可以和录音录像连动起来了。环节如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08f786d38c0610acf30518e30620a0032801300138eb8802.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;架构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　接着简要描述一下项目需求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个签约场景需要进行的环节有很多，每个环节内需要做的质量检测条目也很多。&lt;/li&gt;
  &lt;li&gt;需要一个工作流系统，承接上游下发过来的质检时间点和质检规则。根据质检规则发送给AI侧进行ASR。&lt;/li&gt;
  &lt;li&gt;需要一个工作流系统，转化上游质检环节的数据，下发给实际处理视频的系统进行ffmpeg处理。&lt;/li&gt;
  &lt;li&gt;需要一个操作ffmpeg脚本的服务，负责制作音视频。&lt;/li&gt;
  &lt;li&gt;未来可能会有更多的扩展业务需要进行质量检测。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;架构思想&quot;&gt;架构思想&lt;/h1&gt;

&lt;p&gt;　　然后，说下项目的架构设计思想。成熟的架构设计应该遵循简单，可复用的原则去设计。我们应该将整个项目优先进行切分，划分出不同的领域去设计。在这里我们可以简单的理解领域为专注的一件事情。在我们的这个项目中就划分出了两个领域，一个是工作流，一个是ffmpeg音视频制作系统。工作流系统专注于将上游业务下发的任务通过转化和编排等步骤切分出不同的底层可理解的任务，如拼接，转码等，再发送给视频处理系统去处理。ffmpeg音视频制作系统关注ffmpeg领域，只关心音视频制作等逻辑。ffmepg系统为底层系统，只对接工作流系统。如果将来接入方越来越多的话，因为只有工作流是对接系统，所以底层的ffmpeg可以与业务解耦，能够提供更灵活的支持。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08bb85ce8c0610fdec0318a40820f3032801300138c4c102.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;项目的架构&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;领域设计实践&quot;&gt;领域设计实践&lt;/h1&gt;

&lt;p&gt;　　从以上的需求描述来看，设计的概念较多，也有一定的业务复杂性，而且此次需求是质检系统从0到1的过程，我们决定使用领域驱动设计的方法论来解决业务复杂性问题，以及未来系统的可扩展性、可维护性。我在其中负责的是底层ffmpeg的服务。&lt;/p&gt;

&lt;h2 id=&quot;构建统一领域语言&quot;&gt;构建统一领域语言&lt;/h2&gt;

&lt;p&gt;　　由于需求涉及到的很多概念，为保证左后程序运行结果符合业务预期，需要对这些概念进行在限定语义下的无歧义的描述，就是构建统一的领域语言。这个步骤需要项目组全体成员达成共识，项目的正确性依赖于此。基于本次需求，我们规定了以下这些概念的具体含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务：指制作视频时的各种动作类型的任务；&lt;/li&gt;
  &lt;li&gt;动作：指一个任务下需要进行的各种动作；&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;下载：指从S3上进行下载&lt;/li&gt;
      &lt;li&gt;上传：指上传至S3（批量同理）&lt;/li&gt;
      &lt;li&gt;拼接：音视频文件拼接动作&lt;/li&gt;
      &lt;li&gt;转码：音视频文件的转码动作&lt;/li&gt;
      &lt;li&gt;剪切：通过业务指定的打点时间，剪切出音视频片段&lt;/li&gt;
      &lt;li&gt;空源：指一个视频为黑屏，声音为无声的视频或者音频&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方案：由一个任务和一组动作组成的集合&lt;/li&gt;
  &lt;li&gt;匹配：一个任务匹配动作的方案集&lt;/li&gt;
  &lt;li&gt;ffmpeg命令：通过不同的参数运行ffmpeg可以实现对音视频的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;业务分析与建模&quot;&gt;业务分析与建模&lt;/h2&gt;

&lt;p&gt;　　以上的概念统一有助于接下来要进行的业务分析，在业务分析中主要的关注点在业务的相关概念、隐含概念以及这些概念之间的关系上，这些关系包括依赖、关联、聚合、组合等。&lt;/p&gt;

&lt;p&gt;　　对于业务分析，可以使用多种方式进行，比如用例分析法、UserStory、事件风暴等。这个具体看团队对于哪种方式比较熟悉。我们采用用例分析法，就是对于业务描述、梳理出各种情况下的用户用例。此次需求中有三个模块的用例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务模块；&lt;/li&gt;
  &lt;li&gt;动作匹配配置模块；&lt;/li&gt;
  &lt;li&gt;动作组装命令策略模块；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　这里先来进行动作配置模块的用例分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成动作列表，校验任务状态；&lt;/li&gt;
  &lt;li&gt;生成动作策略方案，从配置列表按照任务进行过滤；&lt;/li&gt;
  &lt;li&gt;生成动作匹配集，每个任务根据传入的参数筛选匹配符合的动作；&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　具体更多的详细用例这里不再展示，业务用例的列举越全面详细，由它构建的模型就会越准确，在列举用例的过程中要依据产品的PRD（如果有），但不能照搬PRD，要对PRD的内容进行归纳总结抽象，发现其中隐含的模型概念，比如这里的动作匹配策略的概念在PRD中没有显示的表现，但是隐藏在业务执行的过程中。&lt;/p&gt;

&lt;p&gt;　　当用例列举完善后，需要在这些用例中总结抽象出业务模型以及模型之间的关系。对于分析用例，简单来说有以下三个基本方法论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提取实体，识别名词定位出实体；&lt;/li&gt;
  &lt;li&gt;添加关联，识别动词添加实体和实体质检的关联；&lt;/li&gt;
  &lt;li&gt;添加属性，识别形容词添加实体属性；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对于上述过程，它不是一蹴而就的，而是一步一步的发现用例，画出相关的模型图，然后再次发现隐含的用例或模型，修改模型图，它是一个迭代而产生的模型图。在迭代的过程中，依然要对相关模型进行统一语言的构建。&lt;/p&gt;

&lt;h3 id=&quot;匹配配置模型分析&quot;&gt;匹配配置模型分析&lt;/h3&gt;

&lt;p&gt;　　此项目的难点就是对于音视频处理任务的类型较多，而且每种类型的任务的场景不同，ffmpeg需要采用的命令行参数也不同，涉及到的规则很是复杂。如下面的规则示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拼接 &amp;amp;&amp;amp; A场景 &amp;amp;&amp;amp; 兼容模式 &amp;amp;&amp;amp; 电视摄像头采集 &amp;amp;&amp;amp; ……&lt;/li&gt;
  &lt;li&gt;拼接 &amp;amp;&amp;amp; B场景 &amp;amp;&amp;amp; 高画质模式 &amp;amp;&amp;amp; 安防摄像头采集 &amp;amp;&amp;amp; ……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　类似这样的规则需求里面有很多种，未来会频繁的修改添加，所以如何对其进行建模使其可配置可扩展至关重要。对与这样的规则，我们把它抽象为规则、条件表达式、ffmpeg命令参数这样的统一概念，一个方案对应一个表达式，一个表达式由一个或者多个ffmpeg命令参数组成。模型图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08a3aad48c0610fb9c05188a0a20ee042801300138fac803.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;模型图1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这样的模型可以使ffmpeg命令和方案配置解耦，方便未来扩展更多的ffmpeg命令以及进行方案的配置，条件表达式可以使用方案引擎进行解析。&lt;/p&gt;

&lt;h3 id=&quot;组装ffmpeg命令策略模型分析&quot;&gt;组装ffmpeg命令策略模型分析&lt;/h3&gt;

&lt;p&gt;　　对于ffmpeg命令策略模型的设计不但依赖上面的匹配配置模型，还要考虑到不同命令参数对最终音视频的影响。目前项目涉及的任务类型只涉及到质检场景的视频拼接、剪切及转码。在未来规划中，还会对其他场景及任务类型的支持，所以这里需要对其进行可扩展的设计：抽象出场景的概念。&lt;/p&gt;

&lt;p&gt;　　基于以上的模型构建，主要分为三个模块：场景、方案、ffmpeg命令参数。想要完成ffmpeg命令策略模型的设计就需要对这三个模块的信息和算法进行编写，我们还需要在设计的同时让他们保持相互解耦，方便未来对算法进行迭代优化。基于此，整个业务模型图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08e9bad48c0610e6960918a80920f20828013001389cd803.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;模型图2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;领域建模&quot;&gt;领域建模&lt;/h2&gt;

&lt;p&gt;　　基于以上的业务分析与建模、接下来要进行相关领域模型的建模。领域模型构建的关注点主要在于实体、值对象、聚合、领域服务和库的定义。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;实体、值对象分析&lt;/p&gt;

    &lt;p&gt;首先要对业务模型中的每个概念进行领域建模、领域模型中最主要的就是实体和值对象，他们的区别有两点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实体是有唯一ID的，而且在业务中是有生命周期的，就是它会有一些状态变化；&lt;/li&gt;
      &lt;li&gt;值对象也可以有唯一的ID，但是它是无状态的，是在程序运行过程中是不可变的；&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;根据以上的原则，可以对上述概念进行领域建模。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于任务这个概念，他是有唯一ID的，在任务处理过程中它是会改变状态的，所以它应该是实体。&lt;/li&gt;
      &lt;li&gt;对于动作这个概念，它是由唯一ID的，在处理过程中它不会改变状态，所以他应该是值对象。&lt;/li&gt;
      &lt;li&gt;对于场景这个概念，他是有唯一ID的，在任务处理过程中它是不会改变状态的，所以它应该是值对象。&lt;/li&gt;
      &lt;li&gt;对于匹配来说，有唯一ID，在处理过程中一旦创建就不会改变，构建为值对象。&lt;/li&gt;
      &lt;li&gt;对于方案来说，同上。&lt;/li&gt;
      &lt;li&gt;对于方案集来说，在处理过程中它需要维护方案的ffmpeg参数，是否为最优方案等相关状态，所以他是实体。&lt;/li&gt;
      &lt;li&gt;对于匹配策略来说，有唯一ID，在处理过程中不可变，构建为值对象。对于他所包含的参数规则，筛选规则，方案匹配规则都应该是值对象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;聚合的划分&lt;/p&gt;

    &lt;p&gt;聚合这个概念是一个抽象的概念，它在代码中没有具体的类模型去承载，但是聚合的划分对于代码逻辑的内聚性至关重要。聚合可以理解为领域模型之间的一种代码约束，比如不同聚合之间的模型不可以直接调用，需要通过聚合根进行聚合间的交互。&lt;/p&gt;

    &lt;p&gt;对于上述模型来说，可以看出来有任务、场景、ffmpeg命令策略这三个聚合。其他的模型与这三个聚合一起构成这个ffmpeg模块聚合。对于ffmpeg命令策略这个聚合，它的内部有匹配规则这个聚合，规则由于有多种类型，所以它是一个抽象类；规则聚合包括表达式这个小聚合，表达式聚合又包含了ffmpeg命令聚合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂、库、领域服务分析&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​	实体和值对象是领域模型中比较重要的两个模型，剩下的工厂、库、领域服务这些对象是为了维护以上两个模型的生命周期而产生的模型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;工厂：正如它的名字，主要维护模型的创建工作。有两种形式来创建工厂，一个是通过构造方法充当模型的工厂方法；如果模型构建比较复杂，就需要创建一个工厂类来承载创建模型的工作。对于上述模型，需要为任务、场景、ffmpeg命令这三个聚合创建工厂类，因为他们够在相对来说比较复杂。&lt;/li&gt;
  &lt;li&gt;库：库的概念主要是用来调用基础设施层来获取持久化数据以及进行数据持久化。这里服务者需要从第三方接口获取数据，需要构建一个库对象；测录需要从数据库获取，构建一个库对象；&lt;/li&gt;
  &lt;li&gt;领域服务：对于领域服务，它主要承载聚合之间的交互逻辑，如果发现有一个逻辑设计多个聚合，它没有一个主体，不适合放在其中的摸一个聚合中，这时需要构建一个领域服务来承载这部分逻辑。比如上面木星中的方案生成逻辑，它涉及任务、场景、ffmpeg这三个聚合，所以应为其创建一个领域服务来承载方案生成以及最优化方案的成圣逻辑。对于领域服务，不能随便滥用，不然会变成一个业务逻辑的打你团。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;领域模型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　基于以上的分析，我们可以构建出如下的领域模型图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/0895a3dd8c06108de80518d0062093062801300138e75c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;领域模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　以上模型基本和业务分析出的模型类似，我们为其确立了具体模型归属，划分了相关的聚合，添加了相应的辅助领域模型。在构建这个模型时，依然要随时丰富相关的用例case，不断完善领域模型。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="系统" /><summary type="html">DDD 是 Domain-Driven Design 的缩写。其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散沙，无法继续演进。</summary></entry><entry><title type="html">我在贝壳的第一次活水</title><link href="http://localhost:4000/life/2021/06/30/01.html" rel="alternate" type="text/html" title="我在贝壳的第一次活水" /><published>2021-06-30T00:00:00+08:00</published><updated>2021-06-30T00:00:00+08:00</updated><id>http://localhost:4000/life/2021/06/30/01</id><content type="html" xml:base="http://localhost:4000/life/2021/06/30/01.html">&lt;blockquote&gt;
  &lt;p&gt;得志不得意，失意不失志&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着4月的晋升失败，给我带来的是又一次打击。本来2020年10月的第一次晋升失败以后，经过2个月在java的项目上的锤炼，我又建立起了很足的信心。因为，在2020年底我自己一人做出的项目平均每天的请求量在80万，qps50。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="链家,活水" /><summary type="html">得志不得意，失意不失志</summary></entry><entry><title type="html">拿饭网对java的classLoader分析</title><link href="http://localhost:4000/tech/2021/06/15/01.html" rel="alternate" type="text/html" title="拿饭网对java的classLoader分析" /><published>2021-06-15T00:00:00+08:00</published><updated>2021-06-15T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/06/15/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/06/15/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　虚拟机把描述类的数据从class文件加载到内存，并且进行校验、解析、初始化。最终形成可以直接使用的Class对象，这就是类加载机制。&lt;/p&gt;

&lt;p&gt;　　类加载并不是一次性把所有class文件都加载到JVM中的，而是按照需求来加载的。比如，JVM启动时，会通过不同的类的加载器加载不同的类。当用户在自己代码中，需要额外的类时，再通过加载机制加载到JVM中，并且存放一段时间，便于频繁使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全盘委托，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示的使用另外一个类加载器加载。&lt;/li&gt;
  &lt;li&gt;父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。&lt;/li&gt;
  &lt;li&gt;缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，自由缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载过程&quot;&gt;类加载过程&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　类从被加载到JVM内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，共7个阶段。其中验证、准备、解析3个部分统称为连接。这7个阶段的发生顺序如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08dca7e7850610aef604188e0c20fa042801300138b2e403.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　其中&lt;code&gt;类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。&lt;/code&gt;在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。&lt;/p&gt;

&lt;p&gt;　　下面详细介绍每个阶段所做的事情：&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;加载&quot;&gt;加载&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　加载时类加载过程的第一个阶段，在加载阶段，JVM需要完成以下三件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过一个类的全限定名来获取其定义的二进制字节流。&lt;/li&gt;
  &lt;li&gt;将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
  &lt;li&gt;在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　第一条中的二进制字节流并不只是单纯的从class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。&lt;/p&gt;

&lt;p&gt;　　相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。&lt;/p&gt;

&lt;p&gt;　　加载完成以后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在&lt;code&gt;方法区&lt;/code&gt;之中，而且在java堆中也会创建一个java.lang.Class类的对象，这样便可以通过对象访问方法区中的这些数据。&lt;/p&gt;

&lt;p&gt;　　类加载器分为以下三类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动类加载器：Bootstrap ClassLoader，它负责加载放在JDK/jre/lib下，或者被-Xbootclasspath参数指定的路径中的，并且被虚拟机是别的类库。启动类加载器是无法被java程序直接启动的。它是C++实现的，是虚拟机的一部分。&lt;/li&gt;
  &lt;li&gt;扩展类加载器：Extension ClassLoader，该加载器由sun.misc.launCher$ExtClassLoader实现，它负责加载JDK/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/li&gt;
  &lt;li&gt;应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　应用程序都是由这三种加载器相互配合进行加载的，如果有必要程序员还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在执行非置信代码之前，自动验证数字签名。&lt;/li&gt;
  &lt;li&gt;动态地创建符合用户特定需要的定制化构建类。&lt;/li&gt;
  &lt;li&gt;从特定的场所取得java class，例如数据库中或者网络中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/0888e8e7850610f18c0118c10220c5032801300138ae1c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;双亲委派模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这种层次关系称为类加载器的&lt;code&gt;双亲委派模型&lt;/code&gt;。他们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中代码。这不是一个强制性的约模型，而是java设计者们推荐给开发者的一种类的加载器实现方式。&lt;/p&gt;

&lt;p&gt;　　双亲委派的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它搜索范围中没有找到所需的类时，子加载器才会去尝试自己去完成加载。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;为什么要使用这种模式呢？&lt;/code&gt;因为java中的类随着它的类加载器一起具备了一种带有优先级的层级关系。这样的好处是，避免了循环引用，而可以一直溯源到最父类。例如，java.lang.Object，他存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载类进行加载，因此Object类在程序的各种类加载器环境中都是能够保证是同一个类。同时，也防止了内存中出现同样的字节码。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;举例说明&quot;&gt;举例说明&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dog dog = new Dog();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由new关键字创建一个类的实例。这个动作会导致常量池的解析，Dog类被隐式装在。如果当前ClassLoader无法找到Dog,则抛出NoClassDefFoundError&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try{
    Class clazz = Class.forName(&quot;Dog&quot;);
    Object dog = clazz.newInstance();
}catch (Exception e){
    System.out.println(e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过反射加载类型并创建对象实例。如果无法找到Dog，则抛出ClassNotFoundException&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try{
    ClassLoader cl = new ClassLoader() {
        @Override
        public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
            return super.loadClass(name);
        }
    };
    Class clazz = cl.loadClass(&quot;Dog&quot;);
    Object dog = clazz.newInstance();
}catch (Exception e){
    System.out.println(e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过反射加载类型并创建对象实例。如果无法找到Dog，则抛出ClassNotFoundException&lt;/p&gt;

&lt;p&gt;&lt;code&gt;上面三种有什么区别呢？分别用于什么情况呢？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1和2使用的类加载器是相同的，都是当前类加载器（this.getClass.getClassLoader）。3是用户指定的类加载器。如果需要在当前类路径以外寻找类，则只能用第3种方式。第3种方式加载的类与当前类分属不同的命名空间。当前类加载器命名空间对其不可见。当然，如果被加载类的超类对于当前类命名空间可见的话，则可以进行强制转型。第1种抛出error，第2，3种抛出Exception。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jdk9的双亲委派模式&quot;&gt;JDK9的双亲委派模式&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDK9为了模块化的支持，对双亲委派模式租了一些改动：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;扩展类加载器被平台类加载器（Platform ClassLoader）取代，原来的rt.jar和tools.jar被拆分成数十个JMOD文件。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平台类加载器和应用程序类加载器都不再继承自java.netURLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;启动类加载器现在是在java虚拟机内部和java类库共同协作实现的类加载器（以前是C++实现）。为了与之前的代码保持兼容，所有在获取启动类加载器的场景中仍然会返回null来代替，而不会得到BootClassLoader的实例。&lt;/li&gt;
  &lt;li&gt;类加载的委派关系也发生了变动，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08d3bea0860610a791181880082080062801300138d28f01.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;jdk9双亲委派模型&quot; /&gt;&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">类加载机制</summary></entry><entry><title type="html">赛格广场晃动，原因竟然是共振</title><link href="http://localhost:4000/thinking/2021/05/22/01.html" rel="alternate" type="text/html" title="赛格广场晃动，原因竟然是共振" /><published>2021-05-22T00:00:00+08:00</published><updated>2021-05-22T00:00:00+08:00</updated><id>http://localhost:4000/thinking/2021/05/22/01</id><content type="html" xml:base="http://localhost:4000/thinking/2021/05/22/01.html">&lt;blockquote&gt;
  &lt;p&gt;赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0519%2F79a605c9j00qtcuwt00a4c0010400r4m.jpg&amp;amp;thumbnail=650x2147483647&amp;amp;quality=80&amp;amp;type=jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月18日，深圳市福田区华强北街道赛格大厦出现摇晃，大厦已经封闭，大厦内人员已全部撤出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月19日，大楼在下午一点半到两点之间出现过晃动。目前大厦原则上只能让商家等内部工作人员出入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月20日12时30分左右在35楼、55楼、60楼等多个楼层感受到晃动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2020年5月21日，深圳市赛格集团有限公司的通知显示自21日起暂停所有业主、商户、租户进出赛格大厦写字楼和电子市场，待相关检测工作完成后再有序开放，有关事宜另行通知。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　最近，赛格大厦晃动的事件在民间讨论的沸沸扬扬，一石激起千层浪，媒体的曝光更加让本来疑云密布的事件罩上了更多的阴谋论。其中一家媒体爆料说是20年前就有一篇&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1700150908927741800&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;《深圳赛格广场建设项目评析》&lt;/a&gt;的硕士论文中指出，大厦是边设计边施工。这位硕士学生是一名华中科技大学非建筑学科且并未参与过赛格广场建设的学生，她的名字叫金典琦。此文章一出各种小道每天就开始各种添油加醋，疯狂的不分青红皂白的就开始说赛格大厦是豆腐渣工程，是中国体系内的不负责任的典型。那么事情真的是这样么？我在网上翻到了当时这名学生的论文并且通读以后得出了结论：&lt;/p&gt;

&lt;p&gt;　　金典琦是学工商管理的在职硕士，全程参与了赛格大厦建设的管理工作。对赛格大厦建造过程中选取的技术和解决方案以及施工方的预算和组织架构有充足的了解和深入的分析。对于建设过程中遇到的问题和解决方案有自己独有的理解和路径分析，形成了自己理论体系内的底层逻辑，逻辑能够自洽，对当时的市场分析和市场判断有比较全面的认知和实践。论文中也给出了详细的问题列表和抓手，对待施工时施工单位采用的方案有给出追种方案的比较并得到了学界内权威人士的认可与支持。&lt;/p&gt;

&lt;p&gt;　　论文中两次提到赛格大厦晃动的经历，一次为大厦顶部的两根天线设计不合理并重新进行了调整；一次为95年因大厦耸入云间，由于云彩移动导致广场上的人们误以为大厦要倾倒的趣事。还有一次提到了共振问题导致晃动。一次边设计边建造的问题根源。&lt;/p&gt;

&lt;p&gt;　　综上所述，论文给出了客观且符合当事人认知的合理判断与真实建造情况。所以，对于这些媒体给出的偏颇结论我认定为是媒体的误导及看到这些文章后唯恐天下不乱的人们不经过自己调研后就轻易下结论的事实。&lt;/p&gt;

&lt;p&gt;　　接下来，让我们的目光集中在&lt;code&gt;共振&lt;/code&gt;这一物理名词上。首先让我们看看bilibili上科普博主用通俗的语言讲的共振的机制和影响吧。&lt;/p&gt;

&lt;div align=&quot;middle&quot;&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=714516015&amp;amp;bvid=BV1qX4y1V7cE&amp;amp;cid=308414800&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/2e7857ed9bfb4122aaf35d697dbbf8b3.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;三百多年前，荷兰科学家惠更斯（Christian Huygens）在房间里的墙上并排放置不同速率的摆钟。当他第二天再回来时，发现这几个摆钟的钟锤都以同速率同步摆动。最终根据这一现象惠更斯写出了《摆钟轮》（Horologium Oscillatorium），摆钟现象被后来许多人相继重复实验，实际上这就是今天说的共振。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/dfce68126e974af08a03e71a2b578caa.gif&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振动图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　让我们来看看数学上是如何解释共振机理的吧，出自《数学指南》，科学出版社出版：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic2.zhimg.com/v2-afd3f984658ef92358a21e3245278824_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-e531f3ecae8171692340dd76189c3fe9_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-062748cdc1ecca03d291bdcb76c6b5aa_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理3&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　通过上面的数学方程式，我们了解到。如果我们一直给弹簧施加一个周期性的力，当力的频率等于弹簧固有震频时，力的作用方向和振子运动方向一直保持一致。这就意味着，力对振子做的功永远为正，于是振子的能量越来越大，对物体内部结构的破坏就越来越大，最终会导致物体被摧毁。&lt;/p&gt;

&lt;p&gt;　　2021年特斯拉上架了ModelY，当发售两个月后车主就曝出了modelY低频共振的问题。据说，很多车主都遇到过这个问题，并且有些车主花钱去做了&lt;a href=&quot;https://club.autohome.com.cn/bbs/thread/870af073c080e909/94575641-1.html&quot;&gt;后备箱隔音&lt;/a&gt;，但仍于事无补。据业内人士分析，ModelY的低频噪音多来自尾部，或许是因为车辆行驶过程中的噪音通过底盘传至车身，由于后尾门存在空腔，且钢板较薄，很容易因为刚性不足而放大噪音，从而产生低频共振的现象。这个就是通过后备箱的声音传过来的声波和车主的耳膜一致造成了共振现象，当振幅越来越大时就会给车主的耳朵造成不可逆的创伤。&lt;/p&gt;

&lt;p&gt;　　在我弹吉他的时候，每次拿出来吉他都要进行调音测试，为了让每条弦能够弹出准确的声音。调音手段中有一个利用共振原理来进行调弦的方法。就是波动一条弦后，其他弦的空弦如果与这条弦的声调一致就会跟着颤抖起来。&lt;/p&gt;

&lt;p&gt;　　在航天航空中，宇航员升天时会与宇宙飞船产生共振。我们国家英雄杨利伟就曾说：“2003年10月15日上午9时整，火箭尾部发出巨大的轰鸣声，几百吨高能燃料开始燃烧，8台发动机同时喷出炽热的火焰，高温高速的气体，几秒钟就把发射台下的上千吨水化为蒸汽。火箭和飞船总重达到487吨，当推力让这个庞然大物升起时，大漠颤抖、天空轰鸣。火箭逐步地加速，我感到压力在渐渐增加。因为这种负荷我们训练时承受过，我的身体感受还挺好，觉得没啥问题。但就在火箭上升到三四十公里的高度时，火箭和飞船开始急剧抖动，产生了共振。这让我感到非常痛苦。人体对10赫兹以下的低频振动非常敏感，它会让人的内脏产生共振。而这时不单单是低频振动的问题，还是这个新的振动要叠加在大约6G的一个负荷上。这种叠加太可怕了，我们从来没有进行过这种训练。我担心的意外还是发生了。”&lt;/p&gt;

&lt;p&gt;　　在现实生活中，我们周边还会有许许多多的共振现象。要解决共振其实很简单，只要找到物体共振频率，在此频率上减小激励力就能够避免共振了。对于高楼大厦来说，一般都是用类似阻尼器的装置来减小共振。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="共振" /><summary type="html">赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。</summary></entry><entry><title type="html">敬给我最尊重的老板，贝壳董事长-左晖</title><link href="http://localhost:4000/life/2021/05/20/01.html" rel="alternate" type="text/html" title="敬给我最尊重的老板，贝壳董事长-左晖" /><published>2021-05-20T00:00:00+08:00</published><updated>2021-05-20T00:00:00+08:00</updated><id>http://localhost:4000/life/2021/05/20/01</id><content type="html" xml:base="http://localhost:4000/life/2021/05/20/01.html">&lt;blockquote&gt;
  &lt;p&gt;我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic3.zhimg.com/80/v2-929a9e08b764aafea5ab50701fc66f82_720w.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;左晖&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面是我们公司的老板说的话，他的精神永远激励着我们，我们将矢志不渝的坚持长期主义，团结一心为新居住产业发展做难而正确的事！&lt;/p&gt;

&lt;p&gt;　　我很早就把我的行业固定在了中国的房地产行业之中，我又是从事互联网的技术人员。所以很自然的就干上了产业互联网之事。而我选择链家就是因为我在见证了链家这20年来的发展，坚定了链家作为中国（将来）最好的企业之一的信念以及我对中国房地产相关产业的看好。&lt;/p&gt;

&lt;p&gt;　　我是18年8月入职贝壳的，其实在四月份我就来链家面过试。那个时候福道大厦还不是贝壳的logo呢。我对链家是有一种执着的信念的，我愿意追随这样一位好领导，干有意义且难但正确的事情。入职贝壳以来，我专心落地到了为左晖先生提的”做有尊严的服务者“这句话的意义上奉献，长达3年的贝壳工作，我一直服务于链家的经纪人产品。&lt;/p&gt;

&lt;p&gt;　　经过这几年的工作，从入职php，到改为写go，再到现在的java。感觉这几年对语言的转型让我对语言已经有深刻的理解了。目前我正在做自己负责的业务，并且一直致力于学习。在2020年10月，和21年4月，我得到了部门给我的晋升机会。虽然通过自己的努力，最终没有晋级成功。但是，两次折磨的过程让我重新认识到了我目前缺乏的东西，第一次是技术，但是在第二次评委已经不说我技术问题了，而是产品高度。在接下来的工作和生活中，我将以提高我的这个能力为前提努力的认真工作。左晖先生的精神，会激励着我，一直向前。&lt;/p&gt;

&lt;p&gt;　　今天下午3点，在得知左晖先生离开后，我心情难以平复，本来未来可期，本来还有一番事业等待着他带领我们一起航行，可是就这样戛然而止，希望左晖先生一路走好，后面还有大S帮您完成您的愿望，我们会一起努力!&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="链家,癌症" /><summary type="html">我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。</summary></entry><entry><title type="html">redis连接池源码分析</title><link href="http://localhost:4000/tech/2021/05/15/01.html" rel="alternate" type="text/html" title="redis连接池源码分析" /><published>2021-05-15T00:00:00+08:00</published><updated>2021-05-15T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/15/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/15/01.html">&lt;p&gt;　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。&lt;/p&gt;

&lt;p&gt;　　你在开发时，可以通过jedis连接redis。jedis支持直连模式和连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直连模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; public static void main(String[] arg){
        //1个实例
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379,100);
        jedis.incr(&quot;threadSafe&quot;);
        jedis.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/089f91fe840610d38104189b092092042801300138f312.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;直连&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　你不应该将一个redis实例共享给不同线程，时用时消的用法会造成产生很多的socket和tcp连接，即浪费时间又耗费资源，也提高了服务不可用的风险。如果你只是在本机环境或者使用者相对少的环境中使用，这种模式比较适宜。但是，如果你需要大量使用redis时，应该采用连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接池模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] arg){
        JedisPool pool = new JedisPool(new JedisPoolConfig(),&quot;localhost&quot;);
        try (Jedis jedis = pool.getResource()) {
            jedis.set(&quot;foo&quot;, &quot;bar&quot;);
            String foobar = jedis.get(&quot;foo&quot;);
            jedis.zadd(&quot;sose&quot;, 0, &quot;car&quot;); jedis.zadd(&quot;sose&quot;, 0, &quot;bike&quot;); 
            Set&amp;lt;String&amp;gt; sose = jedis.zrange(&quot;sose&quot;, 0, -1);
        }
        pool.close();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08af91fe84061087a50a189b09208b052801300138b9f703.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;连接池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　为了避免由单一redis实例引发的未知的服务不可用的风险，我们应该采用这种方案。这种方案背后的原理就是连接池（common-pool2）。当服务到达时服务会从连接池中borrow一个jedis连接，当用完或者发生错误时，连接会归还到连接池中。如果没有borrow到连接，那么服务就会报错且关闭。&lt;/p&gt;

&lt;p&gt;　　我的上一篇&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/12/01.html&quot;&gt;池化技术&lt;/a&gt;已经提到过连接池的概念，所以这篇文章是我想记录并分享我所学习到的jedis连接池的知识。通过上一段代码我们看到当jedisPool实例化以后，我们从pool中通过getResource来获取一个jedis实例。那么我们的代码研究就从这里开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/jedisPool.class
    public Jedis getResource() {
        //调用父集getResource
        Jedis jedis = (Jedis)super.getResource();
        //将当前实例暴露出dataSource，供后续redis操作使用
        jedis.setDataSource(this);
        return jedis;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/client/util/Pool.class
    //genericObjectPool是ObjectPool的实现，ObjectPool是common.pool2中关于池化对象的接口。其中定义了几个标准的对象方法，这些方法就是管理池的核心方法。
    protected GenericObjectPool&amp;lt;T&amp;gt; internalPool;
    ……
    public T getResource() {
        try {
            //通过调用common.pool2中的borrowObject，完成对jedis实例的借取。
            return this.internalPool.borrowObject();
            //如果出现了异常了，按照异常的分类进行处理。
        } catch (NoSuchElementException var2) {
            if (null == var2.getCause()) {
                throw new JedisExhaustedPoolException(&quot;Could not get a resource since the pool is exhausted&quot;, var2);
            } else {
                throw new JedisException(&quot;Could not get a resource from the pool&quot;, var2);
            }
        } catch (Exception var3) {
            throw new JedisConnectionException(&quot;Could not get a resource from the pool&quot;, var3);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在common-pool2中，对象池的核心接口叫做ObjectPool，他定义了对象池的实现的行为。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;addObject方法：往池中添加一个对象。池子里的所有对象都是通过这个方法进来的。&lt;/li&gt;
  &lt;li&gt;borrowObject方法：从池中借走到一个对象。借走不等于删除。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;returnObject方法：把对象归还给对象池。归还不等于添加。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;invalidateObject：销毁一个对象。这个方法才会将对象从池子中删除，当然这其中最重要的就是释放对象本身持有的各种资源。&lt;/li&gt;
  &lt;li&gt;getNumIdle：返回对象池中有多少对象是空闲的，也就是能够被借走的对象的数量。&lt;/li&gt;
  &lt;li&gt;getNumActive：返回对象池中有对象对象是活跃的，也就是已经被借走的，在使用中的对象的数量。&lt;/li&gt;
  &lt;li&gt;clear：清理对象池。注意是清理不是清空，改方法要求的是，清理所有空闲对象，释放相关资源。&lt;/li&gt;
  &lt;li&gt;close：关闭对象池。这个方法可以达到清空的效果，清理所有对象以及相关资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　在common-pool2中，objectPool的核心实现类就是GenericObjectPool。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectedPool
    @Override
    public T borrowObject() throws Exception {
        //getMaxWaitMillis()是BaseGenericObjectPool中设定的volatile类型的值，代表最长等待时间（毫秒），配置文件中的&quot;maxWait&quot;
        return borrowObject(getMaxWaitMillis());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接下来我们来分析下borrowObject方法，刚才说过borrowObject是实现了ObjectPool。那么先看一下这个接口中对borrowObject的描述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    /**
     * Obtains an instance from this pool.
     * &amp;lt;p&amp;gt;
     * Instances returned from this method will have been either newly created
     * with {@link PooledObjectFactory#makeObject} or will be a previously
     * idle object and have been activated with
     * {@link PooledObjectFactory#activateObject} and then validated with
     * {@link PooledObjectFactory#validateObject}.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * By contract, clients &amp;lt;strong&amp;gt;must&amp;lt;/strong&amp;gt; return the borrowed instance
     * using {@link #returnObject}, {@link #invalidateObject}, or a related
     * method as defined in an implementation or sub-interface.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * The behavior of this method when the pool has been exhausted
     * is not strictly specified (although it may be specified by
     * implementations).
     * &amp;lt;/p&amp;gt;
     *
     * @return an instance from this pool.
     *
     * @throws IllegalStateException
     *              after {@link #close close} has been called on this pool.
     * @throws Exception
     *              when {@link PooledObjectFactory#makeObject} throws an
     *              exception.
     * @throws NoSuchElementException
     *              when the pool is exhausted and cannot or will not return
     *              another instance.
     */
     /*
     这个method返回实例，这个实例将是一个被makeObject()创建的对象，或者是一个之前就是idle并且经过activateObject()激活过的并且经过validatedObject()验证过的对象。
     根据约定，客户端必须调用过returenObject(),invalidateObject()或者一个在子类中实现了归还逻辑的方法后归还。
     这个方法在池子耗尽时的表现没有指明具体如何处理（尽管他有可能被他的实现制定过。）
     */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接着我们再来看看这个方法的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectPool.class
    /**
     * Equivalent to &amp;lt;code&amp;gt;{@link #borrowObject(long)
     * borrowObject}({@link #getMaxWaitMillis()})&amp;lt;/code&amp;gt;.
     * &amp;lt;p&amp;gt;
     * {@inheritDoc}
     * &amp;lt;/p&amp;gt;
     */
     //通过获取配置中MaxWait配置，当做传输调用重载的方法。
    @Override
    public T borrowObject() throws Exception {
        return borrowObject(getMaxWaitMillis());
    }
    
    /**
     * Borrows an object from the pool using the specific waiting time which only
     * applies if {@link #getBlockWhenExhausted()} is true.
     * &amp;lt;p&amp;gt;
     * If there is one or more idle instance available in the pool, then an
     * idle instance will be selected based on the value of {@link #getLifo()},
     * activated and returned. If activation fails, or {@link #getTestOnBorrow()
     * testOnBorrow} is set to {@code true} and validation fails, the
     * instance is destroyed and the next available instance is examined. This
     * continues until either a valid instance is returned or there are no more
     * idle instances available.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If there are no idle instances available in the pool, behavior depends on
     * the {@link #getMaxTotal() maxTotal}, (if applicable)
     * {@link #getBlockWhenExhausted()} and the value passed in to the
     * {@code borrowMaxWaitMillis} parameter. If the number of instances
     * checked out from the pool is less than {@code maxTotal,} a new
     * instance is created, activated and (if applicable) validated and returned
     * to the caller. If validation fails, a {@code NoSuchElementException}
     * is thrown.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If the pool is exhausted (no available idle instances and no capacity to
     * create new ones), this method will either block (if
     * {@link #getBlockWhenExhausted()} is true) or throw a
     * {@code NoSuchElementException} (if
     * {@link #getBlockWhenExhausted()} is false). The length of time that this
     * method will block when {@link #getBlockWhenExhausted()} is true is
     * determined by the value passed in to the {@code borrowMaxWaitMillis}
     * parameter.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * When the pool is exhausted, multiple calling threads may be
     * simultaneously blocked waiting for instances to become available. A
     * &quot;fairness&quot; algorithm has been implemented to ensure that threads receive
     * available instances in request arrival order.
     * &amp;lt;/p&amp;gt;
     *
     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
     *                            to become available
     *
     * @return object instance from the pool
     *
     * @throws NoSuchElementException if an instance cannot be returned
     *
     * @throws Exception if an object instance cannot be returned due to an
     *                   error
     */
     /*
     当getBlockWhenExhausted()返回true时，需要提供等待时间从对象池中借出对象，
     如果有1个或多个空闲实例的话，就通过getLifo()方法，也就是先进先出的策略选择由哪个空闲实例承接工作。如果激活失败了，或者testOnBorrow设置为true并且检测失败了，这个实例就会销毁，接下来由下一个可用实例进行承接。这个流程一直持续，直到没有可用的实例可供使用或者没有空闲实例可供使用。
     如果在对象池中没有空闲实例了，接下来的走向取决于maxTotal,getBlockWhenExhausted()和传进来的等待时间参数决定。如果当前对象池中的实力数量小于maxtotal，一个新的实例将被创建，激活并且检测最终返回给调用者。如果检测失败，一个NoSuchElementException异常将被抛出。
     如果对象池已经占满了（也就是说没有可用的空闲实例并且没有容量可以被创建），这个方法要不堵塞（如果getBlockWhenExhausted设置为true的情况下才会堵塞）要不就抛出一个NoSuchElementException（相反getBlockWhenExhausted为false的情况）异常。具体阻塞的时间跟传入的borrowMaxWaitMillis时间大小有关。（还记得刚才说的maxWait的设置么？）
     当对象池已经耗尽，多个调用线程将被同时堵塞，他们一起等待可用的jedis实例接客。接客的规则采用公平算法。其实就是先到先被接~哈哈
     */
    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        //这一步就是检查一下对象池的状态，如果之前已经关闭了，就会抛出IllegalStateException异常。
        assertOpen();
        //移除已经被抛弃的实例
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;
                (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;
                (getNumActive() &amp;gt; getMaxTotal() - 3) ) {
            /*
            被抛弃的实例不为null
            borrow时去除被抛弃的实例
            空闲线程实例&amp;lt;2
            当前活动的实例数量大于最大实例数量-3
            */
            removeAbandoned(ac);
        }
        //定义一个PooledObject类型的对象，T是真正的实例对象。如jedis，db等。
        PooledObject&amp;lt;T&amp;gt; p = null;

        // Get local copy of current config so it is consistent for entire
        // method execution
        /*
        获取一个本地的拷贝，这个拷贝是目前的配置。这样就能够保证整体的一致性。
        这个getBlockWhenExhausted()最终是获取的一个volatile类型的值，这个值是从配置中获取的，代表当线程池满时，是否对新来的任务给予堵塞。但是，我们得注意volatile这个类型了，而且设计者在这个地方单独获取出来这个值，肯定是为了什么。接着往下看吧。
        */
        final boolean blockWhenExhausted = getBlockWhenExhausted();
        //是否为新建，请区别于created。为什么仅在这里定义了变量而没有初始化呢？
        boolean create;
        //当前的毫秒，用来就算
        final long waitTime = System.currentTimeMillis();
        //循环开始，第一次p=null开始循环
        while (p == null) {
            //初始化create=false，代表目前这个线程不是新建的。
            create = false;
            /*
            private final LinkedBlockingDeque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleObjects;
            idleObjects是一个阻塞有序队列，队列的类型是刚才的封装类型，封装的是实际的资源。从名字上可以看出，这里叫做空闲对象组
            可以看到，从空闲对象组里拿出第一个元素。pollFirst()是LinkedBlockingDeque.java中的方法。就是通过操作节点来把第一个节点删除并返回。
            */
            p = idleObjects.pollFirst();
            //如果p为空代表弹出的是null，说明没有空闲。那就创建一个新的对象。
            if (p == null) {
                p = create();
                //p可能会创建失败，创建失败的时候 create=false。 创建成功create=true
                if (p != null) {
                    create = true;
                }
            }
            //如果设置了对象池耗尽后堵塞等待的标示
            if (blockWhenExhausted) {
                if (p == null) {
                    //p没有创建成功
                    if (borrowMaxWaitMillis &amp;lt; 0) {
                        //如果没有设置为-1，只有这种情况会符合小于0.所以就直接从空闲对象组中获取第一个有效的空闲对象。这个方法有锁的实现，所以这块可能会一直堵塞着直到有一个空闲对象可以使用。
                        p = idleObjects.takeFirst();
                    } else {
                    //如果设置等待时间了，就在这段时间里获取。超过了就返回null
                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                TimeUnit.MILLISECONDS);
                    }
                }
                //到这里如果还是空，就说明没等待到空闲的资源了。所以就要报异常了。
                if (p == null) {
                    throw new NoSuchElementException(
                            &quot;Timeout waiting for idle object&quot;);
                }
            } else {
                //如果没有设置blockWhenExhausted标示且p是null，那真是获取不到资源了，因为池子已经被占满了。
                if (p == null) {
                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);
                }
            }
            /*
            到这里其实p应该不是null了，说明肯定是有资源了。有可能是获得了空闲资源或是创建了一个新的资源。这个时候就要让系统给他分配内存了。跟进allocate()代码中，发现这是一个synchronized方法，保证了线程安全。（这块会有线程安全问题。为什么呢？）方法体判断了当前池状态（空闲状态或者测试中状态）然后更改状态位，置lastBorrowTime,lastUseTime,borrowedCount++等，然后返回boolean。
            我们可以推算出，当前的池资源状态可能会被另一个线程改写。有一种情况就是，空闲的连接还需要进行test和validate才能够正确分配。但是如果在test或validate阶段失败了，那线程就不能够被分配资源了，因为前后状态不一致了。所以需要allocate的同步操作来保证当时的空闲资源不被改写。
            */
            if (!p.allocate()) {
                //没有成功分配资源，当然p就应该置为null，等待重新进行遍历。
                p = null;
            }
            //到这里，分配成功的p应该进行校验阶段了。没有成功分配的p目前还是null，所以跳过下面的判断。
            if (p != null) {
                //从这开始p是有资源了
                try {
                    /*
                    private final PooledObjectFactory&amp;lt;T&amp;gt; factory;
                    通过池工厂（PooledObjectFactory.java）对返回来的实例重新初始化。因为PooledObjectFactory是个接口。所以，我以Jedis为T进行解析（JedisFactory.java），别的实际类型会有不同的行为，但是基本差不多。
        这个方法里就是获取了BinaryJedis，判断当前的库是不是库0.如果不是就就简单做个select操作。如果是的话什么都不做。
                    这块的设计有一个小心思，就是作者用这种代码结构来给开发者留出了很大的实现空间。
                    */
                    factory.activateObject(p);
                } catch (final Exception e) {
                    //激活异常
                    try {
                        //摧毁对象，释放资源
                        destroy(p, DestroyMode.NORMAL);
                    } catch (final Exception e1) {
                        // 摧毁的程序都报异常了，我可管不了了。采取鸵鸟算法。
                    }
                    //help GC
                    p = null;
                    //如果是新建的资源，就说明分配成功，但是激活失败。抛个错吧。
                    if (create) {
                        final NoSuchElementException nsee = new NoSuchElementException(
                                &quot;Unable to activate object&quot;);
                        //用什么错误原因呢？就用上面这个吧
                        nsee.initCause(e);
                        throw nsee;
                    }
                }
                /*
                如果分配成功了， 激活也成功了，并且开启了TestOnBorrow，逻辑进来再让我蹂躏下吧。如果失败了跳过这个逻辑吧。
                testOnBorrow的目的是不论资源是否是从池子里借的，都要在返回钱进行一次验证。如果失败了资源会被清除出池子并且毁掉。然后再向池对象尝试借一次。
                */
                if (p != null &amp;amp;&amp;amp; getTestOnBorrow()) {
                    boolean validate = false;
                    Throwable validationThrowable = null;
                    try {
                    /*
                    我依然以JedisFactory.java分析吧。
                    依然是首先获取一个BinaryJedis资源。判断连接的Port和设置的port是否相等。判断连接的host和设置额host是否相等。相等就返回true。否则就返回false。
                    */
                        validate = factory.validateObject(p);
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        validationThrowable = t;
                    }
                    //如果检查没有通过依然是摧毁。如果是新建的就报错。和上面激活的流程一样。
                    if (!validate) {
                        try {
                            destroy(p, DestroyMode.NORMAL);
                            destroyedByBorrowValidationCount.incrementAndGet();
                        } catch (final Exception e) {
                            // Ignore - validation failure is more important
                        }
                        p = null;
                        if (create) {
                            final NoSuchElementException nsee = new NoSuchElementException(
                                    &quot;Unable to validate object&quot;);
                            nsee.initCause(validationThrowable);
                            throw nsee;
                        }
                    }
                }
            }
        }
        //恭喜获得了一个有效的p资源。然后统计一下数据吧，比如消耗时间。
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
        //返回吧。记住返回的是一个PooledObject对象。真正的资源需要通过getObject(）获取。
        return p.getObject();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，看懂了jedis是如何从连接池中拿到资源的了。这里面经常有一些线程安全的判断，这也是难点所在，因为池化技术最重要的功能就是对线程资源的管理与利用。所以，代码中用了很多sychronize方法。不光这些，作者还要考虑到资源的释放和销毁还有扩展。&lt;/p&gt;

&lt;p&gt;　　最后看到了getObject()方法。为什么作者不直接暴露资源呢？为什么还要包一层呢？接下来我来分析一下吧。PooledObject是一个接口，我们先看看接口的描述是什么。详情看我的之前一篇文章&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/13/01.html&quot;&gt;common-pool对象池学习&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Defines the wrapper that is used to track the additional information, such as
 * state, for the pooled objects.
 * &amp;lt;p&amp;gt;
 * Implementations of this class are required to be thread-safe.
 * &amp;lt;/p&amp;gt;
 *
 * @param &amp;lt;T&amp;gt; the type of object in the pool
 *
 * @since 2.0
 */
 /*
 定义一个封装结构，这个封装结构使用来记录额外信息的。比如池资源的状态等。
 实现这个接口的class文件必须是线程安全的。（为什么呢？）
 
 */
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42340670/article/details/106876879&quot;&gt;对象池：commons-pool2源码解析：GenericObjectPool的borrowObject方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,java" /><summary type="html">　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。</summary></entry></feed>