<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://naffan.cn/feed.xml" rel="self" type="application/atom+xml" /><link href="https://naffan.cn/" rel="alternate" type="text/html" /><updated>2021-05-16T23:32:09+08:00</updated><id>https://naffan.cn/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">redis连接池源码分析</title><link href="https://naffan.cn/tech/2021/05/15/01.html" rel="alternate" type="text/html" title="redis连接池源码分析" /><published>2021-05-15T00:00:00+08:00</published><updated>2021-05-15T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/15/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/15/01.html">&lt;p&gt;　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。&lt;/p&gt;

&lt;p&gt;　　你在开发时，可以通过jedis连接redis。jedis支持直连模式和连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直连模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; public static void main(String[] arg){
        //1个实例
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379,100);
        jedis.incr(&quot;threadSafe&quot;);
        jedis.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/089f91fe840610d38104189b092092042801300138f312.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;直连&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　你不应该将一个redis实例共享给不同线程，时用时消的用法会造成产生很多的socket和tcp连接，即浪费时间又耗费资源，也提高了服务不可用的风险。如果你只是在本机环境或者使用者相对少的环境中使用，这种模式比较适宜。但是，如果你需要大量使用redis时，应该采用连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接池模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] arg){
        JedisPool pool = new JedisPool(new JedisPoolConfig(),&quot;localhost&quot;);
        try (Jedis jedis = pool.getResource()) {
            jedis.set(&quot;foo&quot;, &quot;bar&quot;);
            String foobar = jedis.get(&quot;foo&quot;);
            jedis.zadd(&quot;sose&quot;, 0, &quot;car&quot;); jedis.zadd(&quot;sose&quot;, 0, &quot;bike&quot;); 
            Set&amp;lt;String&amp;gt; sose = jedis.zrange(&quot;sose&quot;, 0, -1);
        }
        pool.close();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08af91fe84061087a50a189b09208b052801300138b9f703.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;连接池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　为了避免由单一redis实例引发的未知的服务不可用的风险，我们应该采用这种方案。这种方案背后的原理就是连接池（common-pool2）。当服务到达时服务会从连接池中borrow一个jedis连接，当用完或者发生错误时，连接会归还到连接池中。如果没有borrow到连接，那么服务就会报错且关闭。&lt;/p&gt;

&lt;p&gt;　　我的上一篇&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/12/01.html&quot;&gt;池化技术&lt;/a&gt;已经提到过连接池的概念，所以这篇文章是我想记录并分享我所学习到的jedis连接池的知识。通过上一段代码我们看到当jedisPool实例化以后，我们从pool中通过getResource来获取一个jedis实例。那么我们的代码研究就从这里开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/jedisPool.class
    public Jedis getResource() {
        //调用父集getResource
        Jedis jedis = (Jedis)super.getResource();
        //将当前实例暴露出dataSource，供后续redis操作使用
        jedis.setDataSource(this);
        return jedis;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/client/util/Pool.class
    //genericObjectPool是ObjectPool的实现，ObjectPool是common.pool2中关于池化对象的接口。其中定义了几个标准的对象方法，这些方法就是管理池的核心方法。
    protected GenericObjectPool&amp;lt;T&amp;gt; internalPool;
    ……
    public T getResource() {
        try {
            //通过调用common.pool2中的borrowObject，完成对jedis实例的借取。
            return this.internalPool.borrowObject();
            //如果出现了异常了，按照异常的分类进行处理。
        } catch (NoSuchElementException var2) {
            if (null == var2.getCause()) {
                throw new JedisExhaustedPoolException(&quot;Could not get a resource since the pool is exhausted&quot;, var2);
            } else {
                throw new JedisException(&quot;Could not get a resource from the pool&quot;, var2);
            }
        } catch (Exception var3) {
            throw new JedisConnectionException(&quot;Could not get a resource from the pool&quot;, var3);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在common-pool2中，对象池的核心接口叫做ObjectPool，他定义了对象池的实现的行为。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;addObject方法：往池中添加一个对象。池子里的所有对象都是通过这个方法进来的。&lt;/li&gt;
  &lt;li&gt;borrowObject方法：从池中借走到一个对象。借走不等于删除。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;returnObject方法：把对象归还给对象池。归还不等于添加。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;invalidateObject：销毁一个对象。这个方法才会将对象从池子中删除，当然这其中最重要的就是释放对象本身持有的各种资源。&lt;/li&gt;
  &lt;li&gt;getNumIdle：返回对象池中有多少对象是空闲的，也就是能够被借走的对象的数量。&lt;/li&gt;
  &lt;li&gt;getNumActive：返回对象池中有对象对象是活跃的，也就是已经被借走的，在使用中的对象的数量。&lt;/li&gt;
  &lt;li&gt;clear：清理对象池。注意是清理不是清空，改方法要求的是，清理所有空闲对象，释放相关资源。&lt;/li&gt;
  &lt;li&gt;close：关闭对象池。这个方法可以达到清空的效果，清理所有对象以及相关资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　在common-pool2中，objectPool的核心实现类就是GenericObjectPool。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectedPool
    @Override
    public T borrowObject() throws Exception {
        //getMaxWaitMillis()是BaseGenericObjectPool中设定的volatile类型的值，代表最长等待时间（毫秒），配置文件中的&quot;maxWait&quot;
        return borrowObject(getMaxWaitMillis());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接下来我们来分析下borrowObject方法，刚才说过borrowObject是实现了ObjectPool。那么先看一下这个接口中对borrowObject的描述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    /**
     * Obtains an instance from this pool.
     * &amp;lt;p&amp;gt;
     * Instances returned from this method will have been either newly created
     * with {@link PooledObjectFactory#makeObject} or will be a previously
     * idle object and have been activated with
     * {@link PooledObjectFactory#activateObject} and then validated with
     * {@link PooledObjectFactory#validateObject}.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * By contract, clients &amp;lt;strong&amp;gt;must&amp;lt;/strong&amp;gt; return the borrowed instance
     * using {@link #returnObject}, {@link #invalidateObject}, or a related
     * method as defined in an implementation or sub-interface.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * The behavior of this method when the pool has been exhausted
     * is not strictly specified (although it may be specified by
     * implementations).
     * &amp;lt;/p&amp;gt;
     *
     * @return an instance from this pool.
     *
     * @throws IllegalStateException
     *              after {@link #close close} has been called on this pool.
     * @throws Exception
     *              when {@link PooledObjectFactory#makeObject} throws an
     *              exception.
     * @throws NoSuchElementException
     *              when the pool is exhausted and cannot or will not return
     *              another instance.
     */
     /*
     这个method返回实例，这个实例将是一个被makeObject()创建的对象，或者是一个之前就是idle并且经过activateObject()激活过的并且经过validatedObject()验证过的对象。
     根据约定，客户端必须调用过returenObject(),invalidateObject()或者一个在子类中实现了归还逻辑的方法后归还。
     这个方法在池子耗尽时的表现没有指明具体如何处理（尽管他有可能被他的实现制定过。）
     */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接着我们再来看看这个方法的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectPool.class
    /**
     * Equivalent to &amp;lt;code&amp;gt;{@link #borrowObject(long)
     * borrowObject}({@link #getMaxWaitMillis()})&amp;lt;/code&amp;gt;.
     * &amp;lt;p&amp;gt;
     * {@inheritDoc}
     * &amp;lt;/p&amp;gt;
     */
     //通过获取配置中MaxWait配置，当做传输调用重载的方法。
    @Override
    public T borrowObject() throws Exception {
        return borrowObject(getMaxWaitMillis());
    }
    
    /**
     * Borrows an object from the pool using the specific waiting time which only
     * applies if {@link #getBlockWhenExhausted()} is true.
     * &amp;lt;p&amp;gt;
     * If there is one or more idle instance available in the pool, then an
     * idle instance will be selected based on the value of {@link #getLifo()},
     * activated and returned. If activation fails, or {@link #getTestOnBorrow()
     * testOnBorrow} is set to {@code true} and validation fails, the
     * instance is destroyed and the next available instance is examined. This
     * continues until either a valid instance is returned or there are no more
     * idle instances available.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If there are no idle instances available in the pool, behavior depends on
     * the {@link #getMaxTotal() maxTotal}, (if applicable)
     * {@link #getBlockWhenExhausted()} and the value passed in to the
     * {@code borrowMaxWaitMillis} parameter. If the number of instances
     * checked out from the pool is less than {@code maxTotal,} a new
     * instance is created, activated and (if applicable) validated and returned
     * to the caller. If validation fails, a {@code NoSuchElementException}
     * is thrown.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If the pool is exhausted (no available idle instances and no capacity to
     * create new ones), this method will either block (if
     * {@link #getBlockWhenExhausted()} is true) or throw a
     * {@code NoSuchElementException} (if
     * {@link #getBlockWhenExhausted()} is false). The length of time that this
     * method will block when {@link #getBlockWhenExhausted()} is true is
     * determined by the value passed in to the {@code borrowMaxWaitMillis}
     * parameter.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * When the pool is exhausted, multiple calling threads may be
     * simultaneously blocked waiting for instances to become available. A
     * &quot;fairness&quot; algorithm has been implemented to ensure that threads receive
     * available instances in request arrival order.
     * &amp;lt;/p&amp;gt;
     *
     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
     *                            to become available
     *
     * @return object instance from the pool
     *
     * @throws NoSuchElementException if an instance cannot be returned
     *
     * @throws Exception if an object instance cannot be returned due to an
     *                   error
     */
     /*
     当getBlockWhenExhausted()返回true时，需要提供等待时间从对象池中借出对象，
     如果有1个或多个空闲实例的话，就通过getLifo()方法，也就是先进先出的策略选择由哪个空闲实例承接工作。如果激活失败了，或者testOnBorrow设置为true并且检测失败了，这个实例就会销毁，接下来由下一个可用实例进行承接。这个流程一直持续，直到没有可用的实例可供使用或者没有空闲实例可供使用。
     如果在对象池中没有空闲实例了，接下来的走向取决于maxTotal,getBlockWhenExhausted()和传进来的等待时间参数决定。如果当前对象池中的实力数量小于maxtotal，一个新的实例将被创建，激活并且检测最终返回给调用者。如果检测失败，一个NoSuchElementException异常将被抛出。
     如果对象池已经占满了（也就是说没有可用的空闲实例并且没有容量可以被创建），这个方法要不堵塞（如果getBlockWhenExhausted设置为true的情况下才会堵塞）要不就抛出一个NoSuchElementException（相反getBlockWhenExhausted为false的情况）异常。具体阻塞的时间跟传入的borrowMaxWaitMillis时间大小有关。（还记得刚才说的maxWait的设置么？）
     当对象池已经耗尽，多个调用线程将被同时堵塞，他们一起等待可用的jedis实例接客。接客的规则采用公平算法。其实就是先到先被接~哈哈
     */
    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        //这一步就是检查一下对象池的状态，如果之前已经关闭了，就会抛出IllegalStateException异常。
        assertOpen();
        //移除已经被抛弃的实例
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;
                (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;
                (getNumActive() &amp;gt; getMaxTotal() - 3) ) {
            /*
            被抛弃的实例不为null
            borrow时去除被抛弃的实例
            空闲线程实例&amp;lt;2
            当前活动的实例数量大于最大实例数量-3
            */
            removeAbandoned(ac);
        }
        //定义一个PooledObject类型的对象，T是真正的实例对象。如jedis，db等。
        PooledObject&amp;lt;T&amp;gt; p = null;

        // Get local copy of current config so it is consistent for entire
        // method execution
        /*
        获取一个本地的拷贝，这个拷贝是目前的配置。这样就能够保证整体的一致性。
        这个getBlockWhenExhausted()最终是获取的一个volatile类型的值，这个值是从配置中获取的，代表当线程池满时，是否对新来的任务给予堵塞。但是，我们得注意volatile这个类型了，而且设计者在这个地方单独获取出来这个值，肯定是为了什么。接着往下看吧。
        */
        final boolean blockWhenExhausted = getBlockWhenExhausted();
        //是否为新建，请区别于created。为什么仅在这里定义了变量而没有初始化呢？
        boolean create;
        //当前的毫秒，用来就算
        final long waitTime = System.currentTimeMillis();
        //循环开始，第一次p=null开始循环
        while (p == null) {
            //初始化create=false，代表目前这个线程不是新建的。
            create = false;
            /*
            private final LinkedBlockingDeque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleObjects;
            idleObjects是一个阻塞有序队列，队列的类型是刚才的封装类型，封装的是实际的资源。从名字上可以看出，这里叫做空闲对象组
            可以看到，从空闲对象组里拿出第一个元素。pollFirst()是LinkedBlockingDeque.java中的方法。就是通过操作节点来把第一个节点删除并返回。
            */
            p = idleObjects.pollFirst();
            //如果p为空代表弹出的是null，说明没有空闲。那就创建一个新的对象。
            if (p == null) {
                p = create();
                //p可能会创建失败，创建失败的时候 create=false。 创建成功create=true
                if (p != null) {
                    create = true;
                }
            }
            //如果设置了对象池耗尽后堵塞等待的标示
            if (blockWhenExhausted) {
                if (p == null) {
                    //p没有创建成功
                    if (borrowMaxWaitMillis &amp;lt; 0) {
                        //如果没有设置为-1，只有这种情况会符合小于0.所以就直接从空闲对象组中获取第一个有效的空闲对象。这个方法有锁的实现，所以这块可能会一直堵塞着直到有一个空闲对象可以使用。
                        p = idleObjects.takeFirst();
                    } else {
                    //如果设置等待时间了，就在这段时间里获取。超过了就返回null
                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                TimeUnit.MILLISECONDS);
                    }
                }
                //到这里如果还是空，就说明没等待到空闲的资源了。所以就要报异常了。
                if (p == null) {
                    throw new NoSuchElementException(
                            &quot;Timeout waiting for idle object&quot;);
                }
            } else {
                //如果没有设置blockWhenExhausted标示且p是null，那真是获取不到资源了，因为池子已经被占满了。
                if (p == null) {
                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);
                }
            }
            /*
            到这里其实p应该不是null了，说明肯定是有资源了。有可能是获得了空闲资源或是创建了一个新的资源。这个时候就要让系统给他分配内存了。跟进allocate()代码中，发现这是一个synchronized方法，保证了线程安全。（这块会有线程安全问题。为什么呢？）方法体判断了当前池状态（空闲状态或者测试中状态）然后更改状态位，置lastBorrowTime,lastUseTime,borrowedCount++等，然后返回boolean。
            我们可以推算出，当前的池资源状态可能会被另一个线程改写。有一种情况就是，空闲的连接还需要进行test和validate才能够正确分配。但是如果在test或validate阶段失败了，那线程就不能够被分配资源了，因为前后状态不一致了。所以需要allocate的同步操作来保证当时的空闲资源不被改写。
            */
            if (!p.allocate()) {
                //没有成功分配资源，当然p就应该置为null，等待重新进行遍历。
                p = null;
            }
            //到这里，分配成功的p应该进行校验阶段了。没有成功分配的p目前还是null，所以跳过下面的判断。
            if (p != null) {
                //从这开始p是有资源了
                try {
                    /*
                    private final PooledObjectFactory&amp;lt;T&amp;gt; factory;
                    通过池工厂（PooledObjectFactory.java）对返回来的实例重新初始化。因为PooledObjectFactory是个接口。所以，我以Jedis为T进行解析（JedisFactory.java），别的实际类型会有不同的行为，但是基本差不多。
        这个方法里就是获取了BinaryJedis，判断当前的库是不是库0.如果不是就就简单做个select操作。如果是的话什么都不做。
                    这块的设计有一个小心思，就是作者用这种代码结构来给开发者留出了很大的实现空间。
                    */
                    factory.activateObject(p);
                } catch (final Exception e) {
                    //激活异常
                    try {
                        //摧毁对象，释放资源
                        destroy(p, DestroyMode.NORMAL);
                    } catch (final Exception e1) {
                        // 摧毁的程序都报异常了，我可管不了了。采取鸵鸟算法。
                    }
                    //help GC
                    p = null;
                    //如果是新建的资源，就说明分配成功，但是激活失败。抛个错吧。
                    if (create) {
                        final NoSuchElementException nsee = new NoSuchElementException(
                                &quot;Unable to activate object&quot;);
                        //用什么错误原因呢？就用上面这个吧
                        nsee.initCause(e);
                        throw nsee;
                    }
                }
                /*
                如果分配成功了， 激活也成功了，并且开启了TestOnBorrow，逻辑进来再让我蹂躏下吧。如果失败了跳过这个逻辑吧。
                testOnBorrow的目的是不论资源是否是从池子里借的，都要在返回钱进行一次验证。如果失败了资源会被清除出池子并且毁掉。然后再向池对象尝试借一次。
                */
                if (p != null &amp;amp;&amp;amp; getTestOnBorrow()) {
                    boolean validate = false;
                    Throwable validationThrowable = null;
                    try {
                    /*
                    我依然以JedisFactory.java分析吧。
                    依然是首先获取一个BinaryJedis资源。判断连接的Port和设置的port是否相等。判断连接的host和设置额host是否相等。相等就返回true。否则就返回false。
                    */
                        validate = factory.validateObject(p);
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        validationThrowable = t;
                    }
                    //如果检查没有通过依然是摧毁。如果是新建的就报错。和上面激活的流程一样。
                    if (!validate) {
                        try {
                            destroy(p, DestroyMode.NORMAL);
                            destroyedByBorrowValidationCount.incrementAndGet();
                        } catch (final Exception e) {
                            // Ignore - validation failure is more important
                        }
                        p = null;
                        if (create) {
                            final NoSuchElementException nsee = new NoSuchElementException(
                                    &quot;Unable to validate object&quot;);
                            nsee.initCause(validationThrowable);
                            throw nsee;
                        }
                    }
                }
            }
        }
        //恭喜获得了一个有效的p资源。然后统计一下数据吧，比如消耗时间。
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
        //返回吧。记住返回的是一个PooledObject对象。真正的资源需要通过getObject(）获取。
        return p.getObject();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，看懂了jedis是如何从连接池中拿到资源的了。这里面经常有一些线程安全的判断，这也是难点所在，因为池化技术最重要的功能就是对线程资源的管理与利用。所以，代码中用了很多sychronize方法。不光这些，作者还要考虑到资源的释放和销毁还有扩展。&lt;/p&gt;

&lt;p&gt;　　最后看到了getObject()方法。为什么作者不直接暴露资源呢？为什么还要包一层呢？接下来我来分析一下吧。PooledObject是一个接口，我们先看看接口的描述是什么。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Defines the wrapper that is used to track the additional information, such as
 * state, for the pooled objects.
 * &amp;lt;p&amp;gt;
 * Implementations of this class are required to be thread-safe.
 * &amp;lt;/p&amp;gt;
 *
 * @param &amp;lt;T&amp;gt; the type of object in the pool
 *
 * @since 2.0
 */
 /*
 定义一个封装结构，这个封装结构使用来记录额外信息的。比如池资源的状态等。
 实现这个接口的class文件必须是线程安全的。（为什么呢？）
 
 */
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42340670/article/details/106876879&quot;&gt;对象池：commons-pool2源码解析：GenericObjectPool的borrowObject方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,java" /><summary type="html">　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。</summary></entry><entry><title type="html">common-pool对象池学习</title><link href="https://naffan.cn/tech/2021/05/13/01.html" rel="alternate" type="text/html" title="common-pool对象池学习" /><published>2021-05-13T00:00:00+08:00</published><updated>2021-05-13T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/13/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/13/01.html">&lt;blockquote&gt;
  &lt;p&gt;问如果你要设计一个池化对象，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　设计一个T类型的池子，把T类型的资源都放到池子中。资源负责资源的事情，池子负责管理资源。管理池子要做到资源数量的管理，资源状态的管理，资源创建和销毁，线程安全，资源记录。还要考虑到复用的可能。&lt;/p&gt;

&lt;p&gt;　　让我们看看common-pool2的组成部分吧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ObjectPool: 存取和状态管理的实现。我们直接操作的线程池就是在这里定义的。这里定义的是如何获取和释放对象等操作。至于具体创建对象的代码，是由PooledObjectFactory来负责的。&lt;/li&gt;
  &lt;li&gt;PooledObject: 将真正的资源进行封装，封装的过程中添加一些附加信息，比如状态信息，时间等信息。这些信息方便再操作连接资源时完成特定的操作。&lt;/li&gt;
  &lt;li&gt;PooledObjectFactory:创建，初始化，销毁对象的具体实现的地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08e792838506108fff0318c10420d0022801300138d233.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//一个简单的池结果。它继承了Closeable接口，也就是说是可以关闭的数据源或目标。T是实际存在于池中的类型。
public interface ObjectPool&amp;lt;T&amp;gt; extends Closeable{
    
    //通过PooledObjectFactory创建对象或者通过其他机制放入空闲池对象。addObject也用来预热空闲池。
    void addObject() throws Exception, IllegalStateException,
            UnsupportedOperationException;
            
    //传入参数count，调用count次addObject。 方法的类型是default，也就是说这个方法直接实现方法体，不用实现者实现这个方法。
    default void addObjects(final int count) throws Exception {
        for (int i = 0; i &amp;lt; count; i++) {
            addObject();
        }
    }
    
    /*
    从对象池中获取一个实例。
    创建的实例要不是通过PooledObjectFactory中makeObject()新建出来的，要不就是用了前一个已经被PooledObjectFactory中activateObject()和PooledObjectFactory中validateObject()的空闲对象。
    activateObject()和validateObject()这两个方法需要在不同的池类型文件中自己去实现。
    */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
    
    //清除随机对象放回到池中作为空闲对象。释放这个对象的相关引用资源。在clear之前一定是经过PooledObjectFacotry的destroyObject()过。
     void clear() throws Exception, UnsupportedOperationException;
     
    //继承自Closeable接口，负责关闭并释放有关联系的系统资源。如果之前已经关闭了， 则调用此方法无效。
    @Override
    void close();
    
    //返回当前有多少实例从池对象中被借出了。如果返回的是负数代表这个信息不可用。
    int getNumActive();
    
    //返回当前当前池中有多少空闲对象。这个值是一个近似值，因为他只代表还没有创建成新资源的被借走的对象。我理解的是还没有被分配内存地址（allocate）。
    int getNumIdle();
    
    /*
    使池中对象失效
    按照约定，参数obj必已经被borrwoObject()或者被一个定义在子实现类中定义的方法实现了获取逻辑的对象。如果失败了就返回异常
    */
     void invalidateObject(T obj) throws Exception;
     
     //比上面多了一个DestoryMode。DestoryMode是个枚举，分别为普通摧毁和被禁的摧毁。最终调用的是PooledObjectFactory的destoryObject()。但不知为啥，我发现其实mode参数最终没有用上……。往下看，看到工厂的destoryObject（）
     default void invalidateObject(final T obj, final DestroyMode mode) throws Exception {
        invalidateObject(obj);
    }
    
    /*
    返回一个池对象中的实例。同invalidateObject()
    异常中会抛出IllegalStateException。原因是如果有任何（把除了已经被分配内存的有状态的资源，即被借出了的。或者返回一个对象超过一次以上或者返回一个从未被借出过的对象）操作就会触发这个异常
    */
     void returnObject(T obj) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
用来定义池对象的一个wrapper 接口，用于跟踪对象的附加信息，比如状态、创建时间、使用时间等。这个类的实现必须是线程安全的。
*/
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {

    //返回被包装的实际对象
    T getObject();

    //返回该对象的创建时间
    long getCreateTime();
    
    //以毫秒为单位获得该对象最后在活动状态中使用的时间(它可能仍然处于活动状态，在这种情况下后续调用将返回一个增加的值)。
    long getActiveTimeMillis();

    //借出的次数
    default long getBorrowedCount() {
        return -1;
    }

    //空闲时间
    long getIdleTimeMillis();

    //上次借用时间
    long getLastBorrowTime();

    //上次归还时间
    long getLastReturnTime();

     /**
     * 返回上次使用时间的一个估计值,如果Pooled Object实现了TrackedUse接口
     * 那么返回值将是TrackedUse.getLastUsed()和getLastBorrowTime()的较大者，
     * 否则返回值和getLastBorrowTime()相等
     */
    long getLastUsedTime();

     /*
     因为接口继承了Comparable接口。所以这个接口需要实现自己的排序逻辑。
     默认是按照空闲时间排序的。
     */
    @Override
    int compareTo(PooledObject&amp;lt;T&amp;gt; other);

    @Override
    boolean equals(Object obj);

    @Override
    int hashCode();

    @Override
    String toString();

    //尝试将池对象置于PooledObjectState.EVICTION状态，即收回
    boolean startEvictionTest();

     //是否完成了收回测试
    boolean endEvictionTest(Deque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleQueue);

    //分配内存，这个比较重要。因为连接池中的资源被分配后才能算真正的解除。分配内存的过程中可能会出现抢占资源的情况，所以会发生异常。反正，最终返回ture/false来代表是否分配内存成功，即完成了borrow，状态改为PooledObjectState.ALLOCATED
    boolean allocate();

    //与上面一个方法作用相反,将PooledObjectState.ALLOCATED置为PooledObjectState.IDLE
    boolean deallocate();

    //将对象置为PooledObjectState.INVALID无效状态
    void invalidate();

    //设置是否记录对象使用的堆栈信息,可用于池泄漏时问题追溯
    void setLogAbandoned(boolean logAbandoned);

     /*
     设置记录堆栈信息时的策略，是全量还是只记泄露的信息。
     设置为false时，泄露信息只包括调用类的信息而不是方法名。
     设置为数字时，制使用包含完整堆栈跟踪信息的堆栈遍历机制；否则，如果可能，使用更快的实现。
     参数是自common-pool2-2.7.0开始有的。
     */
    default void setRequireFullStackTrace(final boolean requireFullStackTrace) {
        // noop
    }

     //记录当前对象最后一次使用的堆栈信息
    void use();

    //打印对象的调用堆栈信息
    void printStackTrace(PrintWriter writer);

    //返回对象目前的状态
    PooledObjectState getState();

    //标记该对象发生了泄漏
    void markAbandoned();

    //标记该对象正在被归还到对象池
    void markReturning();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
这个接口主要提供给ObjectPool接口使用。因为这个接口定义了池中对象的生命周期相关的所有方法。
按照约定，以下情况ObjectPool会代理到PooledObjectFactory中：
1.不论何时创建一个实例调用makeObject()时
2.当实例在借出之前，已经处于passivated，每次实例在调用activateObject时
3.当一个实例被激活时。当一个实例已经返回到池里并且正在做检查，又在passivated（卸载）之前时。当acitvated实例且确定能被借出时
4.每个实例返回到连接池后，在调用passivateObject()时
5.当实例正在从池中销毁时，destoryObject()调用时

这个工厂必须确保线程安全，工厂只需要ObjectPool保证操作的实际类型和工厂一致即可。
*/
public interface PooledObjectFactory&amp;lt;T&amp;gt; {
  
   //创建一个资源实例，这个资源实例可以被封装起来。
  PooledObject&amp;lt;T&amp;gt; makeObject() throws Exception;

   /*
   销毁一个不再被池子需要的实例。用的销毁模式是normal。
   实现了这个方法的类需要注意的是：方法内没有任何保证资源处于什么状态和实现的方法如何去处理非预期的errors
   所以，实现者需要考虑到对象没有被摧毁，即被垃圾收集器忘掉了，从而永远储存在了内存中。
   */
  void destroyObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //同上，只是采用了DestoryMode模式。但是其实感觉是mode根本没用用上。。。
  default void destroyObject(final PooledObject&amp;lt;T&amp;gt; p, final DestroyMode mode) throws Exception {
      destroyObject(p);
  }

  //确保实例能够安全的返回到池子里
  boolean validateObject(PooledObject&amp;lt;T&amp;gt; p);

   //重新初始化池返回的实例
  void activateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //卸载要返回到空闲对象池的实例
  void passivateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，我分析完了三个接口。三个接口各司其职，互相协助。我用一张我画的图片来描述的话，一个管对象的打包，一个管对象的创建，一个管对象的进出口。用jedis举例的话就是，jedis资源打包成封装格式，封装格式被工厂创建，创建成真正使用的资源。这些资源再被借出或者归还。多么的形象哈哈。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08eede83850610aaa80818b90e20b8082801300138e0f401.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　下面这张图是这三个接口相关的关系。
&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08cbdf83850610abd30818850620bb032801300138af8401.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　另外，上面的接口都用到了对象的状态，对象状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public enum PooledObjectState {
    /**
     * 在队列中,未被使用,空闲状态。调用allocate()方法后对象应该被置于该状态
     */
    IDLE,

    /**
     * 已分配,在使用中,调用allocate()方法后应该讲对象置于该状态
     */
    ALLOCATED,

    /**
     * 在队列中, 当前正在测试，可能会被回收。在此状态被借出后状态回被置为EVICTION_RETURN_TO_HEAD
     */
    EVICTION,

    /**
     * 不在队列中。当借用该对象时发现对象，发现正在进行回收测试，故将EVICTION更
     * 改EVICTION_RETURN_TO_HEAD，表明曾经在回收过程中被借出，在回收完后它应该从新添加到队列的头部。
     */
    EVICTION_RETURN_TO_HEAD,

    /**
     * 在队列中,目前正在进行校验
     */
    VALIDATION,

    /**
     * 不在队列中，当前正在验证。当对象从池中被借出，
     * 在配置了testOnBorrow的情况下，对像从队列移除和进行预分配的时候会进行验证(借用时校验)
     */
    VALIDATION_PREALLOCATED,

   /**
     * 不在队列中，正在进行验证。从池中借出对象时，发现对象正在进行校验，并将对象状态改为该状态
     */
    VALIDATION_RETURN_TO_HEAD,

    /**
     *无效的，并且将要或已经被销毁。
     */
    INVALID,

    /**
     * 泄漏的
     */
    ABANDONED,

    /**
     *归还中,调用markReturning()方法会将对象状态改为此状态，表明正在归还一个对象
     */
    RETURNING
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq447995687/article/details/80413227&quot;&gt;commons-pool2源码走读(一)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liyantianmin/article/details/86591742&quot;&gt;common-pool对象池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="pool,java" /><summary type="html">问如果你要设计一个池化对象，你会怎么做？</summary></entry><entry><title type="html">池化技术</title><link href="https://naffan.cn/tech/2021/05/12/01.html" rel="alternate" type="text/html" title="池化技术" /><published>2021-05-12T00:00:00+08:00</published><updated>2021-05-12T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/12/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/12/01.html">&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3a3f5840610fee80b18b90e20b8082801300138d074.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　池化技术就是把一些能复用的实例放在一起，一般指的是内存里，而池这个概念也是一个虚拟的概念。这样做的好处是省去了每次消耗在新建、销毁这些实例的时间，从而提高了整体服务性能。在开发中，我们经常遇到的就是数据库的连接池和多线程的线程池。连接池的管理是核心。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;数据库连接池&quot;&gt;数据库连接池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　数据库包括关系型数据库和非关系型数据库两种。关系型数据库指的是mysql，非关系型数据库指的是redis。&lt;/p&gt;

&lt;p&gt;　　mysql连接池有两个重要的配置：最小连接数和最大连接数。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前连接数小于最小连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;如果连接池中有空闲连接，则使用空闲连接。
3。 如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接。这等价于建立一个新的连接。这些连接使用完成不会立马清除，而是放在池中等待复用最终空闲超过一段时间后自动释放。&lt;/li&gt;
  &lt;li&gt;如果当前连接数大于等于最大连接数，并且没有空闲连接了，则进入等待队列，在超时时间内等待空闲连接。&lt;/li&gt;
  &lt;li&gt;超时之后，则提示超时失败。获取数据库连接失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　redis连接池有3个重要的配置：最大连接数，最小空闲数，最大空闲数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前连接小于最大连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;当前连接数大于等于最大连接数，超出的连接进入等待队列&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;，判断是否开启&lt;code&gt;blockWhenExhausted&lt;/code&gt;，是则等待获取连接，否则抛错连接池已耗尽。&lt;/li&gt;
  &lt;li&gt;当前连接数小于最小空闲数，则预热最小空闲数连接。&lt;/li&gt;
  &lt;li&gt;当前连接数大于最大空闲数，则强制销毁这些多出来的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;线程池&quot;&gt;线程池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　JDK1.5中引入的ThreadPoolExecutor就是一种线程池的实现，它有两个重要的参数：coreThreadCount和maxThreadCount。这两个参数控制着线程池的执行过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程数少于coreThreadCount时，则创建新的线程处理请求。&lt;/li&gt;
  &lt;li&gt;如果当前线程数大于coreThreadCount则将超出的任务进队列，由当前空闲的线程执行。&lt;/li&gt;
  &lt;li&gt;当队列中的任务对接满时，则继续创建线程，直到maxThreadCount。&lt;/li&gt;
  &lt;li&gt;当前线程数达到maxThreadCount时还有新的任务，就将其按照抛弃策略进行抛弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc7xbdxj67j30wk0ouqb3.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JDK线程池提交任务示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　连接池和线程池在开发过程中并不陌生，但是想真正弄懂他们还是需要借助阅读源码的帮助。在使用上如果遇到了一些困惑的话，可以查阅相关资料或者探索源码如何解决的。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">一种优化连接的方案，各种地方都有可能用到这种技术</summary></entry><entry><title type="html">我对JVM的解析和总结</title><link href="https://naffan.cn/tech/2021/05/11/01.html" rel="alternate" type="text/html" title="我对JVM的解析和总结" /><published>2021-05-11T00:00:00+08:00</published><updated>2021-05-11T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/11/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/11/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;java运行时数据区&quot;&gt;Java运行时数据区&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;jvm会将内存划分为若干个不同的数据区域。如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://cdn.jikewenku.com/wp-content/uploads/2021/01/74e01322f26270ccfe235ead6215d271.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JVM运行时数据区域&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序计数器：线程私有，指向当前线程正在执行的字节码指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈：java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧压入栈，当方法&lt;code&gt;正常返回&lt;/code&gt;或者&lt;code&gt;抛出未捕获的异常&lt;/code&gt;时，栈帧就会出栈。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jmm-java内存模型&quot;&gt;JMM Java内存模型&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;堆的内存划分&quot;&gt;堆的内存划分&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;gc垃圾回收&quot;&gt;GC垃圾回收&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;hotspot-虚拟机详解&quot;&gt;HotSpot 虚拟机详解&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h1&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot,jvm" /><summary type="html">Java运行时数据区</summary></entry><entry><title type="html">spring-data-redis中的Jackson2JsonRedisSerializer研读</title><link href="https://naffan.cn/tech/2021/05/07/01.html" rel="alternate" type="text/html" title="spring-data-redis中的Jackson2JsonRedisSerializer研读" /><published>2021-05-07T00:00:00+08:00</published><updated>2021-05-07T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/07/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/07/01.html">&lt;p&gt;spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。&lt;/p&gt;

&lt;p&gt;首先，Jackson2JsonRedisSerializer一共有6个方法。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Jackson2JsonRedisSerializer(JavaType javaType)&lt;/td&gt;
      &lt;td&gt;构造方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;deserialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;serialize&lt;/td&gt;
      &lt;td&gt;实现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;setObjectMapper&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getJavaType&lt;/td&gt;
      &lt;td&gt;独有&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonRedisSerializer(Class&lt;T&gt; clazz)&lt;/T&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Creates a new {@link Jackson2JsonRedisSerializer} for the given target {@link Class}.
	 *
	 * @param type
	 */
	public Jackson2JsonRedisSerializer(Class&amp;lt;T&amp;gt; type) {
		this.javaType = getJavaType(type);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据传入的参数类型，通过getJavaType方法指定为databind的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
	 * Returns the Jackson {@link JavaType} for the specific class.
	 * &amp;lt;p&amp;gt;
	 * Default implementation returns {@link TypeFactory#constructType(java.lang.reflect.Type)}, but this can be
	 * overridden in subclasses, to allow for custom generic collection handling. For instance:
	 *
	 * &amp;lt;pre class=&quot;code&quot;&amp;gt;
	 * protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
	 * 	if (List.class.isAssignableFrom(clazz)) {
	 * 		return TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, MyBean.class);
	 * 	} else {
	 * 		return super.getJavaType(clazz);
	 * 	}
	 * }
	 * &amp;lt;/pre&amp;gt;
	 *
	 * @param clazz the class to return the java type for
	 * @return the java type
	 */
	protected JavaType getJavaType(Class&amp;lt;?&amp;gt; clazz) {
		return TypeFactory.defaultInstance().constructType(clazz);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaType类属于com.fasterxml.jackson.databind包。它是一种令牌类的基类，用于保存信息和反序列化器的key。通过getJavaType方法经过反射来构造出指定的class。我们看到其中应用到了TypeFactory,用TypeFactory的作用就是快速的获取到clazz相对应的具体类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final class TypeFactory implements java.io.Serializable
{
    //将clazz传入，通过_formAny方法构造。Class&amp;lt;?&amp;gt; 是实现了Type接口
    public JavaType constructType(Type type) {
        return _fromAny(null, type, EMPTY_BINDINGS);
    }
    
    ....
    
     /**
     * Factory method that can be used if type information is passed
     * as Java typing returned from &amp;lt;code&amp;gt;getGenericXxx&amp;lt;/code&amp;gt; methods
     * (usually for a return or argument type).
     */
    protected JavaType _fromAny(ClassStack context, Type type, TypeBindings bindings)
    {
        JavaType resultType;

        // simple class?
        if (type instanceof Class&amp;lt;?&amp;gt;) {
            // Important: remove possible bindings since this is type-erased thingy
            //判断type是一个简单class。然后调用_formClass
            //ClassStack是一个工具类，用来记录调用栈信息的上下文。
            //EMPTY_BINDINGS是TypeBindings中的常量。TypeBindings是用于解析给定类的类型参数的助手类。也就是说这个常量为空绑定关系。
            resultType = _fromClass(context, (Class&amp;lt;?&amp;gt;) type, EMPTY_BINDINGS);
        }
        // But if not, need to start resolving.
        else if (type instanceof ParameterizedType) {...}
    ...
    }
    
    /**
     * @param bindings Mapping of formal parameter declarations (for generic
     *   types) into actual types
     */
    protected JavaType _fromClass(ClassStack context, Class&amp;lt;?&amp;gt; rawType, TypeBindings bindings)
    {
        // Very first thing: small set of core types we know well:
        //第一件事就是通过rawType来判断是哪种众所周知的简单类型。首先判断是否是原始类型，并且是否是BOOL，INT，LONG。如果不是就是String，Object。否则返回null
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance
        final Object key;
        if ((bindings == null) || bindings.isEmpty()) {
        //key是这种Bool Int Long String object中的一种
            key = rawType;
        } else {
            key = bindings.asKey(rawType);
        }
        //_typeCache是一个LRUMap。LRUMap其实底层是个ConcurrentHashMap。它用来帮助我们避免核心类型的重复解析。尤其为了泛型的解析。
        result = _typeCache.get(key); // ok, cache object is synced
        if (result != null) {
            return result;
        }
        //一般到这里就结束了。但是，如果通过我们传入的rawType没有找到绑定的关系，那就有可能是个复杂结构的结构体（递归引用）。接下来就需要通过调用栈来追踪整个结构了。
        // 15-Oct-2015, tatu: recursive reference?
        if (context == null) {
            context = new ClassStack(rawType);
        } else {
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                //可以看到，resolvedRecursiveType这个方法是用来自我引用的一个内部类型。他继承自TypeBase，TypeBase继承自javaType。
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
            }
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
        }
        //到这里，可以将递归引用的结构解析到context变量里了。
        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
         //首先解析父类型层次结构   
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                //返回的是一个JavaType的数组。
                //如果是个超接口（superInterface），通过反射返回的必须是实际用过的类型（interface or class）。
                //如果是个class，返回的是个数组，数组中包含着所有实现过的接口。
                //如果是个interface，返回的是个数组，数组中包含所有直接继承过的接口。
                //如果是个class或者interface，就返回个一个长度为0的数组。
                //如果是基础类型或者void，就返回一个长度为0的数组。
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so cannot drop those
                //返回class表示的实体(类、接口、基本类型型或void)的直接超类
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, &quot;simple&quot; class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
            }
        }
        context.resolveSelfReferences(result);
        // 16-Jul-2016, tatu: [databind#1302] is solved different way, but ideally we shouldn't
        //     cache anything with partially resolved `ResolvedRecursiveType`... so maybe improve
        if (!result.hasHandlers()) {
            _typeCache.putIfAbsent(key, result); // cache object syncs
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Jackson2JsonReisSerializer(JavaType javaType)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另一个构造方法，参数是JavaType类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;deserialize(@Nullable byte[] bytes)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;反序列化方法，可为null的byte数组为参数。如果是空或者null的话，返回null。否则，通过ObjectMapper将byte数组进行反序列化。&lt;/p&gt;

&lt;p&gt;ObjectMapper提供读和写JSON的能力。不论是转成POJO还是从POJO转出，或者是转成JSON还是从JSON转出，还是一些相关的转化功能。ObjectMapper都可以高定制化的兼容不同种的JSON格式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;serialize(@Nullable Object t)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;序列化方法，同上。t如果为null，则返回空byte数组。否则，将t序列化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setObjectMapper(ObjectMapper objectMapper)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法比较有用，它可以用来自定义JSON序列化进程的。相关设置可以参见ObjectMapper.java中的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ObjectMapper mapper = new ObjectMapper();
		mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		serializer.setObjectMapper(mapper);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getJavaType(Class&amp;lt;?&amp;gt; clazz)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法是被Jackson2JsonRedisSerializer方法调用的，用途就是返回指定class的jackson格式。&lt;/p&gt;

&lt;p&gt;通过简单阅读了这个类的源码，我对这个类也有了大致的了解。作为spring-data-redis对redis的封装中的一个策略，这个策略满足了要保存的数据有比较复杂的层级结构，而且效率还是非常高的。建议用这个策略进行保存，只是可读性差了一些。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">spring-data-redis是springboot的一个对redis的封装包。它是springFramework的一个默认的redis驱动jar包。spring已经在这个jar包里面封装了redis各种功能。其中的redisSerializer接口就是用来序列化存入redis数据格式的一种策略。spring官根据不同种情况已经为我们内置了很多序列化器，我们可以通过查看有哪些类实现了redisSerializer接口就可以得知。下面我就总结一下我对其中一种策略-jackson2Json的序列策略的研读。</summary></entry><entry><title type="html">springboot的策略模式</title><link href="https://naffan.cn/tech/2021/05/02/01.html" rel="alternate" type="text/html" title="springboot的策略模式" /><published>2021-05-02T00:00:00+08:00</published><updated>2021-05-02T00:00:00+08:00</updated><id>https://naffan.cn/tech/2021/05/02/01</id><content type="html" xml:base="https://naffan.cn/tech/2021/05/02/01.html">&lt;p&gt;策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。&lt;/p&gt;

&lt;p&gt;当你用springboot的时候，会牵扯到如何将类委托给spring容器，如果你按照策略模式的传统写法，就会遇到类似问题。所以，我们应该将不同的策略实现公用的接口，也就是面向接口编程。&lt;/p&gt;

&lt;p&gt;首先，我们定义一个接口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ICreateOrderAndMissionStrategy {

	/**
	 * 创建订单和任务。不同的策略应该对这个方法进行重写
	 */
	void doCreateOrderAndMission(KCameraOrderAbstractCreateDTO oscVo);

	/**
	 * 获取类型，每个策略都需要你定义一个类型，比如业务1就定义为1，比如业务2就定义为2。当然，你也可以定义成不同类型。按照你的习惯即可
	 * @return Integer
	 */
	Integer getType();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，构造一个类，这个类的目的就是驱动你的策略。同时，也是这个类将你的策略装配到spring中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Service
public class CreateOrderMissionStrategyService {

	/**
	 * 策略类中的成员map变量，保存各种策略类.可以看到我将ICreateOrderAndMissionStrategy接口构造成一个map。通过我之前定义的数字来获取value。也就是能够拿到相应的策略。
	 */
	Map&amp;lt;Integer, ICreateOrderAndMissionStrategy&amp;gt; strategyMap = new HashMap&amp;lt;&amp;gt;(8);

	/**
	 * 构造函数，通过将spring管理的所有策略类注册进成员map变量中。
	 * 这个方法很重要，因为它驱动了策略类的装配。
	 * @param strategies List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt;
	 */
	public CreateOrderMissionStrategyService(List&amp;lt;ICreateOrderAndMissionStrategy&amp;gt; strategies) {
		for (ICreateOrderAndMissionStrategy strategy : strategies) {
			strategyMap.put(strategy.getType(), strategy);
		}
	}

	/**
	 * 处理策略程序。通过strategyType得到我想要的策略类，然后进行调用
	 * @param strategyType 策略类型
	 * @param oscVo 业务变量
	 * @throws BizException 业务异常
	 */
	public void executeStrategy(Integer strategyType, KCameraOrderAbstractCreateDTO oscVo) throws BizException{
		ICreateOrderAndMissionStrategy strategy = strategyMap.get(strategyType);
		if(strategy == null){
			throw new BizException(&quot;未找到事件处理实现类，strategyType:&quot; + strategyType);
		}
		strategy.doCreateOrderAndMission(oscVo);
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，我可以开始根据不同的业务进行不同的策略了。我举两个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略A
public class AStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.A.getCode();  // 这个是我定义的策略类型的枚举类。我A为1，B为2
	}
	
	/**
	 * A策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这个是策略B
public class BStrategy implements ICreateOrderAndMissionStrategy {

    @Override
	public Integer getType() {
		return BizEnum.B.getCode();  	}
	
	/**
	 * B策略的实现逻辑
	 */
	@Override
	public void doCreateOrderAndMission(ParamDTO paramDTO) {
	   .........
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在真正的逻辑中，我们就可以直接使用这个模式了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Demo{

    public void Business(){
        String[] taskTypeList = oscVo.getTaskTypes().split(&quot;,&quot;);
			for (String i : taskTypeList) {
    createHouseSourceOrderAndMission.executeStrategy(Integer.valueOf(i),oscVo);
            			}
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot" /><summary type="html">策略模式的目的是将不同的策略封装起来，每个策略形成一个一个类文件。你可以进行任意的替换。策略模式遵循开闭原则，意即对扩展保持开放，对修改保持关闭。</summary></entry><entry><title type="html">2021年的五一劳动节</title><link href="https://naffan.cn/life/2021/05/01/01.html" rel="alternate" type="text/html" title="2021年的五一劳动节" /><published>2021-05-01T00:00:00+08:00</published><updated>2021-05-01T00:00:00+08:00</updated><id>https://naffan.cn/life/2021/05/01/01</id><content type="html" xml:base="https://naffan.cn/life/2021/05/01/01.html">&lt;blockquote&gt;
  &lt;p&gt;我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2021年的劳动节是自疫情之后中国的第一个能够群体聚集的首个节日。为了这个节日中国政府将五一前后的周末各调休了一天，用来凑出这次有五天假期的劳动节。就是因为这五天的假期，全国人名举国出游。很庆幸，我们没有参与其中，我们只是全程在抖音上参观景点的盛景。看着视频里“我后悔了，不想出来玩了，我想回家”，心中虽有偷着乐的愉悦心情，但也还是计划着接下来的几天出去走走，只是仅在北京周边自驾玩一玩。&lt;/p&gt;

&lt;p&gt;五一前一周末我从网上订购了一款4人帐篷以及户外炊具，就想着用特斯拉载着家人去环郊，找一片草坪停下车来，打开帐篷，烧着咖啡，看着风景，带上一本好书，悠闲的享受整个下午。&lt;/p&gt;

&lt;p&gt;五一当天，雷打不动的还是固定节目-跟家人们吃饭。说心里话，这种正日子一起坐下来吃个饭，聊聊天，悠闲的慢生活是最佳选择。但是，妈妈偏偏把之前商量好的包饺子改成了做家常饭。妈妈跟我说回来吃一次不容易，还是想给我做一些我喜欢吃的菜。结果是，大家坐在一起吃饭，还不到10分钟就已经吃完了，加上收拾碗筷和擦桌子洗碗，总共加起来不超过20分钟。就这样，难得的中午时光被这么临时的改动浪费了。其实，在前几天我已经跟他们沟通叫上双方的服务一起在我家的小院烤肉，可是在做决定的那天下午，手机的头条发来五一会有8级大风，于是我才同意的改为在705吃饺子。这么说，其实这都是天意。我也没得办法。&lt;/p&gt;

&lt;p&gt;下午，父母是需要睡午觉的，但是我和媳妇不困，不想睡觉了。于是，我提议我们俩去新华百货转一转，让父母睡完觉再跟我联系，到时候一起赶赴大家庭的晚餐聚会。跟媳妇转商场没有什么说的，就是逛和买。但想喝一杯DQ的脏脏奶昔，结果发现到了新街口豁口，DQ却在装修，查了一下最近的DQ门店远在2.4km以外，于是作罢。媳妇提议去对面的咖啡店喝杯咖啡，因为之前媳妇和她闺蜜去喝过，感觉很好喝，所以她建议我跟她再去一次。首先我是拒绝的，但是我也没有什么好的建议，于是妥协了。不过，也是因为这次妥协，我也真正意义的喝上了一杯手磨的咖啡。也学会了一些品咖啡的方法。咖啡的苦要像巧克力的苦，酸要像果酸，咽下去的时候喉咙会感受到回甘。老婆给我点的咖啡应该还是不错的，只是自己没有经验，我也就学着尝试品尝了。回想之前在回龙观的酒吧，老板教我品威士忌，两者相比较来说方法有些相像。&lt;/p&gt;

&lt;p&gt;晚上，大家的聚会还是比较圆满的，只是餐馆包间的桌子比较小。很多人都是侧着身吃饭，这可把我的三姨尴尬坏了，看得出来三姨对这次选地的不满意，但是我也不想让三姨觉得难过，所以还是以很好吃夸赞了这次晚饭，只是我能感觉的出来三姨知道我是在宽慰她。&lt;/p&gt;

&lt;p&gt;回到705写下了这篇日记。晋升的失败没有跟妈妈说，我怕她为我担心，我的不干不应写在脸上。我需要时间再次审视自己的缺陷。在接下来的一年中补齐这块短板。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="劳动节" /><summary type="html">我国劳动节是一个全球性的节日，中国的劳动节可以追溯到1918年，很多先进人士上海、杭州、汉口等城市向人们宣传五一劳动节。后来，北京、上海等地的工人纷纷到街上游行，就这样，五一劳动节在中国流传开来。1949年中华人民共和国成立后，我国将每年的五月一日定为劳动节。</summary></entry><entry><title type="html">阴平古道，邓艾灭蜀</title><link href="https://naffan.cn/thinking/2020/05/16/01.html" rel="alternate" type="text/html" title="阴平古道，邓艾灭蜀" /><published>2020-05-16T00:00:00+08:00</published><updated>2020-05-16T00:00:00+08:00</updated><id>https://naffan.cn/thinking/2020/05/16/01</id><content type="html" xml:base="https://naffan.cn/thinking/2020/05/16/01.html">&lt;blockquote&gt;
  &lt;p&gt;早入蜀都,先到先得。偷渡阴平，直取蜀汉！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这是三国杀中邓艾的武将台词。从这两句中我感受最多的是一种豪言壮志，和一丝凄凉。一个为魏国，一个为蜀国。&lt;/p&gt;

&lt;p&gt;　　不知什么时候，我了解三国后就把蜀国当做了三国的主角，魏国当成了三国的反派，而吴国只是一个配角，但是在读完了关羽败走麦城后，我把吴国定性为了非盗既奸的小人国家。这些都是我个人的主观色彩使然，其实在漫漫的历史长河中，任何人任何事都有两面性，历史不是被任何一个人任何一件事就能够主导或者改变的。三国中有很多名场面，很多都耳熟能详，我也略知一二。但是，今天我不知道哪来的兴趣，想了解一下让蜀国的灭亡直接的战役，想看看这场战役中到底是谁占有举足轻重的作用。&lt;/p&gt;

&lt;p&gt;　　我18年去过重庆和成都，对当地的地形有了一定的了解，我每次去重庆的时候都要坐一夜的火车，但凡白天我看到的都是连续的隧道，正因为这里的山多，所以我们要进入四川就要穿过众多的山脉，相比于重庆来说，成都的地形较为平坦。这种地势在今天看来当然已经有科技帮我们客服了这种物理上的限制，但是对于古代的人们，可不会轻易的选择凿山穿洞的方法向前进行。然而，当时邓艾灭蜀打造的阴平小道是怎么实现的？这个问题让我颇感兴趣。&lt;/p&gt;

&lt;p&gt;　　历史上讲魏国攻打蜀国（公元263年秋）时，钟会带领20（有说10万）万大军，因剑门关是进入成都平原的最后一道重要关隘，所以被姜维死死地挡在了剑阁之外。因为，一般入蜀只有这条道可以通过，原因是周围山脉层峦叠嶂。就算钟会有百万雄师，也只能挨个从剑阁通过。那么剑阁这个地方到底长什么样子呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;何为剑阁道？剑阁道，属金牛道（石牛道）南段。其行程是从昭化（葭萌关）越牛头山，入剑门至剑阁县。此段乃石牛道上有名的险峻去处，约100公里，沿途坡陡路险，十分难行。特别是未入剑门关前的15公里，原本无路，三国时，诸葛亮北伐在峭壁悬崖上修了15公里阁道，剑阁道也由此而得名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://gss0.baidu.com/70cFfyinKgQFm2e88IuM_a/baike/pic/item/1e30e924b899a9012afdc0c314950a7b0308f57f.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;剑门关&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08d1bb848506108ba32b18ee04209906280130013881bc02.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;剑门关&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这就是剑门关，被誉为“蜀北之屏障，两川之咽喉”的雄关险隘。目前剑门关是我国5A级旅游景区，国家级风景名胜区，全国100个红色经典旅游景区之一，已列入世界文化遗产预备名单。剑门关两边有着大小剑山72峰，峰峦叠嶂，近处是刀削斧劈似的悬崖峭壁。古蜀道穿过关楼，厚重的青石板沿着山壁一级一级伸向远方。仰望关搂，耳边的风声仿佛成了万人攻关的呐喊声。&lt;/p&gt;

&lt;p&gt;　　就是这么一个极其重要的战略宝地，易守难攻，那为啥蜀国还是被邓艾掏了老窝了呢？这就要说到邓艾的丰功伟绩了，这就是偷渡阴平了。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3c584850610a4931618ff0420bf032801300138d28802.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;灭蜀路线图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　从图中，我们可以看到。魏国大军分为三路，分别由邓艾，诸葛绪，钟会进攻蜀都。中间的军事过程可以参见下面的这个视频。p.s.这里的诸葛绪因为退后30里让姜维南下的事让他躲过了一劫，最终是这三个人里面下场最好的人。&lt;/p&gt;
&lt;div align=&quot;middle&quot;&gt;
&lt;script&gt;
	document.write(&quot;&lt;iframe src='//player.bilibili.com/player.html?aid=413378551&amp;bvid=BV1FV411y7jP&amp;cid=197675942&amp;page=1'allowfullscreen='true'&gt; &lt;/iframe&gt;&quot;);
&lt;/script&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果我是邓艾，当时我会怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　当时时局姜维正在迎战邓艾，邓艾位于进军路线的西头。诸葛绪位于中间向桥头进军，意图与邓艾前后夹击姜维。钟会在最东边，钟会是第一次带重兵打仗，是当时进军路线最好，最有可能攻入蜀都的。当姜维得知汉中被钟会攻破后，马上掉头去剑阁防守。由于原来是邓艾牵制姜维，可现在邓艾被凉在旁边了，眼前的方向貌似只有追着姜维去剑阁这一条路线了。&lt;/p&gt;

&lt;p&gt;　　接下来我对比一下当时的&lt;a href=&quot;https://baike.baidu.com/item/%E9%82%93%E8%89%BE/6770?fr=aladdin&quot;&gt;邓艾&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/%E9%92%9F%E4%BC%9A/18087?fr=aladdin&quot;&gt;钟会&lt;/a&gt;身世经历。可以看到，钟会从小生活的环境要比邓艾好且有才数技艺，博学多闻，尤其精通玄学，弱冠（20岁）时就与名士、玄学代表人物王弼并知名。相反邓艾幼年丧父，出身卑微，年幼屯田，但受到了良好的教育。典故有一幕&lt;code&gt;邓艾喜欢军事。每见高山大川，都要在那里勘察地形，指划军营处所，遭别人讥笑也不介意。&lt;/code&gt;我想邓艾最终偷渡阴平跟他一直喜欢勘探地形有极大的关系。&lt;/p&gt;

&lt;p&gt;　　如果我是邓艾，在知道如果沿着路去追杀姜维面对的只有一种结果就是和钟会一块被姜维挡在剑阁之外，最终会因粮草短缺而退兵。而蜀军此时会将重兵屯于剑阁之后，即使攻破剑阁到时候面临的仍将是一场恶斗。我相信当时邓艾的军队一定会有密探在蜀国内部（双方都有间谍，这很正常），他肯定知道蜀国国君幼小，奸臣当道，国家也腐败。所以，如果能够跨过敌军绕道背后一定能够直取蜀都。那样擒贼先擒王，先到就先得了。而阴平这个地方地势凶险蜀国一定不会排重兵把守，所以要是我我一定想办法从阴平这修一条小道绕过蜀国重兵，直接来到绵竹。邓艾从小喜欢勘探地形这个特点天然的兼容这套方案啊。所以与其老老实实的失败还不如出其不意呢，万一失败了原路退回来不就行了。反正攻破剑阁也不是立马的事情。到时候随便找个托词给司马昭，得不到荣誉就得不到呗。但是修个阴平小道带来的收益绝对大于面对的风险。所以，我要是邓艾我就会铤而走险，修阴平小道。&lt;/p&gt;

&lt;p&gt;　　当时修阴平小道的难度应该是很大，摆在邓艾前面的就两个问题：山和水。我们来看一眼现在的G5京昆高速的一个关键地界。我们可以看到G5是在山坡上河流里修建的，风险度极高的。而西成铁路倒是一条直线，但是需要凿山挖隧道，隧道出来就是嘉陵江，过了嘉陵江面前有事一座大山，所以又得凿山。可想而知，这种难度对于邓艾来说会有多困难。根据记载邓艾选了几千精兵，一共花了20多天把长700公里的阴平小道建成的。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic2.zhimg.com/33638cf728e134c719eb7a20dad51ed0_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;现在的路况&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;蜀中诸道，皆不必多忧；惟阴平之地，切须仔细。此地虽险峻，久必有失&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　这是公元234年，诸葛亮临死前向众人交代后事，并且特地对姜维说的27个字。简单来说，诸葛亮在临死前特地叮嘱姜维一定要守好阴平，并且还强调这地方虽然地势险要，但难保以后没有魏国人来偷袭，所以必须小心防守才行。别人说这句话没有被姜维重视，但是我不觉得，当时诸葛亮的每一句话都是箴言，并且前有诸葛亮的锦囊妙计，任何人都不可能视诸葛亮之话而不顾，更别说当时的蜀国守国大将军邓艾了。另外，邓艾进军的时候姜维不就在阴平北的沓中么，这不也就说明姜维在守着阴平这块么。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;冬十月，艾自阴平道行无人之地七百馀里，凿山通道，造作桥阁。山高谷深，至为艰险，又粮运将匮，频於危殆。艾以毡自裹，推转而下。将士皆攀木缘崖，鱼贯而进。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　邓艾过了天险，一般来说都需要养精蓄锐，哪有说上来就干仗的。我理解这正是邓艾军事家视野之功，他笃定马邈因腐败会因天降神兵而弃城投降。最终却是也是这样的。有人说是上天眷顾邓艾，但是老天哪里会随随便便眷顾没有准备的人呢。这样邓艾兵不血刃的得了涪城，接下来诸葛瞻带领刘禅给的七万人迎战邓艾三万人马。那为啥邓艾能够迅速歼灭诸葛瞻之军呢？第一，邓艾的军队都是精兵良将，而诸葛瞻都是老弱病残或是临时拼凑。因为刘禅肯定会把精英派去剑阁防守。第二，邓爱军对刚多下涪城，此时士气正浓，然而诸葛瞻的军队士气肯定要落后很多。战场上士气这玩意真的很重要，士气高涨的军队，经常能够以少胜多。所以自古兵家很重视士兵的士气。第三，诸葛瞻战术问题，他没打过硬仗，长平之战时赵国还有廉颇和年轻的李牧，但此时的成都除了诸葛瞻，也没有什么其他人选可用了。&lt;/p&gt;

&lt;p&gt;　　那为什么姜维知道了后方失守却为什么不回来救呢？其实我理解如果回头救的话，可能钟会会突破剑阁，到时候前后受敌，兵家大忌。与其这样还不如继续防守，后方听天由命了。但是，最终等来的消息却是刘禅的一封投降书。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="三国" /><summary type="html">早入蜀都,先到先得。偷渡阴平，直取蜀汉！</summary></entry><entry><title type="html">有关字符集知识的总结</title><link href="https://naffan.cn/tech/2019/09/24/01.html" rel="alternate" type="text/html" title="有关字符集知识的总结" /><published>2019-09-24T00:00:00+08:00</published><updated>2019-09-24T00:00:00+08:00</updated><id>https://naffan.cn/tech/2019/09/24/01</id><content type="html" xml:base="https://naffan.cn/tech/2019/09/24/01.html">&lt;p&gt;　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。&lt;/p&gt;

&lt;p&gt;　　因为字符集类问题是很庞大的，所以让我们来规定几种字符集先。让我就unicode,gbk,ascii等字符集先做一定的温习。&lt;/p&gt;

&lt;p&gt;　　首先，我们来说说我们比较常用的编码之间的关系，好来展开这篇文章的复习。当计算机问世的时候因为是美国人造的，所以美国人就用了些英文字母和标点符号和辅助型符号，这些字符加起来也不过128位，所以就诞生了&lt;code&gt;ASCII&lt;/code&gt;码。后来发展到了欧洲，欧洲那么多国家，每个国家的字母都不太一样，所以人们就扩充了字符集，从而出了拉丁语系的&lt;code&gt;ISO8859-1&lt;/code&gt;字符集。再后来中国人参与进来了，我们中国字常用就7000多个。以现有的字符集根本承载不下来那么多字体，那人们就创造出来了&lt;code&gt;GBK&lt;/code&gt;字符集，这种字符集和之前两种的区别就是GBK使用两个字节来存储的，其中收录了21003个字符。再后来又出了&lt;code&gt;GB18030&lt;/code&gt;，可以收录数量达到了70244个。这个编码采用了1，2，4字节的存储方式，具体存储方式先不说。这个时候人们发现随着用来存储的字节的增多，存储量也变的巨大了。所以，传输的过程中效率问题捉襟见肘。于是，人们就开始考虑更好的存储方法，既能够囊括更多的字符同时存储的容量又不会急剧的膨胀。那么就需要一种智慧的存储方案来解决，于是&lt;code&gt;unicode&lt;/code&gt;编码营运而生。unicode编码采用变长的存储结构，通过高位的特殊位数来规定采用的字节数，从而达到了目的。unicode中分为三类:&lt;code&gt;utf8&lt;/code&gt;,&lt;code&gt;utf16&lt;/code&gt;和&lt;code&gt;utf32&lt;/code&gt;。主要用的还是utf8，而且utf8已然成为现如今世界上最为普遍的编码。&lt;/p&gt;

&lt;h1 id=&quot;一ascii码&quot;&gt;一、ASCII码&lt;/h1&gt;

&lt;p&gt;　　我们知道，计算机内部存储的数据都是二进制值。每一个二进制位（bit）有&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;两种状态。因此，八个二进制可以组合出256种状态，由八位组成一个字节，即从&lt;code&gt;00000000&lt;/code&gt;到&lt;code&gt;11111111&lt;/code&gt;。下表是128种ascii码表。当时规定最&lt;code&gt;高位为0&lt;/code&gt;，剩下的七位来分别表示这128个字符。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/asciifull.gif&quot; alt=&quot;ascii表格&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;二非ascii码&quot;&gt;二、非ASCII码&lt;/h1&gt;

&lt;p&gt;　　可是，当高1位为1的时候，还没有利用上。所以，有的国家就开辟了剩下的128个字符，但是随之而来的问题也接踵而来。问题是每个国家都可以扩充这后128位，最终导致前一128个都是相同的，但是后128个就不同国家都不一样了。如果再这么继续下去整个世界对于字符上就不再统一了，这简直就是个噩梦。于是，美国人开发出了unicode编码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.asciitable.com/index/extend.gif&quot; alt=&quot;扩展的&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;三unicode码&quot;&gt;三、Unicode码&lt;/h1&gt;

&lt;p&gt;　　Unicode是一本很厚的字典，记录着世界上所有字符对应的一个数字。我们可以通过这两个网站查看到每个字符相对应的存储数值，&lt;a href=&quot;https://home.unicode.org/&quot;&gt;unicode.org&lt;/a&gt;和&lt;a href=&quot;http://www.chi2ko.com/tool/CJK.htm&quot;&gt;unicode对照表&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;四utf-8&quot;&gt;四、UTF-8&lt;/h1&gt;

&lt;p&gt;　　unicode主要遇到了两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何让计算机区分出来&lt;/li&gt;
  &lt;li&gt;如何使存储空间更小&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　UTF-8是目前互联网上使用最广泛的一种unicode编码方式了，它主要的特点就是变长。它可以使用1-4个字符表示一个字符（零几年还有6个字符表示的方法，但是后来取消掉了）。规则如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。&lt;/li&gt;
  &lt;li&gt;对于需要使用 N 个字节来表示的字符（N &amp;gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Unicode 十六进制码点范围&lt;/th&gt;
      &lt;th&gt;UTF-8 二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0000 - 0000 007F&lt;/td&gt;
      &lt;td&gt;0xxxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0080 - 0000 07FF&lt;/td&gt;
      &lt;td&gt;110xxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0000 0800 - 0000 FFFF&lt;/td&gt;
      &lt;td&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0001 0000 - 0010 FFFF&lt;/td&gt;
      &lt;td&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　下面，我们用&lt;code&gt;帆&lt;/code&gt;字为例进行讲解&lt;/p&gt;

&lt;p&gt;　　帆的unicode十六进制是&lt;code&gt;5E06&lt;/code&gt;，补全后位&lt;code&gt;0000 5E06&lt;/code&gt;，二进制是&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;。跟具上表可以得知是在第三列范围内的。所以帆的utf8编码需要三个字节，即格式为&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;。从最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0，就得到了&lt;code&gt;11100101 10111000 10000110&lt;/code&gt;，转换成十六进制后得到utf8十六进制&lt;code&gt;E5 B8 86&lt;/code&gt;。我们可以通过&lt;a href=&quot;http://www.mytju.com/classcode/tools/encode_utf8.asp&quot;&gt;utf8和unicode转化工具&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;　　另外，说一下我们的通常表示法。utf8的16进制数表示开头加&lt;code&gt;0x&lt;/code&gt;，unicode开头加&lt;code&gt;U+&lt;/code&gt;。所以，帆字的utf8的16进制应该是&lt;code&gt;0xE5 0xB8 0x86&lt;/code&gt;，而unicode的16进制表示应该是&lt;code&gt;U+5E06&lt;/code&gt;。这个注意一下就好了，别人家写出来咱分辨不出来。&lt;/p&gt;

&lt;h1 id=&quot;五十六进制转换十进制方法&quot;&gt;五、十六进制转换十进制方法&lt;/h1&gt;

&lt;p&gt;　　这节其实是我在写这篇文章的时候遇到的问题。在这里我也就不单独拿出来写了，直接在这里温故而知新吧。我们在表示十六进制的时候，采用的表示法是&lt;code&gt;0x&lt;/code&gt;。比如我们表示&lt;code&gt;0xA4&lt;/code&gt;，其对应的十进制数怎么算呢？首先，我们要知道16进制的权为16，这个数转化为是十进制的方法和二进制转换成十进制一个道理。 是10(A) * 16的一次方+4 * 16的0次方，最终等于164.那我们算下&lt;code&gt;0xFF&lt;/code&gt;，是不是就等于255呢?答案是没错。&lt;/p&gt;

&lt;h1 id=&quot;六大端法和小端法&quot;&gt;六、大端法和小端法&lt;/h1&gt;

&lt;p&gt;　　计算机在存储器重排列字节有两种方式：大端法和小端法，大端法就是将高位字节放到底地址处，比如0x1234, 计算机用两个字节存储，一个是高位字节0x12,一个是低位字节0x34，它的存储方式为下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/09/26/ZxRMdziesI6Th9v.png&quot; alt=&quot;大端法和小端法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　TF-32用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理），如果不分大小端的话，那么就会出现解读错误，比如我们一次要处理四个字节 12 34 56 78，这四个字节是表示0x12 34 56 78还是表示0x78 56 34 12 ，不同的解释最终表示的值不一样。&lt;/p&gt;

&lt;h1 id=&quot;七utf-16&quot;&gt;七、UTF-16&lt;/h1&gt;

&lt;p&gt;　　utf-16也是边长字节表示，我们可以简单看看其表示的方法，不用太细的去看，等到真碰上了再思考也不迟。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对于编号在U+0000到U+FFFF的字符（常用字符集），直接用两个字节表示。&lt;/li&gt;
  &lt;li&gt;编号在 U+10000到U+10FFFF之间的字符，需要用四个字节表示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　同样，UTF-16 也有字节的顺序问题（大小端），所以就有UTF-16BE表示大端，UTF-16LE表示小端。&lt;/p&gt;

&lt;h1 id=&quot;八utf-32&quot;&gt;八、UTF-32&lt;/h1&gt;

&lt;p&gt;　　utf-32是字符对应标号的证书二进制形式，四个字节，直接转化就可以了。比如&lt;code&gt;帆&lt;/code&gt;的unicode为&lt;code&gt;U+5E06&lt;/code&gt;，直接转化成二进制后得到：&lt;code&gt;0101 1110 0000 0110&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以根据他们高低字节的存储位置来判断他们所代表的含义，所以在编码方式中有 UTF-32BE 和 UTF-32LE ，分别对应大端和小端，来正确地解释多个字节（这里是四个字节）的含义。&lt;/p&gt;

&lt;h1 id=&quot;九随便用go玩玩&quot;&gt;九、随便用GO玩玩&lt;/h1&gt;

&lt;p&gt;　　本来想用GO实现下编码互转的，但是后来发现GO原声只支持UTF-8编码，如果想用GB2312等编码还得去get包，我尝试了下但是timeout了。哎，临近国庆，很多东西都用不了啦。以后有需要再弄吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;unicode/utf8&quot;
)

func main(){
	b := []byte(&quot;Hello, 帆&quot;)
	for len(b) &amp;gt;0{
		r,size := utf8.DecodeLastRune(b)
		fmt.Printf(&quot;%c %v\n&quot;,r,size)
		b = b[:len(b)-size]
	}
	c := []byte(&quot;帆&quot;)
	fmt.Println(c)
}

打印结果：
帆 3
  1
, 1
o 1
l 1
l 1
e 1
H 1

[229 184 134]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以看到，utf8的中文在GO中是占3个字符的。而且帆的utf8的16进制数&lt;code&gt;E5 B8 86&lt;/code&gt;转换成十进制就是&lt;code&gt;[229 184 134]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6bdc0d52620a&quot;&gt;彻底弄懂 Unicode 编码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode 和 UTF-8&lt;/a&gt;&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="charset" /><summary type="html">　　工作中的一天下午，大概是16点左右。我旁边的一位爷生气的看着我，让我莫名的有种压力。我心头一紧赶紧追问怎么回事？这位爷气冲冲的告诉我他在解决一个问题，在解决问题的过程中让需求方硬生生的给秀逗了。爷告诉我这都高级工程师了竟然会不知道中文编码的占位问题，关键是这位还竟然在群里众目睽睽地说爷的不是。所以，这位爷找不到撒气的对象了，我心想得我也别招惹这位爷的注意力赶紧结束话题干自己的事情。结果没想到，这位爷还兴冲冲的要问我几个问题。我也不知道哪来的勇气满口答应，让他放马过来。结果我也彻彻底底的秀了一次智商下限。问我的问题让我这位职场老鸟受到了奇耻大辱。所以，我当即下定了决心得恶补一下关于字符集的知识。所以，我才过来写这篇总结。</summary></entry><entry><title type="html">Mysql中的too many connections问题背后</title><link href="https://naffan.cn/tech/2019/09/23/01.html" rel="alternate" type="text/html" title="Mysql中的too many connections问题背后" /><published>2019-09-23T00:00:00+08:00</published><updated>2019-09-23T00:00:00+08:00</updated><id>https://naffan.cn/tech/2019/09/23/01</id><content type="html" xml:base="https://naffan.cn/tech/2019/09/23/01.html">&lt;p&gt;　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。&lt;/p&gt;

&lt;p&gt;　　在中秋节前的那个周二，是我们公司上线的窗口期。在晚上6点左右的时候，同事告诉我50那台机子挂了，测试数据库也在这台机子上，所以也挂掉了。我们上线前QA是需要在测试线回归一下问题后才能上线的，但是由于测试数据库挂了，导致QA的测试不能够进行，时间太短又来不及去迁移整个数据库，看来只能求助OP同学了。后来，OP同学告诉我们50这台服务器是我们的自运维机器，OP们也不知道如何操作（他们其实是不愿意管）。好说歹说OP才腾出功夫将服务器重启了（后来得知，其实并没有重启，而是50这台服务器是虚机，因为某些原道导致机器卡住了，于是虚机就被暂存起来了，然而OP做的就是吧暂存的虚机重新打开就行了），这样看似一切正常的操作，突然mysql就出现了too many connections的报错，这回我是根本连不上mysql了。经过询问DBA，这种情况是数据库太多的僵尸链接导致的，僵尸链接没有放开连接，导致后边的连接根本请求不到资源。这下问题就来了，我没有root权限（其实知道这台机子因为年代久远的原因没有人知道他的root权限了），那怎么办才能够清除这些僵尸链接呢？好了，前言已经铺垫的很多了，我也确实需要回忆一下我的解决方案和问题背后涉及的原理了。&lt;/p&gt;

&lt;h3 id=&quot;问题解释&quot;&gt;问题解释&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if you get a Too many connections error when you try to connect to the mysqld server, this means that all available connections are in use by other clients.

发生too many connections的错误是因为所有可用的连接都被其他客户端保持着呢。

The number of connections permitted is controlled by the max_connections system variable. The default value is 151 to improve performance when MySQL is used with the Apache Web server. (Previously, the default was 100.) If you need to support more connections, you should set a larger value for this variable.

max_connections定义了被允许连接的数量。默认值是151，151是一个性能较高的值，尤其在web服务上。如果你需要更多的连接数，需要设置更大的数字。

mysqld actually permits max_connections+1 clients to connect. The extra connection is reserved for use by accounts that have the CONNECTION_ADMIN or SUPER privilege. By granting the privilege to administrators and not to normal users (who should not need it), an administrator who also has the PROCESS privilege can connect to the server and use SHOW PROCESSLIST to diagnose problems even if the maximum number of unprivileged clients are connected. See Section 13.7.6.29, “SHOW PROCESSLIST Syntax”. 
 
 mysqld进程使max_connections+1为客户端最大数量，这1个特别的连接是提供给最高用户权限的人用的。最高权限的人可以单独拥有这个链接，以此在发生问题时可以登录到mysql中查看问题所在，通过show processlist命令可以分析问题。也就是说151个连接全部被打满时，仍然有个第152链接等待这个最高权限的人进入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面的引用出自mysql用户手册的原语。这只是告诉了我们在这种错误的情况下我们是可以做出调整的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like '%max_con%' \G;
*************************** 1. row ***************************
Variable_name: max_connect_errors
        Value: 100
*************************** 2. row ***************************
Variable_name: max_connections
        Value: 151
*************************** 3. row ***************************
Variable_name: mysqlx_max_connections
        Value: 100
*************************** 4. row ***************************
Variable_name: performance_schema_max_cond_classes
        Value: 100
*************************** 5. row ***************************
Variable_name: performance_schema_max_cond_instances
        Value: -1
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;　　当我们拥有mysql的root权限的时候我们可以直接运行命令&lt;code&gt;set global max_connections = xxx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;　　当我们没有mysql的root权限时我们可以通过重启数据库来解决。还有一种是直接在命令端更改（参见：&lt;a href=&quot;https://www.percona.com/blog/2010/03/23/too-many-connections-no-problem/&quot;&gt;外国连接&lt;/a&gt;），外国人给了一个语句&lt;code&gt;gdb -p  $(cat mysqld.pid) -ex &quot;set max_connections=xxx&quot; -batch&lt;/code&gt;来操作，这个骚气的操作我暂时没看太懂，gdb怎么就能够操作这个呢？&lt;/p&gt;

&lt;h3 id=&quot;自己测试&quot;&gt;自己测试&lt;/h3&gt;
&lt;p&gt;　　知道了问题产生的原理了，那么我就自己模拟了一下，看看我能不能复现出这类问题&lt;/p&gt;

&lt;p&gt;　　首先，就是需要创建出是2个账号，然后再把max_connections设置为1.这样，当A用户连接上后，B去连接就连接不上了，然而我的root却能够登录。如果能够达到这样的效果，就说明了我复现成功了。&lt;/p&gt;

&lt;p&gt;　　值得注意的是mysql自升到了8.0以后，创建用户后需要紧跟着为用户分配权限。如果不这么做，你是之后再分配权限的话，就会得到&lt;code&gt;You are not allowed to create a user with GRANT&lt;/code&gt;的错误提示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create user `A`@localhost identified by 'testA';
mysql&amp;gt; grant select on laravel562.* to `test3`@`localhost`; //创建用户后直接分配读权限

Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我一共创建了两个用户分别是testA和testB。当我登录testA的时候，我通过root登录后运行```show processlist``后发现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*************************** 1. row ***************************
                 host: locahost
                 user: testA
authentication_string: *94BDCEBE19083CE2A1F959FD02F964C7AF4CFC29
               plugin: mysql_native_password
*************************** 2. row ***************************
                 host: localhost
                 user: mysql.infoschema
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 3. row ***************************
                 host: localhost
                 user: mysql.session
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 4. row ***************************
                 host: localhost
                 user: mysql.sys
authentication_string: $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED
               plugin: caching_sha2_password
*************************** 5. row ***************************
                 host: localhost
                 user: root
authentication_string: *332A08EE56001FE5139E2FB111080AA441242991
               plugin: mysql_native_password

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以发现结果中可以看到testA和root两个用户的连接情况。当我这个时候让testB连接的话，testB就会报too many connections的错误了。 我再让testA关闭掉，再连testB就可以了。&lt;/p&gt;

&lt;p&gt;　　之后，我删除了testA和testB，应用&lt;code&gt;drop user `test`@`localhost`;&lt;/code&gt;。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="mysql" /><summary type="html">　　今天，在工作中遇到了mysql报too many connections的问题。于是，在百度上快速的搜到了解决方法，只要在数据库上操作flush hosts操作就行了。我按照这个提示操作了一遍确实可以了。于是，一旦出现问题，我优先会去做此操作，以至于我只要打开数据库就会先来一遍这个操作，反正做了会降低出问题的概率。正当我这样做的不亦乐乎之时，大问题出现了。</summary></entry></feed>