<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-11-23T23:45:44+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">拿饭网</title><subtitle>拿饭网是一个私人博客系统，采用jekyll博客系统部署在GitHub-Pages服务上。拿饭网内的文章均出自作者，作者以技术为导向同时兼顾自己的生活与对经济的观点。</subtitle><author><name>张一帆</name></author><entry><title type="html">聊聊我使用ffmpeg时总结的最佳实践</title><link href="http://localhost:4000/tech/2021/11/23/01.html" rel="alternate" type="text/html" title="聊聊我使用ffmpeg时总结的最佳实践" /><published>2021-11-23T00:00:00+08:00</published><updated>2021-11-23T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/11/23/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/11/23/01.html">&lt;blockquote&gt;
  &lt;p&gt;FFmpeg is the leading multimedia framework, able to &lt;strong&gt;decode&lt;/strong&gt;, &lt;strong&gt;encode&lt;/strong&gt;, &lt;strong&gt;transcode&lt;/strong&gt;, &lt;strong&gt;mux&lt;/strong&gt;, &lt;strong&gt;demux&lt;/strong&gt;, &lt;strong&gt;stream&lt;/strong&gt;, &lt;strong&gt;filter&lt;/strong&gt; and &lt;strong&gt;play&lt;/strong&gt; pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation. It is also highly portable: FFmpeg compiles, runs, and passes our testing infrastructure &lt;a href=&quot;http://fate.ffmpeg.org/&quot;&gt;FATE&lt;/a&gt; across Linux, Mac OS X, Microsoft Windows, the BSDs, Solaris, etc. under a wide variety of build environments, machine architectures, and configurations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;部门的项目涉及到视频处理的功能，公司里负责存储服务的同学并没有这方面的能力支持（虽然他们也正在建设此方面的能力，因为公司内部需要视频处理的业务越来越多了。），所以我们只能硬着头皮开搞ffmpeg。曾经在看游戏的时候短暂的接触过半年多ffmpeg，但那个时候解决问题的能力不足，靠别人帮助的情况比较多。这么多年过去了，自己在开发领域的驾轻就熟，让我有了底气接了这摊子事儿。那么接下来我就总结下这几个月对ffmpeg的学习和使用吧。&lt;/p&gt;

&lt;h1 id=&quot;一框架选择---jave&quot;&gt;一、框架选择 - jave&lt;/h1&gt;

&lt;p&gt;项目是java的项目，借助github和google，了解到目前处理ffmpeg的框架最好用的是一个叫做&lt;a href=&quot;https://github.com/a-schild/jave2&quot;&gt;jave&lt;/a&gt;的开源项目。jave其实就是一个对ffmpeg包装的java库。目前jave的版本已经发展到了3.2.0，只需要在项目中引用jave-all-deps即可，他包括了jave-core和不同平台的ffmpeg脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;ws.schild&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jave-all-deps&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们公司的maven库的阿里镜像源超时的原因（那个时候找不到人来解决这个问题。），导致我用不到3.2.0版本的jave，我能获取到最新的版本就是2.7.3。这就导致了我在使用2.7.3时发现了问题去github上提&lt;a href=&quot;https://github.com/a-schild/jave2/issues/160&quot;&gt;concat mp4 not working properly. version 2.7.3 &lt;/a&gt;，开发者明确表示他没有资源去解决老版本的问题。反正，经过各种方面的努力，我也找到了我们公司管理maven库的同学，在他的帮助下我可以获取到3.2.0版本的jave了。但是，jave框架在视频拼接的处理上做的实在够差，我提了很多类似拼接的issue，比如&lt;a href=&quot;https://github.com/a-schild/jave2/issues/166&quot;&gt;The ffmpeg version included in 2.7.3 is a vry old one, which might cause the issue. &lt;/a&gt;。开发者在我的追问下已经不再回答我了。还有一次给他提了一个多个视频拼接时监控代码会报NPE问题的issue，&lt;a href=&quot;https://github.com/a-schild/jave2/issues/178&quot;&gt;when lots of videos to concat . EncoderProgressListernr get a NPE Exception&lt;/a&gt;，感觉开发者实在忙不过来了，转而求助我对此框架的修复。&lt;/p&gt;

&lt;p&gt;最终，拼接视频的代码我自己写了。格式转换的用了jave的。总的来说，jave可以帮助门外汉快速上手，因为我们可以通过看他的代码一步一步了解他封装ffmpeg时使用的方法以及他在遇到不同操作情况时是采用的什么方案。但是，当你慢慢了解ffmpeg的时候，jave框架会因为他的封装不够扩展而让开发举步维艰。&lt;/p&gt;

&lt;p&gt;当对ffmpeg有了一些最基本的了解后，ffmpeg官方网站（https://ffmpeg.org）就成为了进阶时最信得过的锦囊宝典。&lt;/p&gt;

&lt;h1 id=&quot;二ffmpeg官网&quot;&gt;二、FFmpeg官网&lt;/h1&gt;

&lt;p&gt;FFmpeg官网的左边栏，我们可以下载到ffmpeg最新的命令行。通过Documentation我们可以实时查看目前现有的所有功能，因为这个页面每晚都会重新生成。里面最常用的就是“&lt;strong&gt;Command Line Tools Documentation&lt;/strong&gt;”和“&lt;strong&gt;Components Documentation&lt;/strong&gt;”还有“&lt;strong&gt;General Documentation&lt;/strong&gt;”。&lt;/p&gt;

&lt;p&gt;官网同时还提供了IRC和MAIL等联系方式，IRC的频道是#ffmpeg 和 #ffmpeg-devel。两个频道分别面向的是使用者和开发者。我曾经在使用ffmpeg发生各种问题时进到IRC的频道里去寻求帮助，虽然里面会有4百多位处在挂机状态，但不时还是会有一些人进行交流的。我总得看下来，感觉里面说的东西都是C方面的问题，别的问题感觉里面的人不太感兴趣。我就因为又一次遇到了问题在里面提问了，确实有人回应我了，人家要我给出命令行以及错误堆栈。在IRC中你不能直接贴出来代码，需要一些专门托管代码片段的网站专门来制作代码片段连接，这一点有点让我觉得麻烦，可是又没别的好办法。等过了一会我把连接贴出来后，就没人再回应了。总体来说，体验很差，浪费了自己很多宝贵时间。我建议后来的人还是不要在IRC上浪费时间了。&lt;/p&gt;

&lt;h1 id=&quot;三音视频流的概念&quot;&gt;三、音视频流的概念&lt;/h1&gt;

&lt;p&gt;让我们先看一个视频的详细信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffprobe 1_1637395707\&amp;amp;88966_1637395335_1637395635.mp4 -hide_banner
[aac @ 0x7f846a808600] Input buffer exhausted before END element found
Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;1_1637395707&amp;amp;88966_1637395335_1637395635.mp4&apos;:
  Metadata:
    major_brand     : mp42
    minor_version   : 0
    compatible_brands: isommp42
    creation_time   : 2021-11-20T08:07:16.000000Z
    com.android.version: 9
  Duration: 00:04:59.78, start: 0.000000, bitrate: 575 kb/s
  Stream #0:0(eng): Video: h264 (Constrained Baseline) (avc1 / 0x31637661), yuv420p, 1280x720, 478 kb/s, SAR 1:1 DAR 16:9, 6.15 fps, 90k tbr, 90k tbn, 180k tbc (default)
   Metadata:
     creation_time   : 2021-11-20T08:07:16.000000Z
     handler_name    : VideoHandle
     vendor_id       : [0][0][0][0]
  Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 16000 Hz, mono, fltp, 96 kb/s (default)
    Metadata:
      creation_time   : 2021-11-20T08:07:16.000000Z
      handler_name    : SoundHandle
      vendor_id       : [0][0][0][0]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频一共有三种流：音频流，视频流，字幕流。我建议还是去看看FFmpeg官网对这几种结构的解释，介绍的挺全的，比我写的强多了。&lt;/p&gt;

&lt;p&gt;一般来说一个视频会有一个视频流和多个音频流及多个字幕流。他们的顺序安排按照约定俗成的顺序是第一个是视频流，对应着Stream #0:0；第二个及多个是音频流，对应着Stream#0:1，字幕流按此规则依次展开（当然，在我做ffmpeg的时候，经历过audio和video反了的情况，这种反了情况如果不去做处理ffmpeg其实会智能帮助挑选的，但是在某些时候就会报错失败。所以建议还是按照这个顺序来）。所以，我们可以从上面的代码片段中看到1_1637395707\&amp;amp;88966_1637395335_1637395635.mp4这个mp4文件包含以下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;视频持续时间 00:04:59.78，开始时间是0.000000，码率是575kb/s&lt;/li&gt;
  &lt;li&gt;#0:0是视频流（Video），h264编码，profile等级为baseline,采样格式是yuv420p，分辨率1280*720，平均码率478kb/s，帧率 6.15fps，时间基线 90k。（我列举出来的这几个是挺重要的参数，其他参数我还没有太明白）&lt;/li&gt;
  &lt;li&gt;#0:1是音频流（Audio）,aac编码，采样率16000Hz，单声道，码率96kb/s&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;四concat&quot;&gt;四、concat&lt;/h1&gt;

&lt;p&gt;拼接的意思就是，将两段或者多端音视频片段拼接成一个完整的音视频。ffmpeg官网&lt;a href=&quot;https://ffmpeg.org/faq.html#How-can-I-concatenate-video-files_003f&quot;&gt;指出&lt;/a&gt;，根据不同的情况，有多种方案可以进行选择。&lt;/p&gt;

&lt;h2 id=&quot;1拼接的3种方案&quot;&gt;1、拼接的3种方案&lt;/h2&gt;

&lt;h3 id=&quot;1concat-filter&quot;&gt;（1）concat filter&lt;/h3&gt;

&lt;p&gt;过滤器法适用于同步视频和音频流的片段，每个视频段都必须具有相同数量的流（包括类型），而且最终输出的视频也会按照这个顺序进行合并。这种方法会对视频进行重新编码，速度慢，耗cpu和内存。&lt;/p&gt;

&lt;p&gt;因为有些流不一定会和别的流的时间一致，举例来说一段视频有1个视频流和2个音频流，其中有一个音频流长度很短。那么这个方法就会按照这个视频最长时间的那个流为基准，其他流就会填补上静音。手册里明确说明最后一个视频不能这样。&lt;/p&gt;

&lt;p&gt;如果想让合并如预期那样工作，一定要保证所有视频片段的时间戳都是从0开始的。否则会出现，画面和声音不同步的情况。&lt;/p&gt;

&lt;p&gt;合并的时候还会遇到不同视频片段中有不同类型，不同采样率，不同通道的音频流。FFmpeg会自动的选择一个值来进行处理。另外，还有一些值是不能被FFmpeg自动填充的。还是需要人为的指定。另外，如果每段视频片段拥有不同的帧率，我们在最终结果视频制作时一定要设定个值，否则制作出来的视频就会按照每段自己的帧率进行合并了，这样的结果就是视频卡顿。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffmpeg -i opening.mkv -i episode.mkv -i ending.mkv -filter_complex \
  &apos;[0:0] [0:1] [0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2]
   concat=n=3:v=1:a=2 [v] [a1] [a2]&apos; \
  -map &apos;[v]&apos; -map &apos;[a1]&apos; -map &apos;[a2]&apos; output.mkv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个bash脚本的具体意思，怎么使。我看到了一篇CSDN上的文章，直接在这里做个&lt;a href=&quot;https://blog.csdn.net/xiaoluer/article/details/81136478&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2demuxer&quot;&gt;（2）demuxer&lt;/h3&gt;

&lt;p&gt;当我们的视频文件不支持文件级别的拼接并且我们想要避免重新编译，就应该采用这种方案。&lt;/p&gt;

&lt;p&gt;这种方案，通过读取一个文件里面的视频，将他们一个一个进行拼接。这些视频片段的时间都会被重新调整，第一个视频的开始时间调整为0，后面的视频等待前一个文件拼接完毕再进行拼接。如果他们的流时间长短不一，就会在他们之间产生间隙。&lt;/p&gt;

&lt;p&gt;如果他们的duration不同，那就会产生伪影（这个伪影，是翻译软件的翻译，我出现过这个问题，形象讲就是还在说话但是画面不动了。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 文件名为file，内容为
file &apos;/mnt/share/file-1.mp4&apos;
file &apos;/mnt/share/file 2.mp4&apos;
file &apos;/mnt/share/file 3.mp4&apos;

# ffmpg -y -f concat -i file  output.mp4 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3protocol&quot;&gt;（3）protocol&lt;/h3&gt;

&lt;p&gt;物理上进行拼接的方案，这个方案支持文件级拼接，也是最快的方案。一定要保证拼接的视频文件格式都一样。我最终就是选择用这个方案来进行拼接的，因为这种方案更稳定，更高效。（当然，如果你每个文件都不一样的结构，那这个方案就不行。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bas&quot;&gt;# ffmpeg -y -i &quot;concat:a.mp4|b.mp4&quot; output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2拼接时我遇到的各种问题&quot;&gt;2、拼接时我遇到的各种问题&lt;/h2&gt;

&lt;h4 id=&quot;1-channel-element-10-is-not-allocated&quot;&gt;（1） channel element 1.0 is not allocated&lt;/h4&gt;

&lt;p&gt;在采用demuxer拼接方案时，遇到了这个错误。错误的根本原因是拼接的视频文件中的流顺序和第一个文件的流顺序不一致导致的。&lt;/p&gt;

&lt;p&gt;demuxer的方案，是以第一个文件作为基准的。如果第一个视频的流顺序 #0:0是video，#0:1是audio，那么后面的所有视频文件的流顺序也得是 #0:0是video，#0:1是audio。这种情况是很可能发生的，因为你的输入可能是别人给你的，别人在操作视频的时候因为个人的疏忽或者经验缺失，有可能在制作的过程中将这种顺序弄混。如果你真遇到了这种情况，通过下面的命令，就能将顺序调整成第一个流是video,第二个流是audio。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ffmpeg -i input.mp4 -y output.mp4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2non-monotonous-dts-in-output-stream-01-previous-3277744-current-3276712-changing-to-3277745-this-may-result-in-incorrect-timestamps-in-the-output-file&quot;&gt;（2）Non-monotonous DTS in output stream 0:1; previous: 3277744, current: 3276712; changing to 3277745. This may result in incorrect timestamps in the output file.&lt;/h4&gt;

&lt;p&gt;首先需要了解一下DTS和PTS是什么意思。简单说，PTS就是这一帧应该在什么时候显示，DTS就是这一帧应该在什么时候进行解码。所以，这个问题是有关于帧的时间的报错。我们可以通过以下两个文章了解到更多。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fanyun_01/article/details/89608876&quot;&gt;DTS和PTS的解释&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/linyilong3/p/9940230.html&quot;&gt;图解DTS和PTS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;所以，问题的关键就是让各文件的采样率一致了。就是因为各文件的采样率不一致导致的，拼接视频时解码的时间3277744之后应该是3277745，但突然变小了 3276712。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="ffmpeg" /><summary type="html">FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation. It is also highly portable: FFmpeg compiles, runs, and passes our testing infrastructure FATE across Linux, Mac OS X, Microsoft Windows, the BSDs, Solaris, etc. under a wide variety of build environments, machine architectures, and configurations.</summary></entry><entry><title type="html">借助DDD思想，实践出质量检测系统</title><link href="http://localhost:4000/tech/2021/09/12/01.html" rel="alternate" type="text/html" title="借助DDD思想，实践出质量检测系统" /><published>2021-09-12T00:00:00+08:00</published><updated>2021-09-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/09/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/09/12/01.html">&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;DDD 是 Domain-Driven Design 的缩写。&lt;/strong&gt;其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散沙，无法继续演进。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;　　大屏项目借助链家门店中的终端设备（比如电视，pad等），构建智慧门店各场景的解决方案，助力门店业务发展。同时，协同交易签约场景打造居住服务中心智慧标杆，提供全新体验并优化签约流程。&lt;/p&gt;

&lt;p&gt;　　我们希望借助大屏深挖签约过程中更有价值的需求点，比如在签约过程中会录音录像（经过客业双方授权）。我们借助录制的视频可以保存下来作为客业（客户业主）双方斡旋时的证据，也能联合内部AI能力借助ASR转化来检测签约经理在服务环节中的关键讲解进而提升签约经理的服务质量。于是，我们就对此需求进行了立项，立项通过后进入了开发环节。&lt;/p&gt;

&lt;h1 id=&quot;项目背景&quot;&gt;项目背景&lt;/h1&gt;

&lt;p&gt;　　首先，简单介绍下项目交互和情况。实际发生签约时，客业及经纪人落座签约室进行签约过程。签约过程包括但不限于接待、斡旋、风险视频播放、起草合同等环节。每个环节的切换都是由签约经理通过电视进行操控的，所以每个环节的打点时间是有的，就可以和录音录像连动起来了。环节如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08f786d38c0610acf30518e30620a0032801300138eb8802.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;架构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　接着简要描述一下项目需求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个签约场景需要进行的环节有很多，每个环节内需要做的质量检测条目也很多。&lt;/li&gt;
  &lt;li&gt;需要一个工作流系统，承接上游下发过来的质检时间点和质检规则。根据质检规则发送给AI侧进行ASR。&lt;/li&gt;
  &lt;li&gt;需要一个工作流系统，转化上游质检环节的数据，下发给实际处理视频的系统进行ffmpeg处理。&lt;/li&gt;
  &lt;li&gt;需要一个操作ffmpeg脚本的服务，负责制作音视频。&lt;/li&gt;
  &lt;li&gt;未来可能会有更多的扩展业务需要进行质量检测。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;架构思想&quot;&gt;架构思想&lt;/h1&gt;

&lt;p&gt;　　然后，说下项目的架构设计思想。成熟的架构设计应该遵循简单，可复用的原则去设计。我们应该将整个项目优先进行切分，划分出不同的领域去设计。在这里我们可以简单的理解领域为专注的一件事情。在我们的这个项目中就划分出了两个领域，一个是工作流，一个是ffmpeg音视频制作系统。工作流系统专注于将上游业务下发的任务通过转化和编排等步骤切分出不同的底层可理解的任务，如拼接，转码等，再发送给视频处理系统去处理。ffmpeg音视频制作系统关注ffmpeg领域，只关心音视频制作等逻辑。ffmepg系统为底层系统，只对接工作流系统。如果将来接入方越来越多的话，因为只有工作流是对接系统，所以底层的ffmpeg可以与业务解耦，能够提供更灵活的支持。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08bb85ce8c0610fdec0318a40820f3032801300138c4c102.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;项目的架构&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;领域设计实践&quot;&gt;领域设计实践&lt;/h1&gt;

&lt;p&gt;　　从以上的需求描述来看，设计的概念较多，也有一定的业务复杂性，而且此次需求是质检系统从0到1的过程，我们决定使用领域驱动设计的方法论来解决业务复杂性问题，以及未来系统的可扩展性、可维护性。我在其中负责的是底层ffmpeg的服务。&lt;/p&gt;

&lt;h2 id=&quot;构建统一领域语言&quot;&gt;构建统一领域语言&lt;/h2&gt;

&lt;p&gt;　　由于需求涉及到的很多概念，为保证左后程序运行结果符合业务预期，需要对这些概念进行在限定语义下的无歧义的描述，就是构建统一的领域语言。这个步骤需要项目组全体成员达成共识，项目的正确性依赖于此。基于本次需求，我们规定了以下这些概念的具体含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务：指制作视频时的各种动作类型的任务；&lt;/li&gt;
  &lt;li&gt;动作：指一个任务下需要进行的各种动作；&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;下载：指从S3上进行下载&lt;/li&gt;
      &lt;li&gt;上传：指上传至S3（批量同理）&lt;/li&gt;
      &lt;li&gt;拼接：音视频文件拼接动作&lt;/li&gt;
      &lt;li&gt;转码：音视频文件的转码动作&lt;/li&gt;
      &lt;li&gt;剪切：通过业务指定的打点时间，剪切出音视频片段&lt;/li&gt;
      &lt;li&gt;空源：指一个视频为黑屏，声音为无声的视频或者音频&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方案：由一个任务和一组动作组成的集合&lt;/li&gt;
  &lt;li&gt;匹配：一个任务匹配动作的方案集&lt;/li&gt;
  &lt;li&gt;ffmpeg命令：通过不同的参数运行ffmpeg可以实现对音视频的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;业务分析与建模&quot;&gt;业务分析与建模&lt;/h2&gt;

&lt;p&gt;　　以上的概念统一有助于接下来要进行的业务分析，在业务分析中主要的关注点在业务的相关概念、隐含概念以及这些概念之间的关系上，这些关系包括依赖、关联、聚合、组合等。&lt;/p&gt;

&lt;p&gt;　　对于业务分析，可以使用多种方式进行，比如用例分析法、UserStory、事件风暴等。这个具体看团队对于哪种方式比较熟悉。我们采用用例分析法，就是对于业务描述、梳理出各种情况下的用户用例。此次需求中有三个模块的用例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;任务模块；&lt;/li&gt;
  &lt;li&gt;动作匹配配置模块；&lt;/li&gt;
  &lt;li&gt;动作组装命令策略模块；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　这里先来进行动作配置模块的用例分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生成动作列表，校验任务状态；&lt;/li&gt;
  &lt;li&gt;生成动作策略方案，从配置列表按照任务进行过滤；&lt;/li&gt;
  &lt;li&gt;生成动作匹配集，每个任务根据传入的参数筛选匹配符合的动作；&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　具体更多的详细用例这里不再展示，业务用例的列举越全面详细，由它构建的模型就会越准确，在列举用例的过程中要依据产品的PRD（如果有），但不能照搬PRD，要对PRD的内容进行归纳总结抽象，发现其中隐含的模型概念，比如这里的动作匹配策略的概念在PRD中没有显示的表现，但是隐藏在业务执行的过程中。&lt;/p&gt;

&lt;p&gt;　　当用例列举完善后，需要在这些用例中总结抽象出业务模型以及模型之间的关系。对于分析用例，简单来说有以下三个基本方法论：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提取实体，识别名词定位出实体；&lt;/li&gt;
  &lt;li&gt;添加关联，识别动词添加实体和实体质检的关联；&lt;/li&gt;
  &lt;li&gt;添加属性，识别形容词添加实体属性；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对于上述过程，它不是一蹴而就的，而是一步一步的发现用例，画出相关的模型图，然后再次发现隐含的用例或模型，修改模型图，它是一个迭代而产生的模型图。在迭代的过程中，依然要对相关模型进行统一语言的构建。&lt;/p&gt;

&lt;h3 id=&quot;匹配配置模型分析&quot;&gt;匹配配置模型分析&lt;/h3&gt;

&lt;p&gt;　　此项目的难点就是对于音视频处理任务的类型较多，而且每种类型的任务的场景不同，ffmpeg需要采用的命令行参数也不同，涉及到的规则很是复杂。如下面的规则示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拼接 &amp;amp;&amp;amp; A场景 &amp;amp;&amp;amp; 兼容模式 &amp;amp;&amp;amp; 电视摄像头采集 &amp;amp;&amp;amp; ……&lt;/li&gt;
  &lt;li&gt;拼接 &amp;amp;&amp;amp; B场景 &amp;amp;&amp;amp; 高画质模式 &amp;amp;&amp;amp; 安防摄像头采集 &amp;amp;&amp;amp; ……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　类似这样的规则需求里面有很多种，未来会频繁的修改添加，所以如何对其进行建模使其可配置可扩展至关重要。对与这样的规则，我们把它抽象为规则、条件表达式、ffmpeg命令参数这样的统一概念，一个方案对应一个表达式，一个表达式由一个或者多个ffmpeg命令参数组成。模型图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08a3aad48c0610fb9c05188a0a20ee042801300138fac803.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;模型图1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这样的模型可以使ffmpeg命令和方案配置解耦，方便未来扩展更多的ffmpeg命令以及进行方案的配置，条件表达式可以使用方案引擎进行解析。&lt;/p&gt;

&lt;h3 id=&quot;组装ffmpeg命令策略模型分析&quot;&gt;组装ffmpeg命令策略模型分析&lt;/h3&gt;

&lt;p&gt;　　对于ffmpeg命令策略模型的设计不但依赖上面的匹配配置模型，还要考虑到不同命令参数对最终音视频的影响。目前项目涉及的任务类型只涉及到质检场景的视频拼接、剪切及转码。在未来规划中，还会对其他场景及任务类型的支持，所以这里需要对其进行可扩展的设计：抽象出场景的概念。&lt;/p&gt;

&lt;p&gt;　　基于以上的模型构建，主要分为三个模块：场景、方案、ffmpeg命令参数。想要完成ffmpeg命令策略模型的设计就需要对这三个模块的信息和算法进行编写，我们还需要在设计的同时让他们保持相互解耦，方便未来对算法进行迭代优化。基于此，整个业务模型图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08e9bad48c0610e6960918a80920f20828013001389cd803.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;模型图2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;领域建模&quot;&gt;领域建模&lt;/h2&gt;

&lt;p&gt;　　基于以上的业务分析与建模、接下来要进行相关领域模型的建模。领域模型构建的关注点主要在于实体、值对象、聚合、领域服务和库的定义。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;实体、值对象分析&lt;/p&gt;

    &lt;p&gt;首先要对业务模型中的每个概念进行领域建模、领域模型中最主要的就是实体和值对象，他们的区别有两点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;实体是有唯一ID的，而且在业务中是有生命周期的，就是它会有一些状态变化；&lt;/li&gt;
      &lt;li&gt;值对象也可以有唯一的ID，但是它是无状态的，是在程序运行过程中是不可变的；&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;根据以上的原则，可以对上述概念进行领域建模。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;对于任务这个概念，他是有唯一ID的，在任务处理过程中它是会改变状态的，所以它应该是实体。&lt;/li&gt;
      &lt;li&gt;对于动作这个概念，它是由唯一ID的，在处理过程中它不会改变状态，所以他应该是值对象。&lt;/li&gt;
      &lt;li&gt;对于场景这个概念，他是有唯一ID的，在任务处理过程中它是不会改变状态的，所以它应该是值对象。&lt;/li&gt;
      &lt;li&gt;对于匹配来说，有唯一ID，在处理过程中一旦创建就不会改变，构建为值对象。&lt;/li&gt;
      &lt;li&gt;对于方案来说，同上。&lt;/li&gt;
      &lt;li&gt;对于方案集来说，在处理过程中它需要维护方案的ffmpeg参数，是否为最优方案等相关状态，所以他是实体。&lt;/li&gt;
      &lt;li&gt;对于匹配策略来说，有唯一ID，在处理过程中不可变，构建为值对象。对于他所包含的参数规则，筛选规则，方案匹配规则都应该是值对象。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;聚合的划分&lt;/p&gt;

    &lt;p&gt;聚合这个概念是一个抽象的概念，它在代码中没有具体的类模型去承载，但是聚合的划分对于代码逻辑的内聚性至关重要。聚合可以理解为领域模型之间的一种代码约束，比如不同聚合之间的模型不可以直接调用，需要通过聚合根进行聚合间的交互。&lt;/p&gt;

    &lt;p&gt;对于上述模型来说，可以看出来有任务、场景、ffmpeg命令策略这三个聚合。其他的模型与这三个聚合一起构成这个ffmpeg模块聚合。对于ffmpeg命令策略这个聚合，它的内部有匹配规则这个聚合，规则由于有多种类型，所以它是一个抽象类；规则聚合包括表达式这个小聚合，表达式聚合又包含了ffmpeg命令聚合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工厂、库、领域服务分析&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;​	实体和值对象是领域模型中比较重要的两个模型，剩下的工厂、库、领域服务这些对象是为了维护以上两个模型的生命周期而产生的模型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;工厂：正如它的名字，主要维护模型的创建工作。有两种形式来创建工厂，一个是通过构造方法充当模型的工厂方法；如果模型构建比较复杂，就需要创建一个工厂类来承载创建模型的工作。对于上述模型，需要为任务、场景、ffmpeg命令这三个聚合创建工厂类，因为他们够在相对来说比较复杂。&lt;/li&gt;
  &lt;li&gt;库：库的概念主要是用来调用基础设施层来获取持久化数据以及进行数据持久化。这里服务者需要从第三方接口获取数据，需要构建一个库对象；测录需要从数据库获取，构建一个库对象；&lt;/li&gt;
  &lt;li&gt;领域服务：对于领域服务，它主要承载聚合之间的交互逻辑，如果发现有一个逻辑设计多个聚合，它没有一个主体，不适合放在其中的摸一个聚合中，这时需要构建一个领域服务来承载这部分逻辑。比如上面木星中的方案生成逻辑，它涉及任务、场景、ffmpeg这三个聚合，所以应为其创建一个领域服务来承载方案生成以及最优化方案的成圣逻辑。对于领域服务，不能随便滥用，不然会变成一个业务逻辑的打你团。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;领域模型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　基于以上的分析，我们可以构建出如下的领域模型图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/0895a3dd8c06108de80518d0062093062801300138e75c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;领域模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　以上模型基本和业务分析出的模型类似，我们为其确立了具体模型归属，划分了相关的聚合，添加了相应的辅助领域模型。在构建这个模型时，依然要随时丰富相关的用例case，不断完善领域模型。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="系统" /><summary type="html">DDD 是 Domain-Driven Design 的缩写。其主要的思想是，我们在设计软件时，先从业务出发，理解真实的业务含义，将业务中的一些概念吸收到软件建模中来，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散沙，无法继续演进。</summary></entry><entry><title type="html">我在贝壳的第一次活水</title><link href="http://localhost:4000/life/2021/06/30/01.html" rel="alternate" type="text/html" title="我在贝壳的第一次活水" /><published>2021-06-30T00:00:00+08:00</published><updated>2021-06-30T00:00:00+08:00</updated><id>http://localhost:4000/life/2021/06/30/01</id><content type="html" xml:base="http://localhost:4000/life/2021/06/30/01.html">&lt;blockquote&gt;
  &lt;p&gt;得志不得意，失意不失志&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着4月的晋升失败，给我带来的是又一次打击。本来2020年10月的第一次晋升失败以后，经过2个月在java的项目上的锤炼，我又建立起了很足的信心。因为，在2020年底我自己一人做出的项目平均每天的请求量在80万，qps50。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="链家,活水" /><summary type="html">得志不得意，失意不失志</summary></entry><entry><title type="html">拿饭网对java的classLoader分析</title><link href="http://localhost:4000/tech/2021/06/15/01.html" rel="alternate" type="text/html" title="拿饭网对java的classLoader分析" /><published>2021-06-15T00:00:00+08:00</published><updated>2021-06-15T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/06/15/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/06/15/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　虚拟机把描述类的数据从class文件加载到内存，并且进行校验、解析、初始化。最终形成可以直接使用的Class对象，这就是类加载机制。&lt;/p&gt;

&lt;p&gt;　　类加载并不是一次性把所有class文件都加载到JVM中的，而是按照需求来加载的。比如，JVM启动时，会通过不同的类的加载器加载不同的类。当用户在自己代码中，需要额外的类时，再通过加载机制加载到JVM中，并且存放一段时间，便于频繁使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;全盘委托，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示的使用另外一个类加载器加载。&lt;/li&gt;
  &lt;li&gt;父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。&lt;/li&gt;
  &lt;li&gt;缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，自由缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;类加载过程&quot;&gt;类加载过程&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　类从被加载到JVM内存开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，共7个阶段。其中验证、准备、解析3个部分统称为连接。这7个阶段的发生顺序如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08dca7e7850610aef604188e0c20fa042801300138b2e403.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　其中&lt;code&gt;类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。&lt;/code&gt;在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。&lt;/p&gt;

&lt;p&gt;　　下面详细介绍每个阶段所做的事情：&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;加载&quot;&gt;加载&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　加载时类加载过程的第一个阶段，在加载阶段，JVM需要完成以下三件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过一个类的全限定名来获取其定义的二进制字节流。&lt;/li&gt;
  &lt;li&gt;将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
  &lt;li&gt;在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　第一条中的二进制字节流并不只是单纯的从class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。&lt;/p&gt;

&lt;p&gt;　　相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。&lt;/p&gt;

&lt;p&gt;　　加载完成以后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在&lt;code&gt;方法区&lt;/code&gt;之中，而且在java堆中也会创建一个java.lang.Class类的对象，这样便可以通过对象访问方法区中的这些数据。&lt;/p&gt;

&lt;p&gt;　　类加载器分为以下三类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动类加载器：Bootstrap ClassLoader，它负责加载放在JDK/jre/lib下，或者被-Xbootclasspath参数指定的路径中的，并且被虚拟机是别的类库。启动类加载器是无法被java程序直接启动的。它是C++实现的，是虚拟机的一部分。&lt;/li&gt;
  &lt;li&gt;扩展类加载器：Extension ClassLoader，该加载器由sun.misc.launCher$ExtClassLoader实现，它负责加载JDK/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。&lt;/li&gt;
  &lt;li&gt;应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　应用程序都是由这三种加载器相互配合进行加载的，如果有必要程序员还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做做到：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在执行非置信代码之前，自动验证数字签名。&lt;/li&gt;
  &lt;li&gt;动态地创建符合用户特定需要的定制化构建类。&lt;/li&gt;
  &lt;li&gt;从特定的场所取得java class，例如数据库中或者网络中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/0888e8e7850610f18c0118c10220c5032801300138ae1c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;双亲委派模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这种层次关系称为类加载器的&lt;code&gt;双亲委派模型&lt;/code&gt;。他们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中代码。这不是一个强制性的约模型，而是java设计者们推荐给开发者的一种类的加载器实现方式。&lt;/p&gt;

&lt;p&gt;　　双亲委派的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它搜索范围中没有找到所需的类时，子加载器才会去尝试自己去完成加载。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;为什么要使用这种模式呢？&lt;/code&gt;因为java中的类随着它的类加载器一起具备了一种带有优先级的层级关系。这样的好处是，避免了循环引用，而可以一直溯源到最父类。例如，java.lang.Object，他存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载类进行加载，因此Object类在程序的各种类加载器环境中都是能够保证是同一个类。同时，也防止了内存中出现同样的字节码。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;举例说明&quot;&gt;举例说明&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Dog dog = new Dog();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由new关键字创建一个类的实例。这个动作会导致常量池的解析，Dog类被隐式装在。如果当前ClassLoader无法找到Dog,则抛出NoClassDefFoundError&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try{
    Class clazz = Class.forName(&quot;Dog&quot;);
    Object dog = clazz.newInstance();
}catch (Exception e){
    System.out.println(e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过反射加载类型并创建对象实例。如果无法找到Dog，则抛出ClassNotFoundException&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try{
    ClassLoader cl = new ClassLoader() {
        @Override
        public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
            return super.loadClass(name);
        }
    };
    Class clazz = cl.loadClass(&quot;Dog&quot;);
    Object dog = clazz.newInstance();
}catch (Exception e){
    System.out.println(e.getMessage());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过反射加载类型并创建对象实例。如果无法找到Dog，则抛出ClassNotFoundException&lt;/p&gt;

&lt;p&gt;&lt;code&gt;上面三种有什么区别呢？分别用于什么情况呢？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1和2使用的类加载器是相同的，都是当前类加载器（this.getClass.getClassLoader）。3是用户指定的类加载器。如果需要在当前类路径以外寻找类，则只能用第3种方式。第3种方式加载的类与当前类分属不同的命名空间。当前类加载器命名空间对其不可见。当然，如果被加载类的超类对于当前类命名空间可见的话，则可以进行强制转型。第1种抛出error，第2，3种抛出Exception。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jdk9的双亲委派模式&quot;&gt;JDK9的双亲委派模式&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDK9为了模块化的支持，对双亲委派模式租了一些改动：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;扩展类加载器被平台类加载器（Platform ClassLoader）取代，原来的rt.jar和tools.jar被拆分成数十个JMOD文件。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平台类加载器和应用程序类加载器都不再继承自java.netURLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;启动类加载器现在是在java虚拟机内部和java类库共同协作实现的类加载器（以前是C++实现）。为了与之前的代码保持兼容，所有在获取启动类加载器的场景中仍然会返回null来代替，而不会得到BootClassLoader的实例。&lt;/li&gt;
  &lt;li&gt;类加载的委派关系也发生了变动，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责哪个模块的加载器完成加载。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08d3bea0860610a791181880082080062801300138d28f01.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;jdk9双亲委派模型&quot; /&gt;&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">类加载机制</summary></entry><entry><title type="html">赛格广场晃动，原因竟然是共振</title><link href="http://localhost:4000/thinking/2021/05/22/01.html" rel="alternate" type="text/html" title="赛格广场晃动，原因竟然是共振" /><published>2021-05-22T00:00:00+08:00</published><updated>2021-05-22T00:00:00+08:00</updated><id>http://localhost:4000/thinking/2021/05/22/01</id><content type="html" xml:base="http://localhost:4000/thinking/2021/05/22/01.html">&lt;blockquote&gt;
  &lt;p&gt;赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2021%2F0519%2F79a605c9j00qtcuwt00a4c0010400r4m.jpg&amp;amp;thumbnail=650x2147483647&amp;amp;quality=80&amp;amp;type=jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月18日，深圳市福田区华强北街道赛格大厦出现摇晃，大厦已经封闭，大厦内人员已全部撤出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月19日，大楼在下午一点半到两点之间出现过晃动。目前大厦原则上只能让商家等内部工作人员出入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2021年5月20日12时30分左右在35楼、55楼、60楼等多个楼层感受到晃动。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2020年5月21日，深圳市赛格集团有限公司的通知显示自21日起暂停所有业主、商户、租户进出赛格大厦写字楼和电子市场，待相关检测工作完成后再有序开放，有关事宜另行通知。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　最近，赛格大厦晃动的事件在民间讨论的沸沸扬扬，一石激起千层浪，媒体的曝光更加让本来疑云密布的事件罩上了更多的阴谋论。其中一家媒体爆料说是20年前就有一篇&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1700150908927741800&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;《深圳赛格广场建设项目评析》&lt;/a&gt;的硕士论文中指出，大厦是边设计边施工。这位硕士学生是一名华中科技大学非建筑学科且并未参与过赛格广场建设的学生，她的名字叫金典琦。此文章一出各种小道每天就开始各种添油加醋，疯狂的不分青红皂白的就开始说赛格大厦是豆腐渣工程，是中国体系内的不负责任的典型。那么事情真的是这样么？我在网上翻到了当时这名学生的论文并且通读以后得出了结论：&lt;/p&gt;

&lt;p&gt;　　金典琦是学工商管理的在职硕士，全程参与了赛格大厦建设的管理工作。对赛格大厦建造过程中选取的技术和解决方案以及施工方的预算和组织架构有充足的了解和深入的分析。对于建设过程中遇到的问题和解决方案有自己独有的理解和路径分析，形成了自己理论体系内的底层逻辑，逻辑能够自洽，对当时的市场分析和市场判断有比较全面的认知和实践。论文中也给出了详细的问题列表和抓手，对待施工时施工单位采用的方案有给出追种方案的比较并得到了学界内权威人士的认可与支持。&lt;/p&gt;

&lt;p&gt;　　论文中两次提到赛格大厦晃动的经历，一次为大厦顶部的两根天线设计不合理并重新进行了调整；一次为95年因大厦耸入云间，由于云彩移动导致广场上的人们误以为大厦要倾倒的趣事。还有一次提到了共振问题导致晃动。一次边设计边建造的问题根源。&lt;/p&gt;

&lt;p&gt;　　综上所述，论文给出了客观且符合当事人认知的合理判断与真实建造情况。所以，对于这些媒体给出的偏颇结论我认定为是媒体的误导及看到这些文章后唯恐天下不乱的人们不经过自己调研后就轻易下结论的事实。&lt;/p&gt;

&lt;p&gt;　　接下来，让我们的目光集中在&lt;code&gt;共振&lt;/code&gt;这一物理名词上。首先让我们看看bilibili上科普博主用通俗的语言讲的共振的机制和影响吧。&lt;/p&gt;

&lt;div align=&quot;middle&quot;&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=714516015&amp;amp;bvid=BV1qX4y1V7cE&amp;amp;cid=308414800&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/2e7857ed9bfb4122aaf35d697dbbf8b3.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振例图&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;三百多年前，荷兰科学家惠更斯（Christian Huygens）在房间里的墙上并排放置不同速率的摆钟。当他第二天再回来时，发现这几个摆钟的钟锤都以同速率同步摆动。最终根据这一现象惠更斯写出了《摆钟轮》（Horologium Oscillatorium），摆钟现象被后来许多人相继重复实验，实际上这就是今天说的共振。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180826/dfce68126e974af08a03e71a2b578caa.gif&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振动图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　让我们来看看数学上是如何解释共振机理的吧，出自《数学指南》，科学出版社出版：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic2.zhimg.com/v2-afd3f984658ef92358a21e3245278824_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-e531f3ecae8171692340dd76189c3fe9_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic1.zhimg.com/v2-062748cdc1ecca03d291bdcb76c6b5aa_r.jpg?source=1940ef5c&quot; src=&quot;/images/default.jpg&quot; alt=&quot;共振机理3&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;　　通过上面的数学方程式，我们了解到。如果我们一直给弹簧施加一个周期性的力，当力的频率等于弹簧固有震频时，力的作用方向和振子运动方向一直保持一致。这就意味着，力对振子做的功永远为正，于是振子的能量越来越大，对物体内部结构的破坏就越来越大，最终会导致物体被摧毁。&lt;/p&gt;

&lt;p&gt;　　2021年特斯拉上架了ModelY，当发售两个月后车主就曝出了modelY低频共振的问题。据说，很多车主都遇到过这个问题，并且有些车主花钱去做了&lt;a href=&quot;https://club.autohome.com.cn/bbs/thread/870af073c080e909/94575641-1.html&quot;&gt;后备箱隔音&lt;/a&gt;，但仍于事无补。据业内人士分析，ModelY的低频噪音多来自尾部，或许是因为车辆行驶过程中的噪音通过底盘传至车身，由于后尾门存在空腔，且钢板较薄，很容易因为刚性不足而放大噪音，从而产生低频共振的现象。这个就是通过后备箱的声音传过来的声波和车主的耳膜一致造成了共振现象，当振幅越来越大时就会给车主的耳朵造成不可逆的创伤。&lt;/p&gt;

&lt;p&gt;　　在我弹吉他的时候，每次拿出来吉他都要进行调音测试，为了让每条弦能够弹出准确的声音。调音手段中有一个利用共振原理来进行调弦的方法。就是波动一条弦后，其他弦的空弦如果与这条弦的声调一致就会跟着颤抖起来。&lt;/p&gt;

&lt;p&gt;　　在航天航空中，宇航员升天时会与宇宙飞船产生共振。我们国家英雄杨利伟就曾说：“2003年10月15日上午9时整，火箭尾部发出巨大的轰鸣声，几百吨高能燃料开始燃烧，8台发动机同时喷出炽热的火焰，高温高速的气体，几秒钟就把发射台下的上千吨水化为蒸汽。火箭和飞船总重达到487吨，当推力让这个庞然大物升起时，大漠颤抖、天空轰鸣。火箭逐步地加速，我感到压力在渐渐增加。因为这种负荷我们训练时承受过，我的身体感受还挺好，觉得没啥问题。但就在火箭上升到三四十公里的高度时，火箭和飞船开始急剧抖动，产生了共振。这让我感到非常痛苦。人体对10赫兹以下的低频振动非常敏感，它会让人的内脏产生共振。而这时不单单是低频振动的问题，还是这个新的振动要叠加在大约6G的一个负荷上。这种叠加太可怕了，我们从来没有进行过这种训练。我担心的意外还是发生了。”&lt;/p&gt;

&lt;p&gt;　　在现实生活中，我们周边还会有许许多多的共振现象。要解决共振其实很简单，只要找到物体共振频率，在此频率上减小激励力就能够避免共振了。对于高楼大厦来说，一般都是用类似阻尼器的装置来减小共振。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="thinking" /><category term="共振" /><summary type="html">赛格广场，位于深圳市交通干道深南中路与华强北路交汇处，由深圳赛格集团投资兴建，是深圳市跨世纪的标志性建筑。总高355.8米，总建筑层79层，地上75层，地下4层，总建筑面积达17万平方米。</summary></entry><entry><title type="html">敬给我最尊重的老板，贝壳董事长-左晖</title><link href="http://localhost:4000/life/2021/05/20/01.html" rel="alternate" type="text/html" title="敬给我最尊重的老板，贝壳董事长-左晖" /><published>2021-05-20T00:00:00+08:00</published><updated>2021-05-20T00:00:00+08:00</updated><id>http://localhost:4000/life/2021/05/20/01</id><content type="html" xml:base="http://localhost:4000/life/2021/05/20/01.html">&lt;blockquote&gt;
  &lt;p&gt;我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://pic3.zhimg.com/80/v2-929a9e08b764aafea5ab50701fc66f82_720w.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;左晖&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面是我们公司的老板说的话，他的精神永远激励着我们，我们将矢志不渝的坚持长期主义，团结一心为新居住产业发展做难而正确的事！&lt;/p&gt;

&lt;p&gt;　　我很早就把我的行业固定在了中国的房地产行业之中，我又是从事互联网的技术人员。所以很自然的就干上了产业互联网之事。而我选择链家就是因为我在见证了链家这20年来的发展，坚定了链家作为中国（将来）最好的企业之一的信念以及我对中国房地产相关产业的看好。&lt;/p&gt;

&lt;p&gt;　　我是18年8月入职贝壳的，其实在四月份我就来链家面过试。那个时候福道大厦还不是贝壳的logo呢。我对链家是有一种执着的信念的，我愿意追随这样一位好领导，干有意义且难但正确的事情。入职贝壳以来，我专心落地到了为左晖先生提的”做有尊严的服务者“这句话的意义上奉献，长达3年的贝壳工作，我一直服务于链家的经纪人产品。&lt;/p&gt;

&lt;p&gt;　　经过这几年的工作，从入职php，到改为写go，再到现在的java。感觉这几年对语言的转型让我对语言已经有深刻的理解了。目前我正在做自己负责的业务，并且一直致力于学习。在2020年10月，和21年4月，我得到了部门给我的晋升机会。虽然通过自己的努力，最终没有晋级成功。但是，两次折磨的过程让我重新认识到了我目前缺乏的东西，第一次是技术，但是在第二次评委已经不说我技术问题了，而是产品高度。在接下来的工作和生活中，我将以提高我的这个能力为前提努力的认真工作。左晖先生的精神，会激励着我，一直向前。&lt;/p&gt;

&lt;p&gt;　　今天下午3点，在得知左晖先生离开后，我心情难以平复，本来未来可期，本来还有一番事业等待着他带领我们一起航行，可是就这样戛然而止，希望左晖先生一路走好，后面还有大S帮您完成您的愿望，我们会一起努力!&lt;/p&gt;</content><author><name>张一帆</name></author><category term="life" /><category term="链家,癌症" /><summary type="html">我们这个时代企业经营者的宿命，就是要去干烟花背后的真正提升基础服务品质的苦活、累活。</summary></entry><entry><title type="html">redis连接池源码分析</title><link href="http://localhost:4000/tech/2021/05/15/01.html" rel="alternate" type="text/html" title="redis连接池源码分析" /><published>2021-05-15T00:00:00+08:00</published><updated>2021-05-15T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/15/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/15/01.html">&lt;p&gt;　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。&lt;/p&gt;

&lt;p&gt;　　你在开发时，可以通过jedis连接redis。jedis支持直连模式和连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直连模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; public static void main(String[] arg){
        //1个实例
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379,100);
        jedis.incr(&quot;threadSafe&quot;);
        jedis.close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/089f91fe840610d38104189b092092042801300138f312.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;直连&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　你不应该将一个redis实例共享给不同线程，时用时消的用法会造成产生很多的socket和tcp连接，即浪费时间又耗费资源，也提高了服务不可用的风险。如果你只是在本机环境或者使用者相对少的环境中使用，这种模式比较适宜。但是，如果你需要大量使用redis时，应该采用连接池模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接池模式：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] arg){
        JedisPool pool = new JedisPool(new JedisPoolConfig(),&quot;localhost&quot;);
        try (Jedis jedis = pool.getResource()) {
            jedis.set(&quot;foo&quot;, &quot;bar&quot;);
            String foobar = jedis.get(&quot;foo&quot;);
            jedis.zadd(&quot;sose&quot;, 0, &quot;car&quot;); jedis.zadd(&quot;sose&quot;, 0, &quot;bike&quot;); 
            Set&amp;lt;String&amp;gt; sose = jedis.zrange(&quot;sose&quot;, 0, -1);
        }
        pool.close();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08af91fe84061087a50a189b09208b052801300138b9f703.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;连接池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　为了避免由单一redis实例引发的未知的服务不可用的风险，我们应该采用这种方案。这种方案背后的原理就是连接池（common-pool2）。当服务到达时服务会从连接池中borrow一个jedis连接，当用完或者发生错误时，连接会归还到连接池中。如果没有borrow到连接，那么服务就会报错且关闭。&lt;/p&gt;

&lt;p&gt;　　我的上一篇&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/12/01.html&quot;&gt;池化技术&lt;/a&gt;已经提到过连接池的概念，所以这篇文章是我想记录并分享我所学习到的jedis连接池的知识。通过上一段代码我们看到当jedisPool实例化以后，我们从pool中通过getResource来获取一个jedis实例。那么我们的代码研究就从这里开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/jedisPool.class
    public Jedis getResource() {
        //调用父集getResource
        Jedis jedis = (Jedis)super.getResource();
        //将当前实例暴露出dataSource，供后续redis操作使用
        jedis.setDataSource(this);
        return jedis;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //jedis-3.6.0.jar/redis/clients/jedis/client/util/Pool.class
    //genericObjectPool是ObjectPool的实现，ObjectPool是common.pool2中关于池化对象的接口。其中定义了几个标准的对象方法，这些方法就是管理池的核心方法。
    protected GenericObjectPool&amp;lt;T&amp;gt; internalPool;
    ……
    public T getResource() {
        try {
            //通过调用common.pool2中的borrowObject，完成对jedis实例的借取。
            return this.internalPool.borrowObject();
            //如果出现了异常了，按照异常的分类进行处理。
        } catch (NoSuchElementException var2) {
            if (null == var2.getCause()) {
                throw new JedisExhaustedPoolException(&quot;Could not get a resource since the pool is exhausted&quot;, var2);
            } else {
                throw new JedisException(&quot;Could not get a resource from the pool&quot;, var2);
            }
        } catch (Exception var3) {
            throw new JedisConnectionException(&quot;Could not get a resource from the pool&quot;, var3);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在common-pool2中，对象池的核心接口叫做ObjectPool，他定义了对象池的实现的行为。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;addObject方法：往池中添加一个对象。池子里的所有对象都是通过这个方法进来的。&lt;/li&gt;
  &lt;li&gt;borrowObject方法：从池中借走到一个对象。借走不等于删除。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;returnObject方法：把对象归还给对象池。归还不等于添加。对象一直都属于池子，只是状态的变化。&lt;/li&gt;
  &lt;li&gt;invalidateObject：销毁一个对象。这个方法才会将对象从池子中删除，当然这其中最重要的就是释放对象本身持有的各种资源。&lt;/li&gt;
  &lt;li&gt;getNumIdle：返回对象池中有多少对象是空闲的，也就是能够被借走的对象的数量。&lt;/li&gt;
  &lt;li&gt;getNumActive：返回对象池中有对象对象是活跃的，也就是已经被借走的，在使用中的对象的数量。&lt;/li&gt;
  &lt;li&gt;clear：清理对象池。注意是清理不是清空，改方法要求的是，清理所有空闲对象，释放相关资源。&lt;/li&gt;
  &lt;li&gt;close：关闭对象池。这个方法可以达到清空的效果，清理所有对象以及相关资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　在common-pool2中，objectPool的核心实现类就是GenericObjectPool。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectedPool
    @Override
    public T borrowObject() throws Exception {
        //getMaxWaitMillis()是BaseGenericObjectPool中设定的volatile类型的值，代表最长等待时间（毫秒），配置文件中的&quot;maxWait&quot;
        return borrowObject(getMaxWaitMillis());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接下来我们来分析下borrowObject方法，刚才说过borrowObject是实现了ObjectPool。那么先看一下这个接口中对borrowObject的描述。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    /**
     * Obtains an instance from this pool.
     * &amp;lt;p&amp;gt;
     * Instances returned from this method will have been either newly created
     * with {@link PooledObjectFactory#makeObject} or will be a previously
     * idle object and have been activated with
     * {@link PooledObjectFactory#activateObject} and then validated with
     * {@link PooledObjectFactory#validateObject}.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * By contract, clients &amp;lt;strong&amp;gt;must&amp;lt;/strong&amp;gt; return the borrowed instance
     * using {@link #returnObject}, {@link #invalidateObject}, or a related
     * method as defined in an implementation or sub-interface.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * The behavior of this method when the pool has been exhausted
     * is not strictly specified (although it may be specified by
     * implementations).
     * &amp;lt;/p&amp;gt;
     *
     * @return an instance from this pool.
     *
     * @throws IllegalStateException
     *              after {@link #close close} has been called on this pool.
     * @throws Exception
     *              when {@link PooledObjectFactory#makeObject} throws an
     *              exception.
     * @throws NoSuchElementException
     *              when the pool is exhausted and cannot or will not return
     *              another instance.
     */
     /*
     这个method返回实例，这个实例将是一个被makeObject()创建的对象，或者是一个之前就是idle并且经过activateObject()激活过的并且经过validatedObject()验证过的对象。
     根据约定，客户端必须调用过returenObject(),invalidateObject()或者一个在子类中实现了归还逻辑的方法后归还。
     这个方法在池子耗尽时的表现没有指明具体如何处理（尽管他有可能被他的实现制定过。）
     */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　接着我们再来看看这个方法的具体实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //commons-pool2.jar/org/apache/commons/pool2/impl/GenericObjectPool.class
    /**
     * Equivalent to &amp;lt;code&amp;gt;{@link #borrowObject(long)
     * borrowObject}({@link #getMaxWaitMillis()})&amp;lt;/code&amp;gt;.
     * &amp;lt;p&amp;gt;
     * {@inheritDoc}
     * &amp;lt;/p&amp;gt;
     */
     //通过获取配置中MaxWait配置，当做传输调用重载的方法。
    @Override
    public T borrowObject() throws Exception {
        return borrowObject(getMaxWaitMillis());
    }
    
    /**
     * Borrows an object from the pool using the specific waiting time which only
     * applies if {@link #getBlockWhenExhausted()} is true.
     * &amp;lt;p&amp;gt;
     * If there is one or more idle instance available in the pool, then an
     * idle instance will be selected based on the value of {@link #getLifo()},
     * activated and returned. If activation fails, or {@link #getTestOnBorrow()
     * testOnBorrow} is set to {@code true} and validation fails, the
     * instance is destroyed and the next available instance is examined. This
     * continues until either a valid instance is returned or there are no more
     * idle instances available.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If there are no idle instances available in the pool, behavior depends on
     * the {@link #getMaxTotal() maxTotal}, (if applicable)
     * {@link #getBlockWhenExhausted()} and the value passed in to the
     * {@code borrowMaxWaitMillis} parameter. If the number of instances
     * checked out from the pool is less than {@code maxTotal,} a new
     * instance is created, activated and (if applicable) validated and returned
     * to the caller. If validation fails, a {@code NoSuchElementException}
     * is thrown.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * If the pool is exhausted (no available idle instances and no capacity to
     * create new ones), this method will either block (if
     * {@link #getBlockWhenExhausted()} is true) or throw a
     * {@code NoSuchElementException} (if
     * {@link #getBlockWhenExhausted()} is false). The length of time that this
     * method will block when {@link #getBlockWhenExhausted()} is true is
     * determined by the value passed in to the {@code borrowMaxWaitMillis}
     * parameter.
     * &amp;lt;/p&amp;gt;
     * &amp;lt;p&amp;gt;
     * When the pool is exhausted, multiple calling threads may be
     * simultaneously blocked waiting for instances to become available. A
     * &quot;fairness&quot; algorithm has been implemented to ensure that threads receive
     * available instances in request arrival order.
     * &amp;lt;/p&amp;gt;
     *
     * @param borrowMaxWaitMillis The time to wait in milliseconds for an object
     *                            to become available
     *
     * @return object instance from the pool
     *
     * @throws NoSuchElementException if an instance cannot be returned
     *
     * @throws Exception if an object instance cannot be returned due to an
     *                   error
     */
     /*
     当getBlockWhenExhausted()返回true时，需要提供等待时间从对象池中借出对象，
     如果有1个或多个空闲实例的话，就通过getLifo()方法，也就是先进先出的策略选择由哪个空闲实例承接工作。如果激活失败了，或者testOnBorrow设置为true并且检测失败了，这个实例就会销毁，接下来由下一个可用实例进行承接。这个流程一直持续，直到没有可用的实例可供使用或者没有空闲实例可供使用。
     如果在对象池中没有空闲实例了，接下来的走向取决于maxTotal,getBlockWhenExhausted()和传进来的等待时间参数决定。如果当前对象池中的实力数量小于maxtotal，一个新的实例将被创建，激活并且检测最终返回给调用者。如果检测失败，一个NoSuchElementException异常将被抛出。
     如果对象池已经占满了（也就是说没有可用的空闲实例并且没有容量可以被创建），这个方法要不堵塞（如果getBlockWhenExhausted设置为true的情况下才会堵塞）要不就抛出一个NoSuchElementException（相反getBlockWhenExhausted为false的情况）异常。具体阻塞的时间跟传入的borrowMaxWaitMillis时间大小有关。（还记得刚才说的maxWait的设置么？）
     当对象池已经耗尽，多个调用线程将被同时堵塞，他们一起等待可用的jedis实例接客。接客的规则采用公平算法。其实就是先到先被接~哈哈
     */
    public T borrowObject(final long borrowMaxWaitMillis) throws Exception {
        //这一步就是检查一下对象池的状态，如果之前已经关闭了，就会抛出IllegalStateException异常。
        assertOpen();
        //移除已经被抛弃的实例
        final AbandonedConfig ac = this.abandonedConfig;
        if (ac != null &amp;amp;&amp;amp; ac.getRemoveAbandonedOnBorrow() &amp;amp;&amp;amp;
                (getNumIdle() &amp;lt; 2) &amp;amp;&amp;amp;
                (getNumActive() &amp;gt; getMaxTotal() - 3) ) {
            /*
            被抛弃的实例不为null
            borrow时去除被抛弃的实例
            空闲线程实例&amp;lt;2
            当前活动的实例数量大于最大实例数量-3
            */
            removeAbandoned(ac);
        }
        //定义一个PooledObject类型的对象，T是真正的实例对象。如jedis，db等。
        PooledObject&amp;lt;T&amp;gt; p = null;

        // Get local copy of current config so it is consistent for entire
        // method execution
        /*
        获取一个本地的拷贝，这个拷贝是目前的配置。这样就能够保证整体的一致性。
        这个getBlockWhenExhausted()最终是获取的一个volatile类型的值，这个值是从配置中获取的，代表当线程池满时，是否对新来的任务给予堵塞。但是，我们得注意volatile这个类型了，而且设计者在这个地方单独获取出来这个值，肯定是为了什么。接着往下看吧。
        */
        final boolean blockWhenExhausted = getBlockWhenExhausted();
        //是否为新建，请区别于created。为什么仅在这里定义了变量而没有初始化呢？
        boolean create;
        //当前的毫秒，用来就算
        final long waitTime = System.currentTimeMillis();
        //循环开始，第一次p=null开始循环
        while (p == null) {
            //初始化create=false，代表目前这个线程不是新建的。
            create = false;
            /*
            private final LinkedBlockingDeque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleObjects;
            idleObjects是一个阻塞有序队列，队列的类型是刚才的封装类型，封装的是实际的资源。从名字上可以看出，这里叫做空闲对象组
            可以看到，从空闲对象组里拿出第一个元素。pollFirst()是LinkedBlockingDeque.java中的方法。就是通过操作节点来把第一个节点删除并返回。
            */
            p = idleObjects.pollFirst();
            //如果p为空代表弹出的是null，说明没有空闲。那就创建一个新的对象。
            if (p == null) {
                p = create();
                //p可能会创建失败，创建失败的时候 create=false。 创建成功create=true
                if (p != null) {
                    create = true;
                }
            }
            //如果设置了对象池耗尽后堵塞等待的标示
            if (blockWhenExhausted) {
                if (p == null) {
                    //p没有创建成功
                    if (borrowMaxWaitMillis &amp;lt; 0) {
                        //如果没有设置为-1，只有这种情况会符合小于0.所以就直接从空闲对象组中获取第一个有效的空闲对象。这个方法有锁的实现，所以这块可能会一直堵塞着直到有一个空闲对象可以使用。
                        p = idleObjects.takeFirst();
                    } else {
                    //如果设置等待时间了，就在这段时间里获取。超过了就返回null
                        p = idleObjects.pollFirst(borrowMaxWaitMillis,
                                TimeUnit.MILLISECONDS);
                    }
                }
                //到这里如果还是空，就说明没等待到空闲的资源了。所以就要报异常了。
                if (p == null) {
                    throw new NoSuchElementException(
                            &quot;Timeout waiting for idle object&quot;);
                }
            } else {
                //如果没有设置blockWhenExhausted标示且p是null，那真是获取不到资源了，因为池子已经被占满了。
                if (p == null) {
                    throw new NoSuchElementException(&quot;Pool exhausted&quot;);
                }
            }
            /*
            到这里其实p应该不是null了，说明肯定是有资源了。有可能是获得了空闲资源或是创建了一个新的资源。这个时候就要让系统给他分配内存了。跟进allocate()代码中，发现这是一个synchronized方法，保证了线程安全。（这块会有线程安全问题。为什么呢？）方法体判断了当前池状态（空闲状态或者测试中状态）然后更改状态位，置lastBorrowTime,lastUseTime,borrowedCount++等，然后返回boolean。
            我们可以推算出，当前的池资源状态可能会被另一个线程改写。有一种情况就是，空闲的连接还需要进行test和validate才能够正确分配。但是如果在test或validate阶段失败了，那线程就不能够被分配资源了，因为前后状态不一致了。所以需要allocate的同步操作来保证当时的空闲资源不被改写。
            */
            if (!p.allocate()) {
                //没有成功分配资源，当然p就应该置为null，等待重新进行遍历。
                p = null;
            }
            //到这里，分配成功的p应该进行校验阶段了。没有成功分配的p目前还是null，所以跳过下面的判断。
            if (p != null) {
                //从这开始p是有资源了
                try {
                    /*
                    private final PooledObjectFactory&amp;lt;T&amp;gt; factory;
                    通过池工厂（PooledObjectFactory.java）对返回来的实例重新初始化。因为PooledObjectFactory是个接口。所以，我以Jedis为T进行解析（JedisFactory.java），别的实际类型会有不同的行为，但是基本差不多。
        这个方法里就是获取了BinaryJedis，判断当前的库是不是库0.如果不是就就简单做个select操作。如果是的话什么都不做。
                    这块的设计有一个小心思，就是作者用这种代码结构来给开发者留出了很大的实现空间。
                    */
                    factory.activateObject(p);
                } catch (final Exception e) {
                    //激活异常
                    try {
                        //摧毁对象，释放资源
                        destroy(p, DestroyMode.NORMAL);
                    } catch (final Exception e1) {
                        // 摧毁的程序都报异常了，我可管不了了。采取鸵鸟算法。
                    }
                    //help GC
                    p = null;
                    //如果是新建的资源，就说明分配成功，但是激活失败。抛个错吧。
                    if (create) {
                        final NoSuchElementException nsee = new NoSuchElementException(
                                &quot;Unable to activate object&quot;);
                        //用什么错误原因呢？就用上面这个吧
                        nsee.initCause(e);
                        throw nsee;
                    }
                }
                /*
                如果分配成功了， 激活也成功了，并且开启了TestOnBorrow，逻辑进来再让我蹂躏下吧。如果失败了跳过这个逻辑吧。
                testOnBorrow的目的是不论资源是否是从池子里借的，都要在返回钱进行一次验证。如果失败了资源会被清除出池子并且毁掉。然后再向池对象尝试借一次。
                */
                if (p != null &amp;amp;&amp;amp; getTestOnBorrow()) {
                    boolean validate = false;
                    Throwable validationThrowable = null;
                    try {
                    /*
                    我依然以JedisFactory.java分析吧。
                    依然是首先获取一个BinaryJedis资源。判断连接的Port和设置的port是否相等。判断连接的host和设置额host是否相等。相等就返回true。否则就返回false。
                    */
                        validate = factory.validateObject(p);
                    } catch (final Throwable t) {
                        PoolUtils.checkRethrow(t);
                        validationThrowable = t;
                    }
                    //如果检查没有通过依然是摧毁。如果是新建的就报错。和上面激活的流程一样。
                    if (!validate) {
                        try {
                            destroy(p, DestroyMode.NORMAL);
                            destroyedByBorrowValidationCount.incrementAndGet();
                        } catch (final Exception e) {
                            // Ignore - validation failure is more important
                        }
                        p = null;
                        if (create) {
                            final NoSuchElementException nsee = new NoSuchElementException(
                                    &quot;Unable to validate object&quot;);
                            nsee.initCause(validationThrowable);
                            throw nsee;
                        }
                    }
                }
            }
        }
        //恭喜获得了一个有效的p资源。然后统计一下数据吧，比如消耗时间。
        updateStatsBorrow(p, System.currentTimeMillis() - waitTime);
        //返回吧。记住返回的是一个PooledObject对象。真正的资源需要通过getObject(）获取。
        return p.getObject();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，看懂了jedis是如何从连接池中拿到资源的了。这里面经常有一些线程安全的判断，这也是难点所在，因为池化技术最重要的功能就是对线程资源的管理与利用。所以，代码中用了很多sychronize方法。不光这些，作者还要考虑到资源的释放和销毁还有扩展。&lt;/p&gt;

&lt;p&gt;　　最后看到了getObject()方法。为什么作者不直接暴露资源呢？为什么还要包一层呢？接下来我来分析一下吧。PooledObject是一个接口，我们先看看接口的描述是什么。详情看我的之前一篇文章&lt;a href=&quot;https://www.naffan.cn/tech/2021/05/13/01.html&quot;&gt;common-pool对象池学习&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Defines the wrapper that is used to track the additional information, such as
 * state, for the pooled objects.
 * &amp;lt;p&amp;gt;
 * Implementations of this class are required to be thread-safe.
 * &amp;lt;/p&amp;gt;
 *
 * @param &amp;lt;T&amp;gt; the type of object in the pool
 *
 * @since 2.0
 */
 /*
 定义一个封装结构，这个封装结构使用来记录额外信息的。比如池资源的状态等。
 实现这个接口的class文件必须是线程安全的。（为什么呢？）
 
 */
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42340670/article/details/106876879&quot;&gt;对象池：commons-pool2源码解析：GenericObjectPool的borrowObject方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="redis,java" /><summary type="html">　　我们在开发的时候经常会用到redis。java中首选的redis客户端是jedis。jedis封装了redis的所有功能，并且提供了更多额外好用的功能。</summary></entry><entry><title type="html">common-pool对象池学习</title><link href="http://localhost:4000/tech/2021/05/13/01.html" rel="alternate" type="text/html" title="common-pool对象池学习" /><published>2021-05-13T00:00:00+08:00</published><updated>2021-05-13T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/13/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/13/01.html">&lt;blockquote&gt;
  &lt;p&gt;问如果你要设计一个池化对象，你会怎么做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　设计一个T类型的池子，把T类型的资源都放到池子中。资源负责资源的事情，池子负责管理资源。管理池子要做到资源数量的管理，资源状态的管理，资源创建和销毁，线程安全，资源记录。还要考虑到复用的可能。&lt;/p&gt;

&lt;p&gt;　　让我们看看common-pool2的组成部分吧：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ObjectPool: 存取和状态管理的实现。我们直接操作的线程池就是在这里定义的。这里定义的是如何获取和释放对象等操作。至于具体创建对象的代码，是由PooledObjectFactory来负责的。&lt;/li&gt;
  &lt;li&gt;PooledObject: 将真正的资源进行封装，封装的过程中添加一些附加信息，比如状态信息，时间等信息。这些信息方便再操作连接资源时完成特定的操作。&lt;/li&gt;
  &lt;li&gt;PooledObjectFactory:创建，初始化，销毁对象的具体实现的地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/hdic.t_m/p/image-distinguish/08e792838506108fff0318c10420d0022801300138d233.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//一个简单的池结果。它继承了Closeable接口，也就是说是可以关闭的数据源或目标。T是实际存在于池中的类型。
public interface ObjectPool&amp;lt;T&amp;gt; extends Closeable{
    
    //通过PooledObjectFactory创建对象或者通过其他机制放入空闲池对象。addObject也用来预热空闲池。
    void addObject() throws Exception, IllegalStateException,
            UnsupportedOperationException;
            
    //传入参数count，调用count次addObject。 方法的类型是default，也就是说这个方法直接实现方法体，不用实现者实现这个方法。
    default void addObjects(final int count) throws Exception {
        for (int i = 0; i &amp;lt; count; i++) {
            addObject();
        }
    }
    
    /*
    从对象池中获取一个实例。
    创建的实例要不是通过PooledObjectFactory中makeObject()新建出来的，要不就是用了前一个已经被PooledObjectFactory中activateObject()和PooledObjectFactory中validateObject()的空闲对象。
    activateObject()和validateObject()这两个方法需要在不同的池类型文件中自己去实现。
    */
    T borrowObject() throws Exception, NoSuchElementException,
            IllegalStateException;
    
    //清除随机对象放回到池中作为空闲对象。释放这个对象的相关引用资源。在clear之前一定是经过PooledObjectFacotry的destroyObject()过。
     void clear() throws Exception, UnsupportedOperationException;
     
    //继承自Closeable接口，负责关闭并释放有关联系的系统资源。如果之前已经关闭了， 则调用此方法无效。
    @Override
    void close();
    
    //返回当前有多少实例从池对象中被借出了。如果返回的是负数代表这个信息不可用。
    int getNumActive();
    
    //返回当前当前池中有多少空闲对象。这个值是一个近似值，因为他只代表还没有创建成新资源的被借走的对象。我理解的是还没有被分配内存地址（allocate）。
    int getNumIdle();
    
    /*
    使池中对象失效
    按照约定，参数obj必已经被borrwoObject()或者被一个定义在子实现类中定义的方法实现了获取逻辑的对象。如果失败了就返回异常
    */
     void invalidateObject(T obj) throws Exception;
     
     //比上面多了一个DestoryMode。DestoryMode是个枚举，分别为普通摧毁和被禁的摧毁。最终调用的是PooledObjectFactory的destoryObject()。但不知为啥，我发现其实mode参数最终没有用上……。往下看，看到工厂的destoryObject（）
     default void invalidateObject(final T obj, final DestroyMode mode) throws Exception {
        invalidateObject(obj);
    }
    
    /*
    返回一个池对象中的实例。同invalidateObject()
    异常中会抛出IllegalStateException。原因是如果有任何（把除了已经被分配内存的有状态的资源，即被借出了的。或者返回一个对象超过一次以上或者返回一个从未被借出过的对象）操作就会触发这个异常
    */
     void returnObject(T obj) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
用来定义池对象的一个wrapper 接口，用于跟踪对象的附加信息，比如状态、创建时间、使用时间等。这个类的实现必须是线程安全的。
*/
public interface PooledObject&amp;lt;T&amp;gt; extends Comparable&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; {

    //返回被包装的实际对象
    T getObject();

    //返回该对象的创建时间
    long getCreateTime();
    
    //以毫秒为单位获得该对象最后在活动状态中使用的时间(它可能仍然处于活动状态，在这种情况下后续调用将返回一个增加的值)。
    long getActiveTimeMillis();

    //借出的次数
    default long getBorrowedCount() {
        return -1;
    }

    //空闲时间
    long getIdleTimeMillis();

    //上次借用时间
    long getLastBorrowTime();

    //上次归还时间
    long getLastReturnTime();

     /**
     * 返回上次使用时间的一个估计值,如果Pooled Object实现了TrackedUse接口
     * 那么返回值将是TrackedUse.getLastUsed()和getLastBorrowTime()的较大者，
     * 否则返回值和getLastBorrowTime()相等
     */
    long getLastUsedTime();

     /*
     因为接口继承了Comparable接口。所以这个接口需要实现自己的排序逻辑。
     默认是按照空闲时间排序的。
     */
    @Override
    int compareTo(PooledObject&amp;lt;T&amp;gt; other);

    @Override
    boolean equals(Object obj);

    @Override
    int hashCode();

    @Override
    String toString();

    //尝试将池对象置于PooledObjectState.EVICTION状态，即收回
    boolean startEvictionTest();

     //是否完成了收回测试
    boolean endEvictionTest(Deque&amp;lt;PooledObject&amp;lt;T&amp;gt;&amp;gt; idleQueue);

    //分配内存，这个比较重要。因为连接池中的资源被分配后才能算真正的解除。分配内存的过程中可能会出现抢占资源的情况，所以会发生异常。反正，最终返回ture/false来代表是否分配内存成功，即完成了borrow，状态改为PooledObjectState.ALLOCATED
    boolean allocate();

    //与上面一个方法作用相反,将PooledObjectState.ALLOCATED置为PooledObjectState.IDLE
    boolean deallocate();

    //将对象置为PooledObjectState.INVALID无效状态
    void invalidate();

    //设置是否记录对象使用的堆栈信息,可用于池泄漏时问题追溯
    void setLogAbandoned(boolean logAbandoned);

     /*
     设置记录堆栈信息时的策略，是全量还是只记泄露的信息。
     设置为false时，泄露信息只包括调用类的信息而不是方法名。
     设置为数字时，制使用包含完整堆栈跟踪信息的堆栈遍历机制；否则，如果可能，使用更快的实现。
     参数是自common-pool2-2.7.0开始有的。
     */
    default void setRequireFullStackTrace(final boolean requireFullStackTrace) {
        // noop
    }

     //记录当前对象最后一次使用的堆栈信息
    void use();

    //打印对象的调用堆栈信息
    void printStackTrace(PrintWriter writer);

    //返回对象目前的状态
    PooledObjectState getState();

    //标记该对象发生了泄漏
    void markAbandoned();

    //标记该对象正在被归还到对象池
    void markReturning();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
这个接口主要提供给ObjectPool接口使用。因为这个接口定义了池中对象的生命周期相关的所有方法。
按照约定，以下情况ObjectPool会代理到PooledObjectFactory中：
1.不论何时创建一个实例调用makeObject()时
2.当实例在借出之前，已经处于passivated，每次实例在调用activateObject时
3.当一个实例被激活时。当一个实例已经返回到池里并且正在做检查，又在passivated（卸载）之前时。当acitvated实例且确定能被借出时
4.每个实例返回到连接池后，在调用passivateObject()时
5.当实例正在从池中销毁时，destoryObject()调用时

这个工厂必须确保线程安全，工厂只需要ObjectPool保证操作的实际类型和工厂一致即可。
*/
public interface PooledObjectFactory&amp;lt;T&amp;gt; {
  
   //创建一个资源实例，这个资源实例可以被封装起来。
  PooledObject&amp;lt;T&amp;gt; makeObject() throws Exception;

   /*
   销毁一个不再被池子需要的实例。用的销毁模式是normal。
   实现了这个方法的类需要注意的是：方法内没有任何保证资源处于什么状态和实现的方法如何去处理非预期的errors
   所以，实现者需要考虑到对象没有被摧毁，即被垃圾收集器忘掉了，从而永远储存在了内存中。
   */
  void destroyObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //同上，只是采用了DestoryMode模式。但是其实感觉是mode根本没用用上。。。
  default void destroyObject(final PooledObject&amp;lt;T&amp;gt; p, final DestroyMode mode) throws Exception {
      destroyObject(p);
  }

  //确保实例能够安全的返回到池子里
  boolean validateObject(PooledObject&amp;lt;T&amp;gt; p);

   //重新初始化池返回的实例
  void activateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;

   //卸载要返回到空闲对象池的实例
  void passivateObject(PooledObject&amp;lt;T&amp;gt; p) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　至此，我分析完了三个接口。三个接口各司其职，互相协助。我用一张我画的图片来描述的话，一个管对象的打包，一个管对象的创建，一个管对象的进出口。用jedis举例的话就是，jedis资源打包成封装格式，封装格式被工厂创建，创建成真正使用的资源。这些资源再被借出或者归还。多么的形象哈哈。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08eede83850610aaa80818b90e20b8082801300138e0f401.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　下面这张图是这三个接口相关的关系。
&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08cbdf83850610abd30818850620bb032801300138af8401.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;我画的&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　另外，上面的接口都用到了对象的状态，对象状态如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public enum PooledObjectState {
    /**
     * 在队列中,未被使用,空闲状态。调用allocate()方法后对象应该被置于该状态
     */
    IDLE,

    /**
     * 已分配,在使用中,调用allocate()方法后应该讲对象置于该状态
     */
    ALLOCATED,

    /**
     * 在队列中, 当前正在测试，可能会被回收。在此状态被借出后状态回被置为EVICTION_RETURN_TO_HEAD
     */
    EVICTION,

    /**
     * 不在队列中。当借用该对象时发现对象，发现正在进行回收测试，故将EVICTION更
     * 改EVICTION_RETURN_TO_HEAD，表明曾经在回收过程中被借出，在回收完后它应该从新添加到队列的头部。
     */
    EVICTION_RETURN_TO_HEAD,

    /**
     * 在队列中,目前正在进行校验
     */
    VALIDATION,

    /**
     * 不在队列中，当前正在验证。当对象从池中被借出，
     * 在配置了testOnBorrow的情况下，对像从队列移除和进行预分配的时候会进行验证(借用时校验)
     */
    VALIDATION_PREALLOCATED,

   /**
     * 不在队列中，正在进行验证。从池中借出对象时，发现对象正在进行校验，并将对象状态改为该状态
     */
    VALIDATION_RETURN_TO_HEAD,

    /**
     *无效的，并且将要或已经被销毁。
     */
    INVALID,

    /**
     * 泄漏的
     */
    ABANDONED,

    /**
     *归还中,调用markReturning()方法会将对象状态改为此状态，表明正在归还一个对象
     */
    RETURNING
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq447995687/article/details/80413227&quot;&gt;commons-pool2源码走读(一)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liyantianmin/article/details/86591742&quot;&gt;common-pool对象池&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="pool,java" /><summary type="html">问如果你要设计一个池化对象，你会怎么做？</summary></entry><entry><title type="html">池化技术</title><link href="http://localhost:4000/tech/2021/05/12/01.html" rel="alternate" type="text/html" title="池化技术" /><published>2021-05-12T00:00:00+08:00</published><updated>2021-05-12T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/12/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/12/01.html">&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a3a3f5840610fee80b18b90e20b8082801300138d074.jpeg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;池化技术&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　池化技术就是把一些能复用的实例放在一起，一般指的是内存里，而池这个概念也是一个虚拟的概念。这样做的好处是省去了每次消耗在新建、销毁这些实例的时间，从而提高了整体服务性能。在开发中，我们经常遇到的就是数据库的连接池和多线程的线程池。连接池的管理是核心。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;数据库连接池&quot;&gt;数据库连接池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　数据库包括关系型数据库和非关系型数据库两种。关系型数据库指的是mysql，非关系型数据库指的是redis。&lt;/p&gt;

&lt;p&gt;　　mysql连接池有两个重要的配置：最小连接数和最大连接数。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前连接数小于最小连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;如果连接池中有空闲连接，则使用空闲连接。
3。 如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接。这等价于建立一个新的连接。这些连接使用完成不会立马清除，而是放在池中等待复用最终空闲超过一段时间后自动释放。&lt;/li&gt;
  &lt;li&gt;如果当前连接数大于等于最大连接数，并且没有空闲连接了，则进入等待队列，在超时时间内等待空闲连接。&lt;/li&gt;
  &lt;li&gt;超时之后，则提示超时失败。获取数据库连接失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　redis连接池有3个重要的配置：最大连接数，最小空闲数，最大空闲数&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当前连接小于最大连接数，则创建新的连接处理请求。&lt;/li&gt;
  &lt;li&gt;当前连接数大于等于最大连接数，超出的连接进入等待队列&lt;code&gt;LinkedBlockingDeque&lt;/code&gt;，判断是否开启&lt;code&gt;blockWhenExhausted&lt;/code&gt;，是则等待获取连接，否则抛错连接池已耗尽。&lt;/li&gt;
  &lt;li&gt;当前连接数小于最小空闲数，则预热最小空闲数连接。&lt;/li&gt;
  &lt;li&gt;当前连接数大于最大空闲数，则强制销毁这些多出来的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;线程池&quot;&gt;线程池&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　JDK1.5中引入的ThreadPoolExecutor就是一种线程池的实现，它有两个重要的参数：coreThreadCount和maxThreadCount。这两个参数控制着线程池的执行过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前线程数少于coreThreadCount时，则创建新的线程处理请求。&lt;/li&gt;
  &lt;li&gt;如果当前线程数大于coreThreadCount则将超出的任务进队列，由当前空闲的线程执行。&lt;/li&gt;
  &lt;li&gt;当队列中的任务对接满时，则继续创建线程，直到maxThreadCount。&lt;/li&gt;
  &lt;li&gt;当前线程数达到maxThreadCount时还有新的任务，就将其按照抛弃策略进行抛弃。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://tva1.sinaimg.cn/large/0082zybpgy1gc7xbdxj67j30wk0ouqb3.jpg&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JDK线程池提交任务示意图&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　连接池和线程池在开发过程中并不陌生，但是想真正弄懂他们还是需要借助阅读源码的帮助。在使用上如果遇到了一些困惑的话，可以查阅相关资料或者探索源码如何解决的。&lt;/p&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java" /><summary type="html">一种优化连接的方案，各种地方都有可能用到这种技术</summary></entry><entry><title type="html">拿饭网对JVM的解析和总结</title><link href="http://localhost:4000/tech/2021/05/11/01.html" rel="alternate" type="text/html" title="拿饭网对JVM的解析和总结" /><published>2021-05-11T00:00:00+08:00</published><updated>2021-05-11T00:00:00+08:00</updated><id>http://localhost:4000/tech/2021/05/11/01</id><content type="html" xml:base="http://localhost:4000/tech/2021/05/11/01.html">&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;java虚拟机&quot;&gt;Java虚拟机&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　java虚拟机（java virtual machine,JVM），一种能够运行java字节码的虚拟机。作为一种编程语言的虚拟机啊，实际上不知是专用于java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。&lt;/p&gt;

&lt;p&gt;　　java源代码被编译成&lt;code&gt;字节码&lt;/code&gt;-&lt;code&gt;一个.class的文件&lt;/code&gt;。编译的时候class文件会被VM翻译。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;一次编译，各地运行&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm的基本结构&quot;&gt;JVM的基本结构&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　JVM由三个主要的子系统构成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类加载子系统&lt;/li&gt;
  &lt;li&gt;运行时数据区（内存结构）&lt;/li&gt;
  &lt;li&gt;执行引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm架构&quot;&gt;JVM架构&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　首先，先我们看一看架构图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://javatutorial.net/wp-content/uploads/2017/10/jvm-architecture.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JVM架构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们，先说一下class loader subsystem。首先，loading一共有三个class loader类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;loading&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Bootstrap Class Loader – 加载JDK内部类，比如rt.jar和类似&lt;code&gt;java.lang.*&lt;/code&gt;这样的核心类。&lt;/li&gt;
  &lt;li&gt;Extensions Class Loader – 从JDK的扩展目录加载类。&lt;/li&gt;
  &lt;li&gt;System Class Loader – 从系统设定的classpath加载类，可以在程序启动时通过-cp或者-classpath指令进行设置。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;linking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　其次，linking是链接一个类或接口时包括验证和准备这个类或接口的直接超类、直接超接口及必要时的元素类型。JVM需要满足以下点才能够连接：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;类或接口在被链接之前会被完全加载。&lt;/li&gt;
  &lt;li&gt;在初始化类或接口之前，会对其进行完全的验证和准备。&lt;/li&gt;
  &lt;li&gt;不论因为直接还是间接的代码中包含的连接错误能够被侦察到。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Initialization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　类或接口的初始化包括执行它的类或接口初始化方法或调用类的构造函数。因为Java虚拟机是多线程的，所以类或接口的初始化需要小心地同步，因为其他一些线程可能试图同时初始化相同的类或接口。同时，这是Class Loading的最后一个阶段，这里所有静态变量都将被赋值为原始值，并且静态块将被执行。&lt;/p&gt;

&lt;p&gt;　　我们学习JVM最重要的部分就是运行时数据区。如图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://cdn.jikewenku.com/wp-content/uploads/2021/01/74e01322f26270ccfe235ead6215d271.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JVM运行时数据区域&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.程序计数器：每个线程都有独立的PC寄存器，以保存当前执行指令的地址，一旦指令被执行，PC寄存器将被下一条指令更新。&lt;/p&gt;

&lt;p&gt;2.虚拟机栈：java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧压入栈，当方法&lt;code&gt;正常返回&lt;/code&gt;或者&lt;code&gt;抛出未捕获的异常&lt;/code&gt;时，栈帧就会出栈。&lt;/p&gt;

&lt;p&gt;（1）栈帧：栈帧存储方法的相关信息，包好局部变量表、发回执、操作数栈、动态链接。&lt;/p&gt;

&lt;p&gt; a.局部变量表：包含了方法执过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。&lt;/p&gt;

&lt;p&gt;b.返回值：如果有的话，压入调用者栈帧中的操作数栈中，并且把pc的值指向方法调用指令后面的一条指令地址。&lt;/p&gt;

&lt;p&gt;c.操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定。&lt;/p&gt;

&lt;p&gt;d.动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。&lt;/p&gt;

&lt;p&gt;（2）线程私有&lt;/p&gt;

&lt;p&gt;3.本地方法栈：本地方法堆栈保存本地方法信息。对于每个线程，将创建一个单独的本机方法堆栈。&lt;/p&gt;

&lt;p&gt;4.方法区：所有类级别的数据都将存储在这里，包括静态变量。每个JVM只有一个方法区域，它是一个共享资源。&lt;/p&gt;

&lt;p&gt;5.堆：所有对象及其对应的实例变量和数组都将存储在这里。每个JVM也有一个堆区域。由于方法和堆区域为多个线程共享内存，存储的数据不是线程安全的。&lt;/p&gt;

&lt;p&gt;（1）java堆是虚拟机管理的内存中最大的一块&lt;/p&gt;

&lt;p&gt;（2）java堆是所有线程共享的区域&lt;/p&gt;

&lt;p&gt;（3）在虚拟机启动时创建&lt;/p&gt;

&lt;p&gt;（4）此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组。&lt;/p&gt;

&lt;p&gt;（5）java堆是垃圾收集器管理的内存区域。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;不同变量存储的位置&quot;&gt;不同变量存储的位置&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　我们可以把内存理解成可以单独操作字节的字节数组。在内存中的每个字节或者位置，都像Java中的数组一样可以访问。在32位机中，每个内存槽最大支持32位，也就是一个字符或者4个字节。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://javatutorial.net/wp-content/uploads/2019/06/Untitled-1.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;内存模型2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　正如上图所示，4000，4004，4008等等数字代表每个内存槽的地址。这些数字代表32位。因为每个内存槽持有32位，或者说4个字节，每个内存槽的增量是4.&lt;/p&gt;

&lt;p&gt;　　java中有两种类型变量域-全局变量和本地变量。全局变量可以在程序中任何地方访问到，但是本地变量只能通过创建了它的方法才能访问到。这两种变量域分别存储在方法区和虚拟机栈中。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://javatutorial.net/wp-content/uploads/2019/06/regions.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;内存模型2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://javatutorial.net/wp-content/uploads/2019/06/where.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;内存模型3&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void doSomething() {
   int v = 0;
   System.out.println(v);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面代码中的变量v是在方法中创建的，所以他保存在线程的虚拟机栈中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法区&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Example {
   int globalVar = 3;
   public int showVar() {
       return globalVar;
   }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面的代码中，globalVar保存在方法区中。因为他可以被方法获取到，所以他是可以被整个系统获取到的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;堆&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Person {
    int pid;
    String name;
    public Person(int id, String name) {
       this.pid = id;
       this.name = name;
    }
}

public class Driver {
    public static void main(String[] args) {
        int id = 1;
        String pName = &quot;Rick&quot;;
        Person p = new Person(id, pName);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在上面的代码中我们可以看到，我们创建了Person的实例并储存在变量p中，本质上，我们使用堆区来动态分配内存，我们需要使用new关键字创建这样一个实例。换句话说，我们确定不了这个实例的确切大小。无论实例有多少字节，如果有足够的内存(可能会有)，该实例将被创建，并且只保留创建它所需的字节量。&lt;/p&gt;

&lt;p&gt;　　java其实帮助我们解决了很多动态分配内存的棘手问题，相比C语言来说，C语言必须自己去清除内存。所以说，java的垃圾回收是幕后的，简单到只需要我们触发关键词就可以完成清除内存的目的。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;虚拟机栈&quot;&gt;虚拟机栈&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　首先，我们先看一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public class Demo {

    public int math() {
        int a = 1;
        int b = 2;
        int c = (a + b) * 10;
        return c;
    }

    public static void main(String[] args) {
        Demo demo = new Demo();
        demo.math();
    }
}

/*
java -c Demo.java后，会生成Demo.class
javap -c Demo，进行反编译，结果如下，让我们来分析一下这段程序就可以了解大概虚拟机栈的原理了。
*/

Compiled from &quot;Demo.java&quot;
public class Demo {
  public Demo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
       4: return

  public int math();
    Code:
       0: iconst_1//push
       1: istore_1
       2: iconst_2
       3: istore_2
       4: iload_1
       5: iload_2
       6: iadd
       7: bipush        10
       9: imul
      10: istore_3
      11: iload_3
      12: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class Demo
       3: dup
       4: invokespecial #3                  // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
       7: astore_1
       8: aload_1
       9: invokevirtual #4                  // Method math:()I
      12: pop
      13: return
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　经过反编译后，我们可以看到虚拟机的代码了。那么，分别是什么意思呢？我们可以参考&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.istore&quot;&gt;手册&lt;/a&gt;来分析，分析的过程我在图片中给出了。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08fc9bd285061080bc0e18d21220a5082801300138e51c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;编译过程分析&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　在图中的最后，我们看到ireturn语句，他的意思就是将结果返回。具体返回到那里呢，程序会去程序计数器中查找上一个栈帧的地址，结果就是返回给这个栈帧的。原理是，这段代码是首先调用的main函数，然后调用的math方法。所以，程序计数器会保存着这个关系，同样每段代码的顺序也会被程序计数器记录住。也就说，线程中程序运行到了哪里和从哪运行的都会在这个地方记录着。如果我们考虑多线程的情况，在一个线程运行过程中cpu的时间片到了，于是cpu把下一个时间片分给了新的线程。这个时候程序计数器也会记录住前一个线程运行到了哪里，新的线程从原先旧的线程中何时开始的，结束完成后还需要跳回旧线程中继续执行代码。&lt;/p&gt;

&lt;p&gt;如果我们把程序改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Demo {

    public int math() {
        int a = 1;
        int b = 2;
        Object obj = new Object(); //加入个实例
        int c = (a + b) * 10;
        return c;
    }

    public static void main(String[] args) {
        Demo demo = new Demo();
        demo.math();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们通过&lt;code&gt;javap -v Demo&lt;/code&gt;来看看,可以看到输出的信息比上边的多了很多。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Classfile Demo.class
  Last modified 2021-5-11; size 599 bytes
  MD5 checksum b0253c6a0b3c51e6d1a72e8cc76da634
  Compiled from &quot;Demo.java&quot;
public class Demo
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #2.#28         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #2 = Class              #29            // java/lang/Object
   #3 = Class              #30            // Demo
   #4 = Methodref          #3.#28         // Demo.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #5 = Methodref          #3.#31         // Demo.math:()I
   #6 = Utf8               &amp;lt;init&amp;gt;
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               LDemo;
  #13 = Utf8               math
  #14 = Utf8               ()I
  #15 = Utf8               a
  #16 = Utf8               I
  #17 = Utf8               b
  #18 = Utf8               obj
  #19 = Utf8               Ljava/lang/Object;
  #20 = Utf8               c
  #21 = Utf8               main
  #22 = Utf8               ([Ljava/lang/String;)V
  #23 = Utf8               args
  #24 = Utf8               [Ljava/lang/String;
  #25 = Utf8               demo
  #26 = Utf8               SourceFile
  #27 = Utf8               Demo.java
  #28 = NameAndType        #6:#7          // &quot;&amp;lt;init&amp;gt;&quot;:()V
  #29 = Utf8               java/lang/Object
  #30 = Utf8               Demo
  #31 = NameAndType        #13:#14        // math:()I
{
  public Demo();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
         4: return
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LDemo;

  public int math();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=5, args_size=1
         0: iconst_1
         1: istore_1
         2: iconst_2
         3: istore_2
         4: new           #2                  // class java/lang/Object
         7: dup
         8: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
        11: astore_3
        12: iload_1
        13: iload_2
        14: iadd
        15: bipush        10
        17: imul
        18: istore        4
        20: iload         4
        22: ireturn
      LineNumberTable:
        line 9: 0
        line 10: 2
        line 11: 4
        line 12: 12
        line 13: 20
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  this   LDemo;
            2      21     1     a   I
            4      19     2     b   I
           12      11     3   obj   Ljava/lang/Object;
           20       3     4     c   I

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #3                  // class Demo
         3: dup
         4: invokespecial #4                  // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
         7: astore_1
         8: aload_1
         9: invokevirtual #5                  // Method math:()I 
        12: pop
        13: return
      LineNumberTable:
        line 17: 0
        line 18: 8
        line 19: 13
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      14     0  args   [Ljava/lang/String;
            8       6     1  demo   LDemo;
}
SourceFile: &quot;Demo.java&quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　因为上边的输出太多，本来我想写在代码旁边用注释的形式备注，但是因为顺序是跳跃的，所以用这种方法不太好解释。所以，我还是准备写在下边，因为这样的形式可以保证时间线清晰。&lt;/p&gt;

&lt;p&gt;　　首先，我们发现在代码编译期，就有了&lt;code&gt;Constant pool&lt;/code&gt;常量池了。那常量池是什么呢？他是java文件被编译成.class文件时，存储这些class文件的资源库。其主要存放两大类常亮：&lt;code&gt;字面量&lt;/code&gt;（文本字符串、声明为final的常量值等）和&lt;code&gt;符号引用&lt;/code&gt;（有三类：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）。&lt;/p&gt;

&lt;p&gt;　　除了常量池以外，还有个运行时常量池。运行时常量池是方法区的一部分，class文件中的常量池在类加载后进入方法区的运行时常量池存放。他具有动态性，为什么这么说呢？因为class文件一旦编译后，class常量池就确定了。但是运行时常量池在运行期间有可能有新的常量存入池中。&lt;/p&gt;

&lt;p&gt;　　在main()中，我们看到&lt;code&gt;9: invokevirtual #5&lt;/code&gt;这行，这代表我们调用了constant pool中的#5。#5代表这是一个方法引用，在虚拟机栈的栈帧的局部变量表中，就会生成一个ref并指向方法区中的Demo.math()，通过符号引用就实现了直接引用。其他的同理。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;本地方法栈&quot;&gt;本地方法栈&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　本地方法栈和虚拟机方法栈看起来感觉很像是不是？没错，其实就是很像，只是本地方法栈是由本地系统控制的方法栈。作为java程序员你并不能看到这个栈实际发生了什么，因为系统属于底层，底层是由C写的。那java什么时候会触发系统级的指令呢？让我们看下thread的实现吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //src.zip/java/lang/Thread
    public class Thread implements Runnable {
    
        …………
        
        private native void start0();
        
        public static native Thread currentThread();
        
        public static native void yield();
        
        …………
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　我们可以看到很多个native修饰的方法，java中会用这个关键词来修饰那些调用底层C方法的方法。本地方法栈就是为了这些方法而存在的。意思就是通过系统级方法来实现java想要实现的功能，所以本地方法栈被设计到了JVM中。&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jmm-java内存模型&quot;&gt;JMM Java内存模型&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　Java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量（堆内存中的实例域，静态域和数组元素）来完成隐式通信。&lt;/p&gt;

&lt;p&gt;　　Java 内存模型（JMM）控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08a4fbd2850610b1b90d18c305208b042801300138f63c.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;内存模型1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　计算机在高速的 CPU 和相对低速的存储设备之间使用高速缓存，作为内存和处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中。在多处理器的系统中(或者单处理器多核的系统)，每个处理器内核都有自己的高速缓存，它们有共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为此，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议进行操作，来维护缓存的一致性。&lt;/p&gt;

&lt;p&gt;　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量（线程共享的变量）存储到内存中取出变量这样的底层细节。Java内存模型中规定了所有的比那两都存储在主内存中，每条线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。&lt;/p&gt;

&lt;p&gt;　　不同的线程之间是无法直接访问互相的内存中的变量的，线程间的通讯一般有两种方式：1.通过消息传递。2.通过内存共享。java线程间的铜线采用的是共享内存的方式，线程，主内存和工作内存的交互关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08e3c9d3850610eecc0518b70720b2042801300138b0e702.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;内存模型2&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;重排序和happens-before规则&quot;&gt;重排序和happens-before规则&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　在执行程序时为了提高性能，编译器和处理器尝尝会对指令做重排序。重排序分三种类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/li&gt;
  &lt;li&gt;指令集并行的重排序。现代处理器采用了指令集秉性技术（Instruction-Level Parallelism, ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/li&gt;
  &lt;li&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲器，这使得加载和存储操作看上去可能是在乱序执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　从java源代码到最终实际执行的指令序列，会分别经理下面三种重排序：&lt;/p&gt;

&lt;p&gt;源代码 -》 编译器优化重排序 -》 指令集重排序 -》 内存系统重排序 -》 最终执行的指令&lt;/p&gt;

&lt;p&gt;　　JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。&lt;/p&gt;

&lt;p&gt;　　happens-before是从JDK5开始的，java内存模型提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。&lt;/p&gt;

&lt;p&gt;　　如果一个操作执行的结果需要对另一个操作可见，那么这两个操作数之间必须存在happes-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　如果A happens-before B，那么Java内存模型将向程序员保证-A操作的结果将对B可见，且A的执行顺序排在B之前。&lt;/p&gt;

&lt;p&gt;　　重要的happens-before规则如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意后续操作。&lt;/li&gt;
  &lt;li&gt;监视器规则：对一个监视器锁的解锁，happes-before于随后对这个监视器锁的加锁。&lt;/li&gt;
  &lt;li&gt;volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。&lt;/li&gt;
  &lt;li&gt;传递性：如果A happes-before B，且B happens-beforeC，那么A happens-before C。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　下图是happes-before与JMM的关系：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;lazy post-img&quot; data-original=&quot;https://p.ljcdn.com/v1/raw/p/image-distinguish/08dadbd3850610c9aa0818cf0620f2042801300138a5aa03.png&quot; src=&quot;/images/default.jpg&quot; alt=&quot;JMM内存模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　volatile可以说是JVM提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;保证此变量对所有线程的可见性。&lt;/strong&gt;而普通变量不能做到这一点，普通变量1的值在线程间传递均需要通过主内存来完成。volatile虽然保证了可见性，但是java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。而synchronized关键字则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得线程安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;禁止指令重排序优化。&lt;/strong&gt;普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果。而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;堆的内存划分及gc垃圾回收&quot;&gt;堆的内存划分及GC垃圾回收&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　在我之前写过关于堆及GC的文章，请参考&lt;a href=&quot;https://naffan.cn/tech/2020/01/27/01.html&quot;&gt;拿饭网对java垃圾回收大杂烩&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;一般来说survior区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用&lt;code&gt;-Xmn&lt;/code&gt;设置年轻代的大小。&lt;/li&gt;
  &lt;li&gt;对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：&lt;code&gt;-XX:petenureSizeThreshold=1000000&lt;/code&gt;，单位为B，标明对象大小超过1M时，在老年代分配内存空间。&lt;/li&gt;
  &lt;li&gt;一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值（64位机，最多15），就被放到老年代。这个阈值可以通过&lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt;设置。如果想让对象留在年轻代，可以设置比较大的阈值。（通过查看openjdk能够得知对象头文件中有4位决定阈值。所以，这个是跟机器位数有关系的。）&lt;/li&gt;
  &lt;li&gt;设置对小堆和最大堆：&lt;code&gt;-Xmx&lt;/code&gt;和&lt;code&gt;-Xms&lt;/code&gt;稳定的堆大小对垃圾回收是有利的，获得一个稳定的对大小的方法是将这两个设置设成一样的数字，这样的话可以使GC的次数减少。&lt;/li&gt;
  &lt;li&gt;一个不稳定的堆并非毫无用处。在系统不需要使用大内存的时候，压缩堆空间，使得GC每次应对一个较小的堆空间，加快单次GC次数。基于这种考虑，JVM提供两个参数，用于压缩和扩展堆空间。（1）&lt;code&gt;-XX:MinHeapFreeRatio&lt;/code&gt; 参数用于设置堆空间的最小空闲比率。默认值是40，当堆空间的空闲内存比率小于40，JVM便会扩展堆空间。（2）&lt;code&gt;-XX:MaxHeapFreeRatio&lt;/code&gt; 参数用于设置堆空间的最大空闲比率。默认值是70， 当堆空间的空闲内存比率大于70，JVM便会压缩堆空间。（3）当-Xmx和-Xmx相等时，上面两个参数无效。&lt;/li&gt;
  &lt;li&gt;通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。（1）&lt;code&gt;-XX:+UseParallelGC&lt;/code&gt;:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。（2）&lt;code&gt;-XX:+UseParallelOldGC&lt;/code&gt;:设置老年代使用并行垃圾回收收集器。&lt;/li&gt;
  &lt;li&gt;尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统性能。&lt;code&gt;-XX:+LargePageSizeInBytes&lt;/code&gt;设置内存页的大小。&lt;/li&gt;
  &lt;li&gt;使用非占用的垃圾收集器。&lt;code&gt;-XX:UseConcMarkSweepGC&lt;/code&gt;老年代使用CMS收集器降低停顿。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-XX:SurvivorRatio=3&lt;/code&gt;，代表年轻代中的分配比例：survivor:eden = 2:3。&lt;/li&gt;
  &lt;li&gt;JVM性能调优工具：(1)jps(2)jstack(3)jmap(4)jhat(5)jstat(6)visualVM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考文章：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://javatutorial.net/jvm-explained&quot;&gt;jvm-explained&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014395186&quot;&gt;JVM 完整深入解析&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.istore&quot;&gt;javaSe8手册&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/czwbig/p/11127124.html&quot;&gt;Java内存区域（运行时数据区域）和内存模型（JMM）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>张一帆</name></author><category term="tech" /><category term="java,springboot,jvm" /><summary type="html">Java虚拟机</summary></entry></feed>